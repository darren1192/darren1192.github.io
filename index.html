<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="笨鸟先飞，知行合一。">
<meta name="keywords" content="DarrenW">
<meta property="og:type" content="website">
<meta property="og:title" content="DarrenW">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="DarrenW">
<meta property="og:description" content="笨鸟先飞，知行合一。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DarrenW">
<meta name="twitter:description" content="笨鸟先飞，知行合一。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>DarrenW</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DarrenW</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/18/一张图片引发的思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarrenW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarrenW">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/18/一张图片引发的思考/" itemprop="url">一张图片引发的思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-18T14:09:38+08:00">
                2018-10-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>前段时间做微信小程序分享，用了某家的SDK，然鹅……他们家SDK只能上传<code>png</code>、<code>jpeg</code>格式的图片，微信不是可以上传<code>Data</code>吗？？？？<br><img src="https://upload-images.jianshu.io/upload_images/2855070-1e640864e3ce90f4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="???.jpeg"><br>我吭哧吭哧半天用<code>UIImageJPEGRepresentation</code>压缩图片，然后在生成图片，也没把图片传上去。我当时想肯定是图片大小有问题，因为微信限制128KB以内。我查看保存在沙盒里的图片才32KB啊？？怎么会上传不上去呢？再查看<code>Image</code>的<code>Data</code>大小，噗~~~168KB。好吧，我被打败了。最后还是用微信原生SDK才搞定，直接传一个<code>Data</code>过去，多开心，多easy。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>好的，扯了这么多，其实就是想说一下为啥会有今天这篇大水文。在解决问题的过程中，我对iOS加载图片的理解稍微深入了那么一丢丢。现在，就水一下我理解的那么一丢丢东西。</p>
<h3 id="图片经过哪些流程加载到屏幕上"><a href="#图片经过哪些流程加载到屏幕上" class="headerlink" title="图片经过哪些流程加载到屏幕上"></a>图片经过哪些流程加载到屏幕上</h3><ol>
<li>从磁盘拷贝数据到内核缓冲区</li>
<li>从内核缓冲区复制数据到用户空间（内存级别拷贝）</li>
<li>生成<code>UIImage</code>，把<code>UIImage</code>赋值给<code>UIImageView</code></li>
<li>如果图像数据为未解码的PNG/JPG，解码为位图数据</li>
<li>隐式<code>CATransaction</code>捕获到<code>UIImageView</code>图层树的变化</li>
<li>主线程<code>Runloop</code>提交<code>CATransaction</code>，开始进行图像渲染<br>6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐<br>6.2 GPU处理位图数据，进行渲染</li>
</ol>
<p>其中第四点就是导致我32KB变168KB的“罪魁祸首”。为啥这么说呢？先了解一些东西。</p>
<h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><p><code>PNG</code>只支持无损压缩，所以它的压缩比是有上限的。它有<code>alpha</code>通道，支持图片透明。此外xcode会对png格式进行特殊的优化处理，而对于其他图片不做处理，所以我们一些小图标经常用<code>PNG</code>。</p>
<h4 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h4><p><code>JPEG</code>支持有损压缩，不含有<code>alpha</code>通道，它可以通过图片质量换取内存空间。网络图片最好选用<code>JPEG</code>，可以节省流量、提高下载速度。</p>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>我们是否可以直接使用图片，使其显示在屏幕上呢？答案显然后<strong>不可以</strong>。图片经过解压后，变成位图数据。那么<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3" target="_blank" rel="noopener">位图</a>是什么呢?苹果给出的解释是</p>
<blockquote>
<p>A bitmap image (or sampled image) is an array of pixels (or samples)</p>
</blockquote>
<p>位图是一个像素数组。至于怎么将像素绘制到屏幕上，可以看<a href="https://objccn.io/issue-3-1/" target="_blank" rel="noopener">这篇文章</a>，就不做过多叙述（人家说的很明白）。</p>
<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>解码其实就是将图片的二进制数据转换成像素数据。这个过程是比较耗时的，不能使用 GPU 硬解码，只能通过 CPU 软解码实现（硬解码是通过解码电路实现，软解码是通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码）。解码后的文件大小计算公式</p>
<blockquote>
<p>解压缩后的图片大小 = 图片的像素宽  <em> 图片的像素高  </em> 每个像素所占的字节数 (4)</p>
</blockquote>
<p>每个像素所占的字节数为什么是4呢？因为我们所使用的位图大部分是32位的RGBA模式，这种模式位图的一个像素所占内存为32位，也就是4个字节的长度 。<a href="https://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use" target="_blank" rel="noopener">出处在此</a><br>所以，本地保存的32KB的图片，解码就是168KB了。（解压缩后的数据）<br><img src="https://upload-images.jianshu.io/upload_images/2855070-2e399ff3e5457a17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="恍然大悟.jpg"></p>
<h3 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h3><p>不过分享某一张图片的时候，我用<code>UIImageJPEGRepresentation</code>方法压缩不到128KB一下？？？什么图片这么大？后来问一下后台才知道，这张图片是相机拍摄的，尺寸非常大，只能重新设置图片尺寸。献上我的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func compressImage(_ image: UIImage, toByte maxLength: Int) -&gt; Data?&#123;</span><br><span class="line">    var compression: CGFloat = 1</span><br><span class="line"></span><br><span class="line">    var data = UIImageJPEGRepresentation(image, compression)!</span><br><span class="line">        if data.count &lt;= maxLength &#123;</span><br><span class="line">        return data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var max: CGFloat = 1</span><br><span class="line">    var min: CGFloat = 0</span><br><span class="line"></span><br><span class="line">    let newSize = CGSize.init(width: 200, height: 160)</span><br><span class="line">    UIGraphicsBeginImageContext(newSize)</span><br><span class="line">    image.draw(in: CGRect.init(x: 0, y: 0, width: newSize.width, height: newSize.height))</span><br><span class="line">    let newImage = UIGraphicsGetImageFromCurrentImageContext()!</span><br><span class="line">    UIGraphicsEndImageContext()</span><br><span class="line">    data = UIImageJPEGRepresentation(newImage, 1.0)!</span><br><span class="line">    if data.count &lt;= maxLength &#123;</span><br><span class="line">        return data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for _ in 0..&lt;10 &#123;</span><br><span class="line">        compression = (max + min) / 2</span><br><span class="line">        data = UIImageJPEGRepresentation(newImage, compression)!</span><br><span class="line"></span><br><span class="line">        if CGFloat(data.count) &lt; CGFloat(maxLength) * 0.9 &#123;</span><br><span class="line">            min = compression</span><br><span class="line">        &#125; else if data.count &gt; maxLength &#123;</span><br><span class="line">            max = compression</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h2><p>通常我们说图片加载会用到两种方法：<code>imageNamed</code>、<code>imageWithContentsOfFile</code>，我们简单介绍这两种方法</p>
<h3 id="imageNamed"><a href="#imageNamed" class="headerlink" title="imageNamed"></a>imageNamed</h3><p>该方法的特点在于可以缓存已经加载的图片；使用时，先根据文件名在系统缓存中寻找图片，如果找到了就返回；如果没有，就在<code>Bundle</code>内查找到文件名，找到后把这个文件名放到<code>UIImage</code>里返回，并没有进行实际的文件读取和解码。当<code>UIImage</code>第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。</p>
<h3 id="imageWithContentsOfFile"><a href="#imageWithContentsOfFile" class="headerlink" title="imageWithContentsOfFile"></a>imageWithContentsOfFile</h3><p>该方法仅加载图片，不缓存图像数据，其解码依然要等到第一次显示该图片的时候。<br>对于这两种方法，我们可以做出如下比较：</p>
<ul>
<li>本地（Assets）保存的图标加载使用<code>imageNamed</code></li>
<li>经常使用且文件不大的图片使用<code>imageNamed</code></li>
<li>对于一些文件较大的图片使用<code>imageWithContentsOfFile</code>，当然最好的办法是用<code>UIGraphicsBeginImageContext</code>方法重新绘制图片</li>
</ul>
<p>此外，在 WWDC 2018上，苹果为我们建议了一种大家平时使用较少的大图加载方式，它的实际占用内存与理论值最为接近。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -&gt; UIImage</span><br><span class="line">&#123;</span><br><span class="line">    let sourceOpt = [kCGImageSourceShouldCache : false] as  CFDictionary</span><br><span class="line">// 其他场景可以用createwithdata (data并未decode,所占内存没那么大),</span><br><span class="line">    let source = CGImageSourceCreateWithURL(imageURL as CFURL, sourceOpt)!</span><br><span class="line"></span><br><span class="line">    let maxDimension = max(pointSize.width, pointSize.height) * scale</span><br><span class="line">    let downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : true,</span><br><span class="line">                         kCGImageSourceShouldCacheImmediately : true ,</span><br><span class="line">                         kCGImageSourceCreateThumbnailWithTransform : true,</span><br><span class="line">                         kCGImageSourceThumbnailMaxPixelSize : maxDimension] as CFDictionary</span><br><span class="line">    let downsampleImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOpt)!</span><br><span class="line">    return UIImage(cgImage: downsampleImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.cnbang.net/tech/2578/" target="_blank" rel="noopener">iOS图片加载速度极限优化—FastImageCache解析</a><br><a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina" target="_blank" rel="noopener">谈谈 iOS 中图片的解压缩</a><br><a href="https://juejin.im/post/5b2ddfa7e51d4553156be305" target="_blank" rel="noopener">iOS中的图片使用方式、内存对比和最佳实践</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/09/源码阅读-Kingfisher/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarrenW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarrenW">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/09/源码阅读-Kingfisher/" itemprop="url">源码阅读 Kingfisher</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-09T20:33:02+08:00">
                2018-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener">Kingfisher</a>是一个用于图片下载和缓存的轻量级、纯swift库。通过<a href="https://weibo.com/onevcat?profile_ftype=1&amp;is_all=1#_rnd1539003449528" target="_blank" rel="noopener">喵神</a>的介绍，可以得知<code>Kingfisher</code>有以下特点：</p>
<ul>
<li>实现了图片的异步下载和缓存</li>
<li>基于<code>URLSession</code>的网络，提供基本图像处理器和过滤器。</li>
<li>内存和磁盘的多层缓存。</li>
<li>可取消下载和处理任务以提高性能。</li>
<li>独立的组件，根据需要单独使用下载器或缓存系统。</li>
<li>预览图像并在以后需要时从缓存中显示它们。</li>
<li>对<code>UIImageView</code>,<code>NSImage</code>和<code>UIButton</code>的扩展，可以直接从<code>URL</code>设置图像。</li>
<li>设置图像时内置过渡动画。</li>
<li>加载图像时可自定义占位符。</li>
<li>可扩展的图像处理和图像格式支持。</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>在项目中，我们使用<code>CocoaPods</code>下载安装<code>Kingfisher</code>。<br>我们查看<code>Kingfisher</code>的目录结构，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Kingfisher</span><br><span class="line">    AnimatedImageView.swift    //动画控件   </span><br><span class="line">    Box.swift    //工具类</span><br><span class="line">    CacheSerializer.swift    //序列化类，读写文件时Data和Image互转</span><br><span class="line">    Filter.swift    //仅对CIImage有效</span><br><span class="line">    FormatIndicatedCacheSerializer.swift    //PNG/JPEG/GIF和Data互转</span><br><span class="line">    Image.swift    //图片格式转换</span><br><span class="line">    ImageCache.swift    //图片缓存</span><br><span class="line">    ImageDownloader.swift    //图片下载</span><br><span class="line">    ImageModifier.swift    //图片修改</span><br><span class="line">    ImagePrefetcher.swift    //图片下载管理类，对并发多个下载任务的处理</span><br><span class="line">    ImageProcessor.swift    //数据处理类，将Data转为Image</span><br><span class="line">    ImageTransition.swift    //动画效果</span><br><span class="line">    ImageView+Kingfisher.swift    //扩展ImageView添加下载图片的方法</span><br><span class="line">    Indicator.swift    //动画相关</span><br><span class="line">    Kingfisher.h    //版本号</span><br><span class="line">    Kingfisher.swift    //类，扩展ImageView添加属性kf</span><br><span class="line">    KingfisherManager.swift    //管理类，封装图片下载和缓存的逻辑</span><br><span class="line">    KingfisherOptionsInfo.swift    //枚举类</span><br><span class="line">    Placeholder.swift    //默认图片管理类</span><br><span class="line">    RequestModifier.swift    //协议，修改原始URLRequest参数</span><br><span class="line">    Resource.swift    //协议，声明下载链接和缓存key</span><br><span class="line">    String+MD5.swift    //MD5加密</span><br><span class="line">    ThreadHelper.swift    //工具类</span><br><span class="line">    UIButton+Kingfisher.swift    //扩展UIButton添加下载图片的方法</span><br></pre></td></tr></table></figure></p>
<h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>很简单的一句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.imageV.kf.setImage(with: imgUrl)</span><br></pre></td></tr></table></figure></p>
<p>如果想在图片加载的过程中添加默认图片，可以添加<code>placeholder</code>方法，监听加载的过程<code>progressBlock</code>，图片加载完成后的回调<code>completionHandler</code>。</p>
<h2 id="查看方法"><a href="#查看方法" class="headerlink" title="查看方法"></a>查看方法</h2><p>查看<code>kf.setImage</code>方法，我们会跳到<em>ImageView+Kingfisher.swift</em>文件里。这里我们对方法做一个简单的介绍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">public func setImage(with resource: Resource?,</span><br><span class="line">                     placeholder: Placeholder? = nil,</span><br><span class="line">                     options: KingfisherOptionsInfo? = nil,</span><br><span class="line">                     progressBlock: DownloadProgressBlock? = nil,</span><br><span class="line">                     completionHandler: CompletionHandler? = nil) -&gt; RetrieveImageTask&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，在这个方法里面，包括了ImageView的资源、默认图片、作者封装的枚举类、加载进度的回调以及完成结果。<br><code>@discardableResult</code>方法是为了取消不使用返回值的警告。<br>在这个方法里面(方法太长就不列举出来，捡主要的说)，</p>
<ul>
<li>首先判断参数合法性，当<code>resource</code>为<code>nil</code>时，展示默认图片。</li>
<li>设置读取策略和启动动画。比如常见的一个问题：当用户头像改变但图片<code>URL</code>没有改变时，怎么去处理用户头像。一般有两种方法，一种是在缓存用户头像时保存当前时间。另一种就是设置读取策略，<code>KingfisherOptionsInfo</code>是一个枚举，设置它为<code>forceRefresh</code>时，可以强制刷新。</li>
<li>从内存、文件或网络<code>URL</code>获取对应图片数据。</li>
<li>获取图片完成后，在主线程刷新界面。</li>
</ul>
<p>我们查看一下这里面的参数：</p>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>Resource是一个协议，我们查看源码可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public protocol Resource &#123;</span><br><span class="line">    var cacheKey: String &#123; get &#125;</span><br><span class="line">    var downloadURL: URL &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>cacheKey</code>是图片保存的key值，当<code>cacheKey</code>为<code>nil</code>时，取<code>downloadURL.absoluteString</code>(有兴趣的可以去了解一下<code>absoluteString</code>和<code>path</code>的区别)。<code>downloadURL</code>不言而喻，就是图片的<code>URL</code>。</p>
<h3 id="Placeholder"><a href="#Placeholder" class="headerlink" title="Placeholder"></a>Placeholder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public protocol Placeholder &#123;</span><br><span class="line">    func add(to imageView: ImageView)</span><br><span class="line">    func remove(from imageView: ImageView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Placeholder</code>是一个协议，作者为它定义了<code>add</code>和<code>remove</code>方法，任何。默认实现了<code>Image</code>，如果想用<code>View</code>充当<code>Placeholder</code>，只要让<code>view</code>遵守协议即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension Placeholder where Self: View&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="KingfisherOptionsInfo"><a href="#KingfisherOptionsInfo" class="headerlink" title="KingfisherOptionsInfo"></a>KingfisherOptionsInfo</h3><p><code>KingfisherOptionsInfo</code>是一个类型别名，点击查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]</span><br></pre></td></tr></table></figure></p>
<p>所以我们关注的应该是<code>KingfisherOptionsInfoItem</code>是什么东西？那么它是什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public enum KingfisherOptionsInfoItem &#123;</span><br><span class="line">    case targetCache(ImageCache)    //系统缓存位置。可以设置的属性</span><br><span class="line">    case originalCache(ImageCache)    //系统缓存原始图像位置（只用于自己设置placeholder） </span><br><span class="line">    case downloader(ImageDownloader)    //获取更改session属性，设置请求</span><br><span class="line">    case transition(ImageTransition)    //自定义动画</span><br><span class="line">    case downloadPriority(Float)    //下载优先级（0-1）</span><br><span class="line">    case forceRefresh    //每次请求忽略缓存，直接下载</span><br><span class="line">    case fromMemoryCacheOrRefresh    //先取缓存再去文件，再去下载</span><br><span class="line">    case forceTransition    //强制移动</span><br><span class="line">    case cacheMemoryOnly     //只从缓存读取，不读取本机沙盒图片</span><br><span class="line">    case onlyFromCache    //从缓存、沙盒读取，没有也不下载网络，显示placeholder</span><br><span class="line">    case backgroundDecode    //设置后，显示前在后台线程解码</span><br><span class="line">    case callbackDispatchQueue(DispatchQueue?)    //自定义回调队列，默认主线程</span><br><span class="line">    case scaleFactor(CGFloat)    //自定义图片data -&gt; Image缩放比例，不指定按屏幕2x\3x缩放</span><br><span class="line">    case preloadAllAnimationData    //预先加载data成图片缓存</span><br><span class="line">    case requestModifier(ImageDownloadRequestModifier)    //改变请求</span><br><span class="line">    case processor(ImageProcessor)    //自定义Data转图片样式</span><br><span class="line">    case cacheSerializer(CacheSerializer)    //自定义缓存Data 转图像样式</span><br><span class="line">    case imageModifier(ImageModifier)    //修改图像</span><br><span class="line">    case keepCurrentImageWhileLoading     //包含这个意味着placeHolder设置无效，没有直接用默认</span><br><span class="line">    case onlyLoadFirstFrame    //如果返回结果是.gif图，只取第一帧显示</span><br><span class="line">    case cacheOriginalImage    //同时缓存原始图片和下载后的图片</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="DownloadProgressBlock"><a href="#DownloadProgressBlock" class="headerlink" title="DownloadProgressBlock"></a>DownloadProgressBlock</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -&gt; ())</span><br></pre></td></tr></table></figure>
<p><code>DownloadProgressBlock</code>里面有<code>receivedSize</code>和<code>totalSize</code>，可以根据这两个参数得知图片下载了多少和图片多大，也可以计算图片的下载进度。</p>
<h3 id="CompletionHandler"><a href="#CompletionHandler" class="headerlink" title="CompletionHandler"></a>CompletionHandler</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public typealias CompletionHandler = ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -&gt; ())</span><br></pre></td></tr></table></figure>
<p><code>CompletionHandler</code>的回调里会有<code>image</code>、<code>error</code>、<code>cacheType</code>、<code>imageURL</code>四个参数。<code>image</code>、<code>error</code>、<code>imageURL</code>不做介绍，直接就能看出什么内容。<br>主要看一下<code>cacheType</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum CacheType &#123;</span><br><span class="line">    case none, memory, disk</span><br><span class="line">    public var cached: Bool &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .memory, .disk: return true</span><br><span class="line">        case .none: return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>none</code>检索图片时，图片尚未缓存</li>
<li><code>memory</code>图片缓存在内存中</li>
<li><code>disk</code>图片缓存在磁盘中</li>
</ul>
<h2 id="检索图片"><a href="#检索图片" class="headerlink" title="检索图片"></a>检索图片</h2><p>OK，让我们继续看这些代码。在<code>setImage</code>方法中，从内存、文件或网络<code>URL</code>获取对应图片数据是怎么实现的呢？这里，我们可以查看<code>KingfisherManager.shared.retrieveImage</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">public func retrieveImage(with resource: Resource,</span><br><span class="line">    options: KingfisherOptionsInfo?,</span><br><span class="line">    progressBlock: DownloadProgressBlock?,</span><br><span class="line">    completionHandler: CompletionHandler?) -&gt; RetrieveImageTask</span><br><span class="line">&#123;</span><br><span class="line">    let task = RetrieveImageTask()</span><br><span class="line">    let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo)</span><br><span class="line">    if options.forceRefresh &#123;</span><br><span class="line">        _ = downloadAndCacheImage(</span><br><span class="line">            with: resource.downloadURL,</span><br><span class="line">            forKey: resource.cacheKey,</span><br><span class="line">            retrieveImageTask: task,</span><br><span class="line">            progressBlock: progressBlock,</span><br><span class="line">            completionHandler: completionHandler,</span><br><span class="line">            options: options)</span><br><span class="line">    &#125; else &#123;    </span><br><span class="line">        tryToRetrieveImageFromCache(</span><br><span class="line">            forKey: resource.cacheKey,</span><br><span class="line">            with: resource.downloadURL, </span><br><span class="line">            retrieveImageTask: task,</span><br><span class="line">            progressBlock: progressBlock,</span><br><span class="line">            completionHandler: completionHandler,</span><br><span class="line">            options: options)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，代码会通过<code>KingfisherOptionsInfo</code>进行判断是强制刷新，网络下载并执行缓存策略还是从内存或文件中获取对应的Image。</p>
<h3 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">func downloadAndCacheImage(with url: URL,</span><br><span class="line">                         forKey key: String,</span><br><span class="line">                  retrieveImageTask: RetrieveImageTask,</span><br><span class="line">                      progressBlock: DownloadProgressBlock?,</span><br><span class="line">                  completionHandler: CompletionHandler?,</span><br><span class="line">                            options: KingfisherOptionsInfo) -&gt; RetrieveImageDownloadTask?&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>downloadAndCacheImage</code>方法中，会<code>return  downloader.downloadImage</code>方法，下载的主要逻辑在这里实现，对应的文件是<em>ImageDownloader.swift</em>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">open func downloadImage(with url: URL,</span><br><span class="line">               retrieveImageTask: RetrieveImageTask? = nil,</span><br><span class="line">                         options: KingfisherOptionsInfo? = nil,</span><br><span class="line">                   progressBlock: ImageDownloaderProgressBlock? = nil,</span><br><span class="line">               completionHandler: ImageDownloaderCompletionHandler? = nil) -&gt; RetrieveImageDownloadTask?&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ImageDownloader.swift</code>文件中，主要参数：</p>
<ul>
<li><code>downloadTimeout</code> 超时时间，默认15秒</li>
<li><code>trustedHosts</code> 信任的请求地址，和自己实现请求代理设置冲突，二选一</li>
<li><code>sessionConfiguration</code> session配置设置</li>
<li><code>requestsUsePipelining</code> 请求是否管道类型，是否按顺序下载，默认<code>false</code></li>
<li><code>sessionHandler</code>单独设计出的一个<code>ImageDownloaderSessionHandler</code>，是为了解决之前出现的<a href="https://github.com/onevcat/Kingfisher/issues/235" target="_blank" rel="noopener">内存泄漏</a></li>
<li><code>delegate</code> 下载代理</li>
<li><code>authenticationChallengeResponder</code> 信任请求代理，和trustedHosts冲突二选一</li>
<li><code>fetchLoads</code> 下载完成每个URL可能有多个处理方式，优先取这里的</li>
<li>此外还有三个<code>DispatchQueue</code>：<code>barrierQueue</code>、<code>processQueue</code>、<code>cancelQueue</code></li>
</ul>
<p>下载完成后，在<code>completionHandler</code>回调中处理图片，如果下载失败：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if let error = error, error.code == KingfisherError.notModified.rawValue &#123;</span><br><span class="line">    //从缓存中读取，不需保存，直接返回</span><br><span class="line">    targetCache.retrieveImage(forKey: key, options: options, completionHandler: &#123; (cacheImage, cacheType) -&gt; () in</span><br><span class="line">        completionHandler?(cacheImage, nil, cacheType, url)</span><br><span class="line">    &#125;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下载成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if let image = image, let originalData = originalData &#123;</span><br><span class="line">    //存储图片</span><br><span class="line">    targetCache.store(image,</span><br><span class="line">                      original: originalData,</span><br><span class="line">                      forKey: key,</span><br><span class="line">                      processorIdentifier:options.processor.identifier,</span><br><span class="line">                      cacheSerializer: options.cacheSerializer,</span><br><span class="line">                      toDisk: !options.cacheMemoryOnly,</span><br><span class="line">                      completionHandler: nil)</span><br><span class="line">        if options.cacheOriginalImage &amp;&amp; options.processor != DefaultImageProcessor.default &#123;</span><br><span class="line">            let originalCache = options.originalCache</span><br><span class="line">            let defaultProcessor = DefaultImageProcessor.default</span><br><span class="line">            if let originalImage = defaultProcessor.process(item: .data(originalData), options: options) &#123;</span><br><span class="line">                originalCache.store(originalImage,</span><br><span class="line">                        original: originalData,</span><br><span class="line">                        forKey: key,</span><br><span class="line">                        processorIdentifier: defaultProcessor.identifier,</span><br><span class="line">                        cacheSerializer: options.cacheSerializer,</span><br><span class="line">                        toDisk: !options.cacheMemoryOnly,</span><br><span class="line">                        completionHandler: nil)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h4><p>我们先来看一下实现的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open func store(_ image: Image,</span><br><span class="line">                  original: Data? = nil,</span><br><span class="line">                  forKey key: String,</span><br><span class="line">                  processorIdentifier identifier: String = &quot;&quot;,</span><br><span class="line">                  cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,</span><br><span class="line">                  toDisk: Bool = true,</span><br><span class="line">                  completionHandler: (() -&gt; Void)? = nil)&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中<code>memoryCache</code>是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileprivate let memoryCache = NSCache&lt;NSString, AnyObject&gt;()</span><br></pre></td></tr></table></figure></p>
<p>可见图片存储首先是缓存在<code>NSCache</code>中，如果想存储在磁盘中(<code>if toDisk</code>)，利用串行队列异步的进行存储原图。</p>
<h4 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">open func retrieveImage(forKey key: String,</span><br><span class="line">                           options: KingfisherOptionsInfo?,</span><br><span class="line">                 completionHandler: ((Image?, CacheType) -&gt; ())?) -&gt; RetrieveImageDiskTask?&#123;...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先从内存中获取图片<code>if let image = self.retrieveImageInMemoryCache(forKey: key, options: options)</code></li>
<li>如果没有，在根据条件判断是否从磁盘上获取<code>if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options)</code></li>
</ul>
<h4 id="删除图片"><a href="#删除图片" class="headerlink" title="删除图片"></a>删除图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open func removeImage(forKey key: String,</span><br><span class="line">                      processorIdentifier identifier: String = &quot;&quot;,</span><br><span class="line">                      fromDisk: Bool = true,</span><br><span class="line">                      completionHandler: (() -&gt; Void)? = nil)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@objc public func clearMemoryCache() &#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open func clearDiskCache(completion handler: (()-&gt;())? = nil) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open func cleanExpiredDiskCache(completion handler: (()-&gt;())? = nil) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@objc public func backgroundCleanExpiredDiskCache() &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>其中，一些方法是通过通知的方法来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 系统内存警告</span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(clearMemoryCache), name: .UIApplicationDidReceiveMemoryWarning, object: nil)    </span><br><span class="line">// 程序终止</span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(cleanExpiredDiskCache), name: .UIApplicationWillTerminate, object: nil)</span><br><span class="line">// 程序进入后台</span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(backgroundCleanExpiredDiskCache), name: .UIApplicationDidEnterBackground, object: nil)</span><br></pre></td></tr></table></figure></p>
<p>此外，还有一些属性要注意:</p>
<ul>
<li><code>maxMemoryCost</code>最大缓存量，在收到内存警告时会被清空。</li>
<li><code>pathExtension</code>沙盒后续拼接文件夹名称</li>
<li><code>maxCachePeriodInSecond</code>默认清除一周前的图片</li>
<li><code>maxDiskCacheSize</code>沙盒最大存储量，为0，默认无限制</li>
</ul>
<p>以上就是对Kingfisher的简单描述，它有很多方法值得我们去借鉴，比如<code>@discardableResult</code>、<code>where</code>、<code>typealias</code>、<code>if case let</code>、善于利用<code>guard</code>、扩展协议等等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/30/RxSwift-操作符决策树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarrenW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarrenW">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/RxSwift-操作符决策树/" itemprop="url">RxSwift 操作符决策树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-30T21:59:24+08:00">
                2018-09-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前列举了很多操作符的用法，还有很多我们没有列举的。其实写了那么多操作符有时候我还是会忘记选择哪一个。这个时候，我发现在<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html" target="_blank" rel="noopener">RxSwift中文文档</a>有一篇关于选择操作符的文章。这一篇水文纯搬运。</p>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p><strong>我想要创建一个 <code>Observable</code></strong></p>
<ul>
<li>产生特定的一个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/just.html" target="_blank" rel="noopener">just</a></li>
<li>经过一段延时：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html" target="_blank" rel="noopener">timer</a></li>
<li>从一个序列拉取元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/from.html" target="_blank" rel="noopener">from</a></li>
<li>重复的产生某一个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/repeatElement.html" target="_blank" rel="noopener">repeatElement</a></li>
<li>存在自定义逻辑：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/create.html" target="_blank" rel="noopener">create</a></li>
<li>每次订阅时产生：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/deferred.html" target="_blank" rel="noopener">deferred</a></li>
<li>每隔一段时间，发出一个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/interval.html" target="_blank" rel="noopener">interval</a></li>
<li>在一段延时后：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html" target="_blank" rel="noopener">timer</a></li>
<li>一个空序列，只有一个完成事件：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/empty.html" target="_blank" rel="noopener">empty</a></li>
<li>一个任何事件都没有产生的序列：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/never.html" target="_blank" rel="noopener">never</a></li>
</ul>
<p><strong>我想要创建一个 <code>Observable</code> 通过组合其他的 <code>Observables</code></strong></p>
<ul>
<li>任意一个 <code>Observable</code> 产生了元素，就发出这个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/merge.html" target="_blank" rel="noopener">merge</a></li>
<li>让这些 <code>Observables</code> 一个接一个的发出元素，当上一个 <code>Observable</code> 元素发送完毕后，下一个<code>Observable</code> 才能开始发出元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concat.html" target="_blank" rel="noopener">concat</a></li>
<li>组合多个 <code>Observables</code> 的元素</li>
<li>当每一个 <code>Observable</code> 都发出一个新的元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/zip.html" target="_blank" rel="noopener">zip</a></li>
<li>当任意一个 <code>Observable</code> 发出一个新的元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/combineLatest.html" target="_blank" rel="noopener">combineLatest</a></li>
</ul>
<p><strong>我想要转换 <code>Observable</code> 的元素后，再将它们发出来</strong></p>
<ul>
<li>对每个元素直接转换：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/map.html" target="_blank" rel="noopener">map</a></li>
<li>转换到另一个 <code>Observable</code>：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMap.html" target="_blank" rel="noopener">flatMap</a></li>
<li>只接收最新的元素转换的 <code>Observable</code> 所产生的元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMapLatest.html" target="_blank" rel="noopener">flatMapLatest</a></li>
<li>每一个元素转换的 <code>Observable</code> 按顺序产生元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concatMap.html" target="_blank" rel="noopener">concatMap</a></li>
<li>基于所有遍历过的元素： <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html" target="_blank" rel="noopener">scan</a></li>
</ul>
<p><strong>我想要将产生的每一个元素，拖延一段时间后再发出：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delay.html" target="_blank" rel="noopener">delay</a></strong></p>
<p><strong>我想要将产生的事件封装成元素发送出来</strong></p>
<ul>
<li>将他们封装成 <code>Event&lt;Element&gt;</code>：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/materialize.html" target="_blank" rel="noopener">materialize</a></li>
<li>然后解封出来：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/dematerialize.html" target="_blank" rel="noopener">dematerialize</a></li>
</ul>
<p><strong>我想要忽略掉所有的 <code>next</code> 事件，只接收 <code>completed</code> 和 <code>error</code> 事件：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/ignoreElements.html" target="_blank" rel="noopener">ignoreElements</a></strong></p>
<p><strong>我想创建一个新的 <code>Observable</code> 在原有的序列前面加入一些元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/startWith.html" target="_blank" rel="noopener">startWith</a></strong></p>
<p><strong>我想从 <code>Observable</code> 中收集元素，缓存这些元素之后在发出：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/buffer.html" target="_blank" rel="noopener">buffer</a></strong></p>
<p><strong>我想将 <code>Observable</code> 拆分成多个 <code>Observables</code>：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/window.html" target="_blank" rel="noopener">window</a></strong></p>
<ul>
<li>基于元素的共同特征：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/groupBy.html" target="_blank" rel="noopener">groupBy</a></li>
</ul>
<p><strong>我想只接收 <code>Observable</code> 中特定的元素</strong></p>
<ul>
<li>发出唯一的元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/single.html" target="_blank" rel="noopener">single</a></li>
</ul>
<p><strong>我想重新从 <code>Observable</code> 中发出某些元素</strong></p>
<ul>
<li>通过判定条件过滤出一些元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/filter.html" target="_blank" rel="noopener">filter</a></li>
<li>仅仅发出头几个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html" target="_blank" rel="noopener">take</a></li>
<li>仅仅发出尾部的几个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeLast.html" target="_blank" rel="noopener">takeLast</a></li>
<li>仅仅发出第 n 个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/elementAt.html" target="_blank" rel="noopener">elementAt</a></li>
<li>跳过头几个元素</li>
<li>跳过头 n 个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html" target="_blank" rel="noopener">skip</a></li>
<li>跳过头几个满足判定的元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html" target="_blank" rel="noopener">skipWhile</a>，<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html" target="_blank" rel="noopener">skipWhileWithIndex</a></li>
<li>跳过某段时间内产生的头几个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html" target="_blank" rel="noopener">skip</a></li>
<li>跳过头几个元素直到另一个 <code>Observable</code> 发出一个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipUntil.html" target="_blank" rel="noopener">skipUntil</a></li>
<li>只取头几个元素</li>
<li>只取头几个满足判定的元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html" target="_blank" rel="noopener">takeWhile</a>，<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html" target="_blank" rel="noopener">takeWhileWithIndex</a></li>
<li>只取某段时间内产生的头几个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html" target="_blank" rel="noopener">take</a></li>
<li>只取头几个元素直到另一个 <code>Observable</code> 发出一个元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeUntil.html" target="_blank" rel="noopener">takeUntil</a></li>
<li>周期性的对 <code>Observable</code> 抽样：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/sample.html" target="_blank" rel="noopener">sample</a></li>
<li>发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/debounce.html" target="_blank" rel="noopener">debounce</a></li>
<li>直到元素的值发生变化，才发出新的元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html" target="_blank" rel="noopener">distinctUntilChanged</a></li>
<li>并提供元素是否相等的判定函数：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html" target="_blank" rel="noopener">distinctUntilChanged</a></li>
<li>在开始发出元素时，延时后进行订阅：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delaySubscription.html" target="_blank" rel="noopener">delaySubscription</a></li>
</ul>
<p><strong>我想要从一些 <code>Observables</code> 中，只取第一个产生元素的 <code>Observable</code>：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/amb.html" target="_blank" rel="noopener">amb</a></strong></p>
<p><strong>我想评估 <code>Observable</code> 的全部元素</strong></p>
<ul>
<li>并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/reduce.html" target="_blank" rel="noopener">reduce</a></li>
<li>并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html" target="_blank" rel="noopener">scan</a></li>
</ul>
<p><strong>我想把 <code>Observable</code> 转换为其他的数据结构：as…</strong></p>
<p><strong>我想在某个 <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html" target="_blank" rel="noopener">Scheduler</a> 应用操作符：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html" target="_blank" rel="noopener">subscribeOn</a></strong></p>
<ul>
<li>在某个 <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html" target="_blank" rel="noopener">Scheduler</a> 监听：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html" target="_blank" rel="noopener">observeOn</a></li>
</ul>
<p><strong>我想要 <code>Observable</code> 发生某个事件时, 采取某个行动：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/do.html" target="_blank" rel="noopener">do</a></strong></p>
<p><strong>我想要 <code>Observable</code> 发出一个 <code>error</code> 事件：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/error.html" target="_blank" rel="noopener">error</a></strong></p>
<ul>
<li>如果规定时间内没有产生元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html" target="_blank" rel="noopener">timeout</a></li>
</ul>
<p><strong>我想要 <code>Observable</code> 发生错误时，优雅的恢复</strong></p>
<ul>
<li>如果规定时间内没有产生元素，就切换到备选 <code>Observable</code> ：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html" target="_blank" rel="noopener">timeout</a></li>
<li>如果产生错误，将错误替换成某个元素 ：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html" target="_blank" rel="noopener">catchErrorJustReturn</a></li>
<li>如果产生错误，就切换到备选 <code>Observable</code> ：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html" target="_blank" rel="noopener">catchError</a></li>
<li>如果产生错误，就重试 ：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/retry.html" target="_blank" rel="noopener">retry</a></li>
</ul>
<p><strong>我创建一个 <code>Disposable</code> 资源，使它与 <code>Observable</code> 具有相同的寿命：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/using.html" target="_blank" rel="noopener">using</a></strong></p>
<p><strong>我创建一个 <code>Observable</code>，直到我通知它可以产生元素后，才能产生元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/publish.html" target="_blank" rel="noopener">publish</a></strong></p>
<ul>
<li>并且，就算是在产生元素后订阅，也要发出全部元素：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/replay.html" target="_blank" rel="noopener">replay</a></li>
<li>并且，一旦所有观察者取消观察，他就被释放掉：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/refCount.html" target="_blank" rel="noopener">refCount</a></li>
<li>通知它可以产生元素了：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/connect.html" target="_blank" rel="noopener">connect</a></li>
</ul>
<p>笨鸟先飞，执行合一。基本了解<code>RxSwift</code>后，就应该动手写一些BUG了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/28/RxSwift-结合操作符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarrenW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarrenW">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/28/RxSwift-结合操作符/" itemprop="url">RxSwift 结合操作符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-28T21:47:21+08:00">
                2018-09-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>结合操作（或者称合并操作）指的是将多个<code>Observable</code>序列进行组合，拼装成一个新的<code>Observable</code>序列。</p>
<h4 id="1-startWith"><a href="#1-startWith" class="headerlink" title="1. startWith"></a>1. startWith</h4><p>该方法会在<code>Observable</code>序列开始之前插入一些事件元素。即发出事件消息之前，会先发出这些预先插入的事件消息。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-1e67a4bb28af2c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">Observable.of(2, 3)</span><br><span class="line">        .startWith(1)</span><br><span class="line">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h4 id="2-concat"><a href="#2-concat" class="headerlink" title="2. concat"></a>2. concat</h4><ul>
<li><code>concat</code>操作符将多个<code>Observables</code>按顺序串联起来，当前一个<code>Observable</code>元素发送完毕后，后一个 Observable 才可以开始发出元素。</li>
<li><code>concat</code>将等待前一个 Observable 产生完成事件后，才对后一个<code>Observable</code>进行订阅。如果后一个是“热”<code>Observable</code>，在它前一个<code>Observable</code>产生完成事件前，所产生的元素将不会被发送出来。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2855070-8a8303ad65144b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">et disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">let subject1 = BehaviorSubject.init(value: &quot;1&quot;)</span><br><span class="line">let subject2 = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class="line"></span><br><span class="line">let variable = Variable.init(subject1)</span><br><span class="line">variable.asObservable()</span><br><span class="line">        .concat()</span><br><span class="line">        .subscribe&#123; print($0) &#125;</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject1.onNext(&quot;2&quot;)</span><br><span class="line">subject1.onNext(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">variable.value = subject2</span><br><span class="line">subject2.onNext(&quot;I would be ignored&quot;)</span><br><span class="line">subject2.onNext(&quot;B&quot;)</span><br><span class="line"></span><br><span class="line">subject1.onCompleted()</span><br><span class="line">subject2.onNext(&quot;C&quot;)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">next(1)</span><br><span class="line">next(2)</span><br><span class="line">next(3)</span><br><span class="line">next(B)</span><br><span class="line">next(C)</span><br></pre></td></tr></table></figure></p>
<h4 id="3-merge"><a href="#3-merge" class="headerlink" title="3. merge"></a>3. merge</h4><ul>
<li>通过使用<code>merge</code>操作符你可以将多个<code>Observables</code>合并成一个，当某一个<code>Observable</code>发出一个元素时，他就将这个元素发出。</li>
<li>如果，某一个<code>Observable</code>发出一个<code>onError</code>事件，那么被合并的<code>Observable</code>也会将它发出，并且立即终止序列。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-4982880854a4f8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">let subject1 = PublishSubject&lt;Int&gt;()</span><br><span class="line">let subject2 = PublishSubject&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">Observable.of(subject1, subject2)</span><br><span class="line">        .merge()</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject1.onNext(20)</span><br><span class="line">subject1.onNext(40)</span><br><span class="line">subject1.onNext(60)</span><br><span class="line">subject2.onNext(1)</span><br><span class="line">subject1.onNext(80)</span><br><span class="line">subject1.onNext(100)</span><br><span class="line">subject2.onNext(1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">40</span><br><span class="line">60</span><br><span class="line">1</span><br><span class="line">80</span><br><span class="line">100</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h4 id="4-zip"><a href="#4-zip" class="headerlink" title="4. zip"></a>4. zip</h4><p><code>zip</code>操作符将多个(最多不超过8个)<code>Observables</code>的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的<code>Observable</code>的第一个元素，是由每一个源<code>Observables</code>的第一个元素组合出来的。它的第二个元素 ，是由每一个源<code>Observables</code>的第二个元素组合出来的。它的第三个元素 ，是由每一个源<code>Observables</code>的第三个元素组合出来的，以此类推。它的元素数量等于源<code>Observables</code>中元素数量最少的那个。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-ae17319dd7d0a940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">let first = PublishSubject&lt;String&gt;()</span><br><span class="line">let second = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">Observable.zip(first, second) &#123; $0 + $1 &#125;</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">first.onNext(&quot;1&quot;)</span><br><span class="line">second.onNext(&quot;A&quot;)</span><br><span class="line">first.onNext(&quot;2&quot;)</span><br><span class="line">second.onNext(&quot;B&quot;)</span><br><span class="line">second.onNext(&quot;C&quot;)</span><br><span class="line">second.onNext(&quot;D&quot;)</span><br><span class="line">first.onNext(&quot;3&quot;)</span><br><span class="line">first.onNext(&quot;4&quot;)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1A</span><br><span class="line">2B</span><br><span class="line">3C</span><br><span class="line">4D</span><br></pre></td></tr></table></figure></p>
<h4 id="5-combineLatest"><a href="#5-combineLatest" class="headerlink" title="5. combineLatest"></a>5. combineLatest</h4><p><code>combineLatest</code>操作符将多个<code>Observables</code>中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源<code>Observables</code>中任何一个发出一个元素，他都会发出一个元素（前提是，这些<code>Observables</code>曾经发出过元素）。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-2fab45bfd4b8c814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">let first = PublishSubject&lt;String&gt;()</span><br><span class="line">let second = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">Observable.combineLatest(first, second) &#123; $0 + $1 &#125;</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">first.onNext(&quot;1&quot;)</span><br><span class="line">second.onNext(&quot;A&quot;)</span><br><span class="line">first.onNext(&quot;2&quot;)</span><br><span class="line">second.onNext(&quot;B&quot;)</span><br><span class="line">second.onNext(&quot;C&quot;)</span><br><span class="line">second.onNext(&quot;D&quot;)</span><br><span class="line">first.onNext(&quot;3&quot;)</span><br><span class="line">first.onNext(&quot;4&quot;)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1A</span><br><span class="line">2A</span><br><span class="line">2B</span><br><span class="line">2C</span><br><span class="line">2D</span><br><span class="line">3D</span><br><span class="line">4D</span><br></pre></td></tr></table></figure></p>
<h4 id="6-withLatestFrom"><a href="#6-withLatestFrom" class="headerlink" title="6. withLatestFrom"></a>6. withLatestFrom</h4><p><code>withLatestFrom</code>操作符将两个<code>Observables</code>中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。当第一个<code>Observable</code>发出一个元素时，就立即取出第二个<code>Observable</code>中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-9bfeb60b798296e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">subject1.withLatestFrom(subject2)</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject1.onNext(&quot;A&quot;)</span><br><span class="line">subject2.onNext(&quot;1&quot;)</span><br><span class="line">subject1.onNext(&quot;B&quot;)</span><br><span class="line">subject1.onNext(&quot;C&quot;)</span><br><span class="line">subject2.onNext(&quot;2&quot;)</span><br><span class="line">subject1.onNext(&quot;D&quot;)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/27/RxSwift-条件和布尔操作符-Conditional-and-Boolean-Operators/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarrenW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarrenW">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/27/RxSwift-条件和布尔操作符-Conditional-and-Boolean-Operators/" itemprop="url">RxSwift 条件和布尔操作符(Conditional and Boolean Operators)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-27T21:31:24+08:00">
                2018-09-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>条件和布尔操作会根据条件发射或变换<code>Observables</code>，或者对他们做布尔运算。</p>
<h4 id="1-amb"><a href="#1-amb" class="headerlink" title="1.amb"></a>1.amb</h4><p>当你传入多个<code>Observables</code>到<code>amb</code>操作符时，它将取其中一个<code>Observable</code>：第一个产生事件的那个<code>Observable</code>，可以是一个<code>next</code>，<code>error</code>或者<code>completed</code>事件。<code>amb</code>将忽略掉其他的<code>Observables</code>。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-84522567d0c59097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">let subject1 = PublishSubject&lt;Int&gt;()</span><br><span class="line">let subject2 = PublishSubject&lt;Int&gt;()</span><br><span class="line">let subject3 = PublishSubject&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">subject1.amb(subject2)</span><br><span class="line">        .amb(subject3)</span><br><span class="line">        .subscribe&#123; print($0.element!) &#125;</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject2.onNext(1)</span><br><span class="line">subject1.onNext(20)</span><br><span class="line">subject2.onNext(2)</span><br><span class="line">subject1.onNext(40)</span><br><span class="line">subject3.onNext(0)</span><br><span class="line">subject2.onNext(3)</span><br><span class="line">subject1.onNext(60)</span><br><span class="line">subject3.onNext(0)</span><br><span class="line">subject3.onNext(0)</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h4 id="2-takeWhile"><a href="#2-takeWhile" class="headerlink" title="2. takeWhile"></a>2. takeWhile</h4><p>该方法依次判断<code>Observable</code>序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-df28e3c3f9466030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">Observable.of(1, 2, 3, 4, 3, 2, 1)</span><br><span class="line">        .takeWhile &#123; $0 &lt; 4 &#125;</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h4 id="3-takeUntil"><a href="#3-takeUntil" class="headerlink" title="3. takeUntil"></a>3. takeUntil</h4><p><code>takeUntil</code>操作符将镜像源<code>Observable</code>，它同时观测第二个<code>Observable</code>。一旦第二个<code>Observable</code>发出一个元素或者产生一个终止事件，那个镜像的<code>Observable</code>将立即终止。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2855070-0445e18465f29f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="takeUntil.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class="line">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">subject1.takeUntil(subject2)</span><br><span class="line">        .subscribe &#123; print($0) &#125;</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject1.onNext(&quot;A&quot;)</span><br><span class="line">subject1.onNext(&quot;B&quot;)</span><br><span class="line">subject2.onNext(&quot;我可以让它中止&quot;)</span><br><span class="line">subject1.onNext(&quot;C&quot;)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next(A)</span><br><span class="line">next(B)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure></p>
<h4 id="4-skipUntil"><a href="#4-skipUntil" class="headerlink" title="4. skipUntil"></a>4. skipUntil</h4><ul>
<li>同上面的<code>takeUntil</code>一样，<code>skipUntil</code>除了订阅源<code>Observable</code>外，通过<code>skipUntil</code>方法我们还可以监视另外一个<code>Observable</code>， 即<code>notifier</code> 。</li>
<li>与<code>takeUntil</code>相反的是。源<code>Observable</code>序列事件默认会一直跳过，直到<code>notifier</code>发出值或 complete 通知</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2855070-5063471ccc8c9bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">let subject = PublishSubject&lt;String&gt;()</span><br><span class="line">let notifier = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">subject.skipUntil(notifier)</span><br><span class="line">        .subscribe (onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;A&quot;)</span><br><span class="line">subject.onNext(&quot;B&quot;)</span><br><span class="line">notifier.onNext(&quot;接收消息&quot;)</span><br><span class="line">subject.onNext(&quot;C&quot;)</span><br><span class="line">subject.onNext(&quot;D&quot;)</span><br><span class="line">subject.onNext(&quot;E&quot;)</span><br><span class="line">notifier.onNext(&quot;接收消息&quot;)</span><br><span class="line">subject.onNext(&quot;F&quot;)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">D</span><br><span class="line">E</span><br><span class="line">F</span><br></pre></td></tr></table></figure></p>
<h4 id="5-skipWhile"><a href="#5-skipWhile" class="headerlink" title="5. skipWhile"></a>5. skipWhile</h4><p><code>skipWhile</code>操作符可以让你忽略源<code>Observable</code>中头几个元素，直到元素的判定为否。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-cf1e93804e5b79e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">Observable.of(1, 3, 6, 4, 7, 2)</span><br><span class="line">        .skipWhile&#123; $0 &lt; 5 &#125;</span><br><span class="line">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/26/RxSwift-过滤操作符-Filtering-Observables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarrenW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarrenW">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/26/RxSwift-过滤操作符-Filtering-Observables/" itemprop="url">RxSwift 过滤操作符(Filtering Observables)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-26T21:30:34+08:00">
                2018-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>过滤操作指的是从源<code>Observable</code>中选择特定的数据发送。</p>
<h4 id="1-filter"><a href="#1-filter" class="headerlink" title="1. filter"></a>1. filter</h4><p><code>filter</code>操作符将通过你提供的判定方法过滤一个<code>Observable</code>。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-7403d9c225aec4cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="filter.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of(2, 30, 22, 5, 60, 1)</span><br><span class="line">        .filter&#123; $0 &gt; 10 &#125;</span><br><span class="line">        .subscribe(onNext: &#123; print( $0 )&#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">30</span><br><span class="line">22</span><br><span class="line">60</span><br></pre></td></tr></table></figure></p>
<h4 id="2-distinctUntilChanged"><a href="#2-distinctUntilChanged" class="headerlink" title="2. distinctUntilChanged"></a>2. distinctUntilChanged</h4><p><code>distinctUntilChanged</code>操作符将阻止<code>Observable</code>发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-0c5afa37f9610704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="distinctUntilChanged.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of(1, 2, 2, 1, 3)</span><br><span class="line">        .distinctUntilChanged()</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h4 id="3-single"><a href="#3-single" class="headerlink" title="3. single"></a>3. single</h4><ul>
<li>限制只发送一次事件，或者满足条件的第一个事件。</li>
<li>如果存在有多个事件或者没有事件都会发出一个<code>error</code>事件。</li>
<li>如果只有一个事件，则不会发出<code>error</code>事件</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2855070-29bfd143ec29394e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="single.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of(1, 2, 3, 4, 4, 4, 5)</span><br><span class="line">        .single()</span><br><span class="line">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">Observable.of(&quot;A&quot;)</span><br><span class="line">        .single()</span><br><span class="line">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">Unhandled error happened: Sequence contains more than one element.</span><br><span class="line">subscription called from:</span><br><span class="line">A</span><br></pre></td></tr></table></figure></p>
<h4 id="4-elementAt"><a href="#4-elementAt" class="headerlink" title="4. elementAt"></a>4. elementAt</h4><p><code>elementAt</code>操作符将拉取<code>Observable</code>序列中指定索引数的元素，然后将它作为唯一的元素发出。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-b8ac9409cc9bf25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="elementAt.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of(1, 2, 3, 4)</span><br><span class="line">        .elementAt(2)</span><br><span class="line">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h4 id="5-ignoreElements"><a href="#5-ignoreElements" class="headerlink" title="5. ignoreElements"></a>5. ignoreElements</h4><ul>
<li>该操作符可以忽略掉所有的元素，只发出<code>error</code>或<code>completed</code>事件。</li>
<li>如果我们并不关心<code>Observable</code>的任何元素，只想知道<code>Observable</code>在什么时候终止，那就可以使用<code>ignoreElements</code>操作符。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2855070-bcadae47ddc7f71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ignoreElements.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of(1, 2, 3, 4, 4, 4, 5)</span><br><span class="line">        .ignoreElements()</span><br><span class="line">        .subscribe&#123; print($0) &#125;</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">completed</span><br></pre></td></tr></table></figure></p>
<h4 id="6-take"><a href="#6-take" class="headerlink" title="6.take"></a>6.take</h4><p>该方法实现仅发送<code>Observable</code>序列中的前<code>n</code>个事件，在满足数量之后会自动<code>.completed</code><br><img src="https://upload-images.jianshu.io/upload_images/2855070-ba890655a1787c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="take.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of(1, 2, 3, 4)</span><br><span class="line">        .take(2)</span><br><span class="line">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h4 id="7-takeLast"><a href="#7-takeLast" class="headerlink" title="7. takeLast"></a>7. takeLast</h4><p>该方法实现仅发送<code>Observable</code>序列中的后<code>n</code>个事件<br><img src="https://upload-images.jianshu.io/upload_images/2855070-3e60ff6e411e234c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="takeLast.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of(1, 2, 3, 4)</span><br><span class="line">        .takeLast(1)</span><br><span class="line">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h4 id="8-skip"><a href="#8-skip" class="headerlink" title="8. skip"></a>8. skip</h4><p>该方法用于跳过源<code>Observable</code>序列发出的前<code>n</code>个事件。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-439c4618a9901d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="skip.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of(1, 2, 3, 4)</span><br><span class="line">        .skip(2)</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h4 id="9-Sample"><a href="#9-Sample" class="headerlink" title="9. Sample"></a>9. Sample</h4><ul>
<li><code>Sample</code>除了订阅源<code>Observable</code>外，还可以监视另外一个<code>Observable</code>， 即<code>notifier</code>。<br>每当收到<code>notifier</code>事件，就会从源序列取一个最新的事件并发送。而如果两次<code>notifier</code>事件之间没有源序列的事件，则不发送值。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2855070-509212ce29f1c102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sample.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">let source = PublishSubject&lt;Int&gt;()</span><br><span class="line">let notifier = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">source.sample(notifier)</span><br><span class="line">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">source.onNext(1)</span><br><span class="line"></span><br><span class="line">notifier.onNext(&quot;A&quot;)</span><br><span class="line"></span><br><span class="line">source.onNext(2)</span><br><span class="line"></span><br><span class="line">notifier.onNext(&quot;B&quot;)</span><br><span class="line">notifier.onNext(&quot;C&quot;)</span><br><span class="line"></span><br><span class="line">source.onNext(3)</span><br><span class="line">source.onNext(4)</span><br><span class="line"></span><br><span class="line">notifier.onNext(&quot;D&quot;)</span><br><span class="line"></span><br><span class="line">source.onNext(5)</span><br><span class="line"></span><br><span class="line">notifier.onCompleted()</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<h4 id="10-debounce"><a href="#10-debounce" class="headerlink" title="10. debounce"></a>10. debounce</h4><ul>
<li><code>debounce</code>操作符可以用来<em>过滤掉高频产生的元素</em>，它只会发出这种元素：该元素产生后，一段时间内没有新元素产生。</li>
<li>换句话说就是，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉。</li>
<li><code>debounce</code>常用在<em>用户输入</em>的时候，不需要每个字母敲进去都发送一个事件，而是稍等一下取最后一个事件。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2855070-b313fa33f47012ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="debounce.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">//定义好每个事件里的值以及发送的时间</span><br><span class="line">let times = [</span><br><span class="line">[ &quot;value&quot;: 1, &quot;time&quot;: 0.1 ],</span><br><span class="line">[ &quot;value&quot;: 2, &quot;time&quot;: 1.1 ],</span><br><span class="line">[ &quot;value&quot;: 3, &quot;time&quot;: 1.2 ],</span><br><span class="line">[ &quot;value&quot;: 4, &quot;time&quot;: 1.2 ],</span><br><span class="line">[ &quot;value&quot;: 5, &quot;time&quot;: 1.4 ],</span><br><span class="line">[ &quot;value&quot;: 6, &quot;time&quot;: 2.1 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//生成对应的 Observable 序列并订阅</span><br><span class="line">Observable.from(times)</span><br><span class="line">        .flatMap &#123; item in</span><br><span class="line">            return Observable.of(Int(item[&quot;value&quot;]!))</span><br><span class="line">                            .delaySubscription(Double(item[&quot;time&quot;]!),scheduler: MainScheduler.instance)</span><br><span class="line">                &#125;</span><br><span class="line">        .debounce(0.5, scheduler: MainScheduler.instance) //只发出与下一个间隔超过0.5秒的元素</span><br><span class="line">        .subscribe&#123; print($0) &#125;</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>运行结果……为啥我啥也没打印出来？？？<br><img src="https://upload-images.jianshu.io/upload_images/2855070-bafa66b6f115f0c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="u=4240739968,2514380758&amp;fm=27&amp;gp=0.jpg"><br>这个留在下回思考……<br>但据可靠信息，咳咳咳，打印出来的应该是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/25/RxSwift-变换操作-Transforming-Observables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarrenW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarrenW">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/RxSwift-变换操作-Transforming-Observables/" itemprop="url">RxSwift 变换操作(Transforming Observables)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T21:52:23+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>变换操作指的是对原始的<code>Observable</code>序列进行一些转换，类似于 Swift 中<code>CollectionType</code>的各种转换</p>
<h4 id="1-buffer"><a href="#1-buffer" class="headerlink" title="1. buffer"></a>1. buffer</h4><p><code>buffer</code>操作符将缓存<code>Observable</code>中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-76c121cb942f7c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="buffer.png"><br>🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let subject = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">subject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class="line">        .subscribe&#123; print($0) &#125;</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line">subject.onNext(&quot;A&quot;)</span><br><span class="line">subject.onNext(&quot;B&quot;)</span><br><span class="line">subject.onNext(&quot;C&quot;)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🐯&quot;)</span><br><span class="line">subject.onNext(&quot;🐭&quot;)</span><br><span class="line">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">next([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br><span class="line">next([&quot;🐯&quot;, &quot;🐭&quot;, &quot;🐱&quot;])</span><br></pre></td></tr></table></figure></p>
<p>有一点疑问，对于<code>buffer</code>在<code>RxSwift</code>的解释是</p>
<blockquote>
<p>Projects each element of an observable sequence into a buffer that’s sent out when either it’s full or a given amount of time has elapsed, using the specified scheduler to run timers</p>
</blockquote>
<p><code>RxSwift</code>中，它的意思是当缓冲区满了或超过了给定的时间时，就会发出缓冲区。可是如果我们把上述代码稍微改变一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let subject = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">subject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class="line">        .subscribe&#123; print($0) &#125;</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line">subject.onNext(&quot;A&quot;)</span><br><span class="line">subject.onNext(&quot;B&quot;)</span><br><span class="line">subject.onNext(&quot;C&quot;)</span><br><span class="line"></span><br><span class="line">//  subject.onNext(&quot;🐯&quot;)</span><br><span class="line">subject.onNext(&quot;🐭&quot;)</span><br><span class="line">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br></pre></td></tr></table></figure></p>
<p>并没有后面的内容。因为我在很多文章里都看到说如果规定时间内不够要求的数量也会发出（有几个发几个，一个都没有发空数组 []）。所以，这点值得注意。</p>
<h4 id="2-window"><a href="#2-window" class="headerlink" title="2. window"></a>2. window</h4><ul>
<li><code>window</code>操作符和<code>buffer</code>十分相似。不过<code>buffer</code>是周期性的将缓存的元素集合发送出来，而<code>window</code>周期性的将元素集合以<code>Observable</code>的形态发送出来。<br>同时<code>buffer</code>要等到元素搜集完毕后，才会发出元素序列。而<code>window</code>可以实时发出元素序列。(这一点证明了<code>buffer</code>还是要元素搜集完毕后才会发出序列)<br><img src="https://upload-images.jianshu.io/upload_images/2855070-4658ffd7d827e9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="window.png"><br>首先我们先这么写：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let subject = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">subject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class="line">        .subscribe&#123; print($0) &#125;</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;A&quot;)</span><br><span class="line">subject.onNext(&quot;B&quot;)</span><br><span class="line">subject.onNext(&quot;C&quot;)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🐯&quot;)</span><br><span class="line">subject.onNext(&quot;🐭&quot;)</span><br><span class="line">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class="line">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class="line">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class="line">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>可见他在不断打印<code>next(RxSwift.AddRef&lt;Swift.String&gt;)</code><br>如果把代码改成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let subject = PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">subject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        print(&quot;subscribe:\($0)&quot;)</span><br><span class="line">        $0.asObservable()</span><br><span class="line">            .subscribe&#123; print($0) &#125;</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;A&quot;)</span><br><span class="line">subject.onNext(&quot;B&quot;)</span><br><span class="line">subject.onNext(&quot;C&quot;)</span><br><span class="line"></span><br><span class="line">subject.onNext(&quot;🐯&quot;)</span><br><span class="line">subject.onNext(&quot;🐭&quot;)</span><br><span class="line">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class="line">next(A)</span><br><span class="line">next(B)</span><br><span class="line">next(C)</span><br><span class="line">completed</span><br><span class="line">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class="line">next(🐯)</span><br><span class="line">next(🐭)</span><br><span class="line">next(🐱)</span><br><span class="line">completed</span><br><span class="line">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class="line">completed</span><br><span class="line">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class="line">completed</span><br></pre></td></tr></table></figure></p>
<h4 id="3-map"><a href="#3-map" class="headerlink" title="3.map"></a>3.map</h4><p><code>map</code>操作符将<code>Observable</code>的每个元素应用你提供的转换方法，然后返回含有转换结果的<code>Observable</code>。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-def03bf478a9770d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="map.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of(1,2,3)</span><br><span class="line">        .map&#123; $0 * 2 &#125;</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>其实，swift中也有一个高级函数<code>map</code>，可以对数组中的每一个元素做一次处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let array = [1, 2, 3]</span><br><span class="line">let nums = array.map &#123;</span><br><span class="line">    return $0 * 2</span><br><span class="line">&#125;</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure></p>
<p>结果得出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 4, 6]</span><br></pre></td></tr></table></figure></p>
<h4 id="4-flatMap"><a href="#4-flatMap" class="headerlink" title="4. flatMap"></a>4. flatMap</h4><ul>
<li><code>map</code>在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。</li>
<li>而<code>flatMap</code>操作符会对源<code>Observable</code>的每一个元素应用一个转换方法，将他们转换成<code>Observables</code>。 然后将这些<code>Observables</code>的元素合并之后再发送出来。即又将其 “拍扁”（降维）成一个<code>Observable</code>序列。</li>
<li>这个操作符是非常有用的。比如当<code>Observable</code>的元素本生拥有其他的<code>Observable</code>时，我们可以将所有子<code>Observables</code>的元素发送出来。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2855070-f40ff203991060c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flatMap.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class="line">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class="line">let variable = Variable.init(first)</span><br><span class="line"></span><br><span class="line">variable.asObservable()</span><br><span class="line">        .flatMap&#123; $0 &#125;</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line">first.onNext(&quot;1&quot;)</span><br><span class="line">variable.value = second</span><br><span class="line">second.onNext(&quot;2&quot;)</span><br><span class="line">first.onNext(&quot;3&quot;)</span><br></pre></td></tr></table></figure>
<p>打印结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">1</span><br><span class="line">B</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>我们依然可以在<code>Swift</code>中找到高级函数<code>flatMap</code>，它相比<code>map</code>有两点不同</p>
<ul>
<li><code>flatMap</code>返回后的数组中不存在<code>nil</code>，同时它会把<code>Optional</code>解包</li>
<li><code>flatMap</code>还能把数组中存有数组的数组（二维数组、N维数组）一同打开变成一个新的数组</li>
<li>也能把两个不同的数组合并成一个数组，这个合并的数组元素个数是前面两个数组元素个数的乘积</li>
</ul>
<p>只举一个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let array = [[1, 2, 3], [4, 5, 6]]</span><br><span class="line">let nums = array.flatMap&#123; $0 &#125;</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure></p>
<h4 id="5-flatMapLatest"><a href="#5-flatMapLatest" class="headerlink" title="5. flatMapLatest"></a>5. flatMapLatest</h4><p><code>flatMapLatest</code>与<code>flatMap</code>的唯一区别是：<code>flatMapLatest</code>只会接收最新的<code>value</code>事件<br><img src="https://upload-images.jianshu.io/upload_images/2855070-ac2d4f8e45ea1ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flatMapLatest.png"><br>将上述代码中<code>flatMap</code>改为<code>flatMapLatest</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class="line">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class="line">let variable = Variable.init(first)</span><br><span class="line"></span><br><span class="line">variable.asObservable()</span><br><span class="line">        .flatMapLatest&#123; $0 &#125;</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line">first.onNext(&quot;1&quot;)</span><br><span class="line">variable.value = second</span><br><span class="line">second.onNext(&quot;2&quot;)</span><br><span class="line">first.onNext(&quot;3&quot;)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">1</span><br><span class="line">B</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h4 id="6-concatMap"><a href="#6-concatMap" class="headerlink" title="6. concatMap"></a>6. concatMap</h4><p><code>concatMap</code>操作符将源<code>Observable</code>的每一个元素应用一个转换方法，将他们转换成<code>Observables</code>。然后让这些<code>Observables</code> 按顺序的发出元素，当前一个<code>Observable</code>元素发送完毕后，后一个<code>Observable</code>才可以开始发出元素。等待前一个<code>Observable</code>产生完成事件后，才对后一个<code>Observable</code>进行订阅<br><img src="https://upload-images.jianshu.io/upload_images/2855070-5969d4c9a2013318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="concatMap.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class="line">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class="line">let variable = Variable.init(first)</span><br><span class="line"></span><br><span class="line">variable.asObservable()</span><br><span class="line">        .concatMap&#123; $0 &#125;</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)   </span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line">first.onNext(&quot;1&quot;)</span><br><span class="line">first.onNext(&quot;2&quot;)</span><br><span class="line"></span><br><span class="line">variable.value = second</span><br><span class="line">second.onNext(&quot;3&quot;)</span><br><span class="line">second.onNext(&quot;4&quot;)</span><br><span class="line"></span><br><span class="line">first.onCompleted()</span><br><span class="line">second.onNext(&quot;5&quot;)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<h4 id="7-scan"><a href="#7-scan" class="headerlink" title="7. scan"></a>7. scan</h4><p><code>scan</code>操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-83cf372dd5b1cbe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="scan.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable.of(1, 2, 3, 4, 5)</span><br><span class="line">        .scan(0) &#123; acum, elem  in</span><br><span class="line">            acum + elem</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure></p>
<h4 id="8-groupBy"><a href="#8-groupBy" class="headerlink" title="8. groupBy"></a>8. groupBy</h4><ul>
<li><code>groupBy</code>操作符将源<code>Observable</code>分解为多个子<code>Observable</code>，然后将这些子<code>Observable</code>发送出来。</li>
<li>也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以<code>Observable</code>的形态发送出来。<br><img src="https://upload-images.jianshu.io/upload_images/2855070-4193d29d366c8e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="groupBy.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">Observable&lt;Int&gt;.of(0, 1, 2, 3, 4, 5)</span><br><span class="line">        .groupBy &#123; (element) -&gt; String in</span><br><span class="line">            return element % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123; (event) in</span><br><span class="line">            switch event &#123;</span><br><span class="line">            case .next(let group):</span><br><span class="line">                group.asObservable().subscribe(&#123; (event) in</span><br><span class="line">                    print(&quot;key:\(group.key)  event:\(event)&quot;)</span><br><span class="line">                &#125;)</span><br><span class="line">                .disposed(by: disposeBag)</span><br><span class="line">            default:</span><br><span class="line">                print(&quot;&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key:偶数  event:next(0)</span><br><span class="line">key:奇数  event:next(1)</span><br><span class="line">key:偶数  event:next(2)</span><br><span class="line">key:奇数  event:next(3)</span><br><span class="line">key:偶数  event:next(4)</span><br><span class="line">key:奇数  event:next(5)</span><br><span class="line">key:奇数  event:completed</span><br><span class="line">key:偶数  event:completed</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/22/RxSwift-Observable-Observer和辅助类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarrenW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarrenW">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/22/RxSwift-Observable-Observer和辅助类型/" itemprop="url">RxSwift Observable&Observer和辅助类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-22T23:49:42+08:00">
                2018-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在我们日常开发中，有一些既可是<code>Observable</code>又可是<code>Observer</code>。举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let observable = textField.rx.text</span><br><span class="line">observable.subscribe(onNext: &#123; text in show(text: text) &#125;)</span><br></pre></td></tr></table></figure></p>
<p>在这行代码中，<code>textField</code>当前文本就是一个<code>Observable</code>，当用户在<code>textField</code>中输入时，就会<code>show</code>文本内容。<br>再举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let observer = textField.rx.text</span><br><span class="line">let observable = Observable&lt;String&gt;.just(&quot;A&quot;)</span><br><span class="line">observable.bind(to: observer)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>这个时候，屏幕上就会显示：<br><img src="https://upload-images.jianshu.io/upload_images/2855070-a113479a0f2d92f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="textField.png"><br>这时，<code>textField</code>的当前文本就是<code>Observer</code>。<br>此外，框架中还有一些辅助类型，既可是<code>Observable</code>又可是<code>Observer</code>。</p>
<h4 id="1-AsyncSubject"><a href="#1-AsyncSubject" class="headerlink" title="1. AsyncSubject"></a>1. AsyncSubject</h4><p><code>AsyncSubject</code>将在<code>Observable</code>产生完成事件后，发出最后一个元素（仅仅只有最后一个元素）。如果<code>Observable</code>没有发出任何元素，只有一个完成事件，那<code>AsyncSubject</code>也只有一个完成事件。如果<code>Observable</code>因<code>error</code>中止，那么<code>AsyncSubject</code>只会将<code>error</code>发送出来，不会发出其它元素。<br>举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">//创建一个AsyncSubject</span><br><span class="line">let subject = AsyncSubject&lt;String&gt;()</span><br><span class="line">//订阅subject</span><br><span class="line">subject.subscribe&#123; print($0) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">subject.onNext(&quot;B&quot;)</span><br><span class="line">subject.onNext(&quot;C&quot;)</span><br><span class="line">subject.onNext(&quot;D&quot;)</span><br><span class="line">subject.onCompleted()</span><br></pre></td></tr></table></figure></p>
<p>这个时候输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">next(D)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure></p>
<p>此时我们再改造一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let subject = AsyncSubject&lt;String&gt;()</span><br><span class="line">subject.subscribe&#123; print($0) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">subject.onNext(&quot;B&quot;)</span><br><span class="line">subject.onNext(&quot;C&quot;)</span><br><span class="line">subject.onNext(&quot;D&quot;)</span><br><span class="line">//SubjectError 自己定义的enum Error</span><br><span class="line">subject.onError(SubjectError.error)</span><br></pre></td></tr></table></figure></p>
<p>就会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error(error)</span><br></pre></td></tr></table></figure></p>
<h4 id="2-PublishSubject"><a href="#2-PublishSubject" class="headerlink" title="2. PublishSubject"></a>2. PublishSubject</h4><p><code>PublishSubject</code>是将对观察者发送<code>订阅后产生的元素</code>，而在订阅前发出的元素将不会发送给观察者。</p>
<ul>
<li><code>PublishSubject</code>是最普通的<code>Subject</code>，它不需要初始值就能创建</li>
<li><code>PublishSubject</code>的订阅者从他们开始订阅的时间点起，可以收到订阅后<code>Subject</code>发出的新<code>Event</code>，而不会收到他们在订阅前已发出的<code>Event</code></li>
</ul>
<p>举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let subject = PublishSubject&lt;String&gt;()</span><br><span class="line">//由于当前没有订阅，所以不输出</span><br><span class="line">subject.onNext(&quot;🐶&quot;)</span><br><span class="line">//第一次订阅</span><br><span class="line">subject.subscribe(onNext: &#123; (element) in</span><br><span class="line">    print(&quot;第一次订阅:\(element)&quot;)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">//当前有一个订阅，输出</span><br><span class="line">subject.onNext(&quot;🐱&quot;)</span><br><span class="line"></span><br><span class="line">//第二次订阅</span><br><span class="line">subject.subscribe(onNext: &#123; (element) in</span><br><span class="line">    print(&quot;第二次订阅:\(element)&quot;)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br><span class="line">//当前有两个订阅 输出</span><br><span class="line">subject.onNext(&quot;🐹&quot;)</span><br><span class="line"></span><br><span class="line">//结束subject</span><br><span class="line">subject.onCompleted()</span><br><span class="line">//再次发出.next事件</span><br><span class="line">subject.onNext(&quot;🐯&quot;)</span><br></pre></td></tr></table></figure></p>
<p>显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次订阅:🐱</span><br><span class="line">第一次订阅:🐹</span><br><span class="line">第二次订阅:🐹</span><br><span class="line">第一次订阅:completed</span><br><span class="line">第二次订阅:completed</span><br><span class="line">第三次订阅:completed</span><br></pre></td></tr></table></figure></p>
<h4 id="3-ReplaySubject"><a href="#3-ReplaySubject" class="headerlink" title="3. ReplaySubject"></a>3. ReplaySubject</h4><p><code>ReplaySubject</code>将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的<code>ReplaySubject</code>，有的只会将最新的n个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把<code>ReplaySubject</code>当作观察者来使用，注意不要在多个线程调用<code>onNext</code>,<code>onError</code>或<code>onCompleted</code>。这样会导致无序调用，将造成意想不到的结果。</p>
<ul>
<li><code>ReplaySubject</code>在创建时候需要设置一个<code>bufferSize</code>，表示它对于它发送过的<code>event</code>的缓存个数</li>
<li>比如一个<code>ReplaySubject</code>的<code>bufferSize</code>设置为 2，它发出了 3 个<code>.next</code>的<code>event</code>，那么它会将后两个（最近的两个）<code>event</code>给缓存起来。此时如果有一个<code>subscriber</code>订阅了这个 <code>ReplaySubject</code>，那么这个<code>subscriber</code>就会立即收到前面缓存的两个<code>.next</code>的<code>event</code></li>
<li>如果一个<code>subscriber</code>订阅已经结束的<code>ReplaySubject</code>，除了会收到缓存的<code>.next</code>的<code>event</code>外，还会收到那个终结的<code>.error</code>或者<code>.complete</code>的<code>event</code></li>
</ul>
<p>举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">//创建</span><br><span class="line">let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 0)</span><br><span class="line">//第1次订阅subject</span><br><span class="line">subject.subscribe&#123; print(&quot;第一次订阅:\($0)&quot;) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">//发送.next事件</span><br><span class="line">subject.onNext(&quot;A&quot;)</span><br><span class="line">subject.onNext(&quot;B&quot;)</span><br><span class="line">//第二次订阅</span><br><span class="line">subject.subscribe&#123; print(&quot;第二次订阅:\($0)&quot; )&#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">//发送.next事件</span><br><span class="line">subject.onNext(&quot;C&quot;)</span><br><span class="line">subject.onNext(&quot;D&quot;)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次订阅:next(A)</span><br><span class="line">第一次订阅:next(B)</span><br><span class="line">第一次订阅:next(C)</span><br><span class="line">第二次订阅:next(C)</span><br><span class="line">第一次订阅:next(D)</span><br><span class="line">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>
<p>当<code>bufferSize</code>改成1时，结果就变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一次订阅:next(A)</span><br><span class="line">第一次订阅:next(B)</span><br><span class="line">第二次订阅:next(B)</span><br><span class="line">第一次订阅:next(C)</span><br><span class="line">第二次订阅:next(C)</span><br><span class="line">第一次订阅:next(D)</span><br><span class="line">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>
<p>如果是2的话，结果就变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一次订阅:next(A)</span><br><span class="line">第一次订阅:next(B)</span><br><span class="line">第二次订阅:next(A)</span><br><span class="line">第二次订阅:next(B)</span><br><span class="line">第一次订阅:next(C)</span><br><span class="line">第二次订阅:next(C)</span><br><span class="line">第一次订阅:next(D)</span><br><span class="line">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>
<h4 id="4-BehaviorSubject"><a href="#4-BehaviorSubject" class="headerlink" title="4. BehaviorSubject"></a>4. BehaviorSubject</h4><p><code>BehaviorSubject</code>会把<code>Observable</code>最新元素发出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果<code>Observable</code>因为<code>error</code>事件而中止，则不会发出任何元素，将<code>error</code>事件发出来。</p>
<ul>
<li><code>BehaviorSubject</code>需要通过一个默认初始值来创建</li>
<li>当一个订阅者来订阅它的时候，这个订阅者会立即收到 <code>BehaviorSubjects</code>上一个发出的<code>event</code>。之后就跟正常的情况一样，它也会接收到<code>BehaviorSubject</code>之后发出的新的<code>event</code></li>
</ul>
<p>举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">//创建一个BehaviorSubject</span><br><span class="line">let subject = BehaviorSubject.init(value: &quot;🐭&quot;)</span><br><span class="line">//第一次订阅</span><br><span class="line">subject.subscribe&#123; print(&quot;第一次订阅:\($0)&quot;) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">//发送.next事件</span><br><span class="line">subject.onNext(&quot;🐯&quot;)</span><br><span class="line">//发送error事件</span><br><span class="line">subject.onError(NSError(domain: &quot;local&quot;, code: 0, userInfo: nil))</span><br><span class="line">//第二次订阅</span><br><span class="line">subject.subscribe&#123; print(&quot;第二次订阅:\($0)&quot;) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一次订阅:next(🐭)</span><br><span class="line">第一次订阅:next(🐯)</span><br><span class="line">第一次订阅:error(Error Domain=local Code=0 &quot;(null)&quot;)</span><br><span class="line">第二次订阅:error(Error Domain=local Code=0 &quot;(null)&quot;)</span><br></pre></td></tr></table></figure></p>
<h4 id="4-Variable"><a href="#4-Variable" class="headerlink" title="4. Variable"></a>4. Variable</h4><p>在<code>RxSwift</code>中，<code>Variable</code>相当于<code>Swift</code>中的<code>var</code>。</p>
<ul>
<li><code>Variable</code>其实就是对<code>BehaviorSubject</code>的封装，所以它也必须要通过一个默认的初始值进行创建。</li>
<li><code>Variable</code>具有<code>BehaviorSubject</code>的功能，能够向它的订阅者发出上一个<code>event</code>以及之后新创建的<code>event</code>。</li>
<li>不同的是，<code>Variable</code>还会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送<code>.complete</code>的<code>event</code>，不需要也不能手动给<code>Variables</code>发送<code>completed</code>或者<code>error</code>事件来结束它。</li>
<li>简单地说就是<code>Variable</code>有一个<code>value</code>属性，我们改变这个<code>value</code>属性的值就相当于调用一般<code>Subjects</code>的<code>onNext()</code>方法，而这个最新的<code>onNext()</code>的值就被保存在<code>value</code>属性里了，直到我们再次修改它。</li>
<li><code>Variables</code>本身没有<code>subscribe()</code>方法，但是所有<code>Subjects</code>都有一个<code>asObservable()</code>方法。我们可以使用这个方法返回这个<code>Variable</code>的<code>Observable</code>类型，拿到这个<code>Observable</code>类型我们就能订阅它了。</li>
</ul>
<p>举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">let variable = Variable.init(&quot;A&quot;)</span><br><span class="line">variable.value = &quot;B&quot;</span><br><span class="line">//第一次订阅</span><br><span class="line">variable.asObservable().subscribe&#123; print(&quot;第一次订阅:\($0)&quot;) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">//修改value</span><br><span class="line">variable.value = &quot;C&quot;</span><br><span class="line">//第二次订阅</span><br><span class="line">variable.asObservable().subscribe&#123; print(&quot;第二次订阅:\($0)&quot;) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">//修改value</span><br><span class="line">variable.value = &quot;D&quot;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一次订阅:next(B)</span><br><span class="line">第一次订阅:next(C)</span><br><span class="line">第二次订阅:next(C)</span><br><span class="line">第一次订阅:next(D)</span><br><span class="line">第二次订阅:next(D)</span><br><span class="line">第一次订阅:completed</span><br><span class="line">第二次订阅:completed</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/21/RxSwift-Observer-观察者/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarrenW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarrenW">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/RxSwift-Observer-观察者/" itemprop="url">RxSwift Observer-观察者</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T23:18:04+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们在<a href="https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more" target="_blank" rel="noopener">之前</a>已经了解了什么是<code>Observer</code>观察者，这篇我们了解一下怎么创建观察者以及特征观察者(<code>AnyObserver</code>、<code>Binder</code>)。</p>
<h4 id="在-subscribe-方法中创建"><a href="#在-subscribe-方法中创建" class="headerlink" title="在 subscribe 方法中创建"></a>在 subscribe 方法中创建</h4><p>创建观察者最直接的方法就是在<code>Observable</code>的<code>subscribe</code>方法后面描述当事件发生时，需要如何做出响应。举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(1,2,3,4,5)</span><br><span class="line">observable.subscribe(onNext: &#123; element in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(error)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果.png"></p>
<h4 id="在bind方法中创建"><a href="#在bind方法中创建" class="headerlink" title="在bind方法中创建"></a>在bind方法中创建</h4><p>我们创建一个定时生成索引数的<code>Observable</code>序列，并将索引数不断显示在<code>label</code>标签上<br>举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxCocoa</span><br><span class="line">import RxSwift</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">        observable.map&#123; &quot;当前索引数:\($0)&quot; &#125;</span><br><span class="line">                .bind &#123; [weak self](text) in</span><br><span class="line">                    self?.label.text = text</span><br><span class="line">                &#125;.disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override func didReceiveMemoryWarning() &#123;</span><br><span class="line">        super.didReceiveMemoryWarning()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="https://upload-images.jianshu.io/upload_images/2855070-c9f8b9f5593b1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bind结果.png"><br>除了以上创建方法外，我们还可以使用其他的方式，比如<code>AnyObserver</code>和<code>Binder</code></p>
<h4 id="使用AnyObserver创建观察者"><a href="#使用AnyObserver创建观察者" class="headerlink" title="使用AnyObserver创建观察者"></a>使用AnyObserver创建观察者</h4><p><code>AnyObserver</code>可以用来描叙任意一种观察者</p>
<h5 id="配合subscribe方法使用"><a href="#配合subscribe方法使用" class="headerlink" title="配合subscribe方法使用"></a>配合<code>subscribe</code>方法使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let observer: AnyObserver&lt;Int&gt; = AnyObserver &#123; event in</span><br><span class="line">    switch event&#123;</span><br><span class="line">    case .next(let data):</span><br><span class="line">        print(data)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(error)</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;completed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let observable = Observable.of(1,2,3,4,5)</span><br><span class="line">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果.png"></p>
<h5 id="配合bindTo方法使用"><a href="#配合bindTo方法使用" class="headerlink" title="配合bindTo方法使用"></a>配合bindTo方法使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxCocoa</span><br><span class="line">import RxSwift</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">        let observer: AnyObserver&lt;String&gt; = AnyObserver&#123;</span><br><span class="line">            [weak self] event in</span><br><span class="line">            switch event&#123;</span><br><span class="line">            case .next(let text):</span><br><span class="line">                self?.label.text = text</span><br><span class="line">            default:</span><br><span class="line">            break</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">        observable.map&#123;&quot;当前索引数:\($0)&quot;&#125;</span><br><span class="line">                .bind(to: observer)</span><br><span class="line">                .disposed(by: disposeBag )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override func didReceiveMemoryWarning() &#123;</span><br><span class="line">        super.didReceiveMemoryWarning()</span><br><span class="line">        // Dispose of any resources that can be recreated.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><p>Binder 主要有以下两个特征：</p>
<ul>
<li>不会处理错误事件</li>
<li>确保绑定都是在给定<code>Schedule</code>上执行（默认<code>MainScheduler</code>）</li>
</ul>
<p>一旦产生错误事件，在调试环境下将执行<code>fatalError</code>，在发布环境下将打印错误信息<br>在上面更新<code>label</code>文字的例子中，更好的方式就是使用<code>Binder</code>。理由有二：</p>
<ul>
<li>UI的更新在主线程完成</li>
<li>只处理<code>next</code>事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxCocoa</span><br><span class="line">import RxSwift</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">        let observer: Binder&lt;String&gt; = Binder(label)&#123;</span><br><span class="line">            (view,text) in</span><br><span class="line">            view.text = text</span><br><span class="line">        &#125;</span><br><span class="line">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">        observable.map&#123; &quot;当前索引数:\($0)&quot;&#125;</span><br><span class="line">                .bind(to: observer)</span><br><span class="line">                .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override func didReceiveMemoryWarning() &#123;</span><br><span class="line">        super.didReceiveMemoryWarning()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面，我们再去实现另外一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">observable.map&#123; $0 % 2 == 0&#125;</span><br><span class="line">        .bind(to: label.rx.isHidden)</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>此时label会不断的消失、出现。这段代码里我们又操作了什么？查看<code>label.rx.isHidden</code>中<code>isHidden</code>可以发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Reactive where Base: UIView &#123;</span><br><span class="line">    public var isHidden: Binder&lt;Bool&gt; &#123;</span><br><span class="line">        return Binder(self.base) &#123; view, hidden in</span><br><span class="line">            view.isHidden = hidden</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实<code>RxCocoa</code>在对许多 UI 控件进行扩展时，就利用<code>Binder</code>将控件属性变成观查者，我们也可以用这种方式来创建自定义的 UI 观察者。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/RxSwift-Observable-可观察序列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DarrenW">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarrenW">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/RxSwift-Observable-可观察序列/" itemprop="url">RxSwift Observable-可观察序列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-20T22:25:46+08:00">
                2018-09-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more" target="_blank" rel="noopener">上一篇</a>已经介绍了<code>Observable</code>是什么，现在简单介绍一下它怎么创建，以及<code>RxSwift</code>里面<code>Observable</code>存在的一些特征序列。</p>
<h3 id="常见的创建方法"><a href="#常见的创建方法" class="headerlink" title="常见的创建方法"></a>常见的创建方法</h3><h4 id="just-方法"><a href="#just-方法" class="headerlink" title="just() 方法"></a>just() 方法</h4><p>该方法通过传入一个默认值完成初始化，并指定了当前<code>Observable</code>所发出事件携带的数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;Int&gt;.just(1)</span><br></pre></td></tr></table></figure></p>
<h4 id="of-方法"><a href="#of-方法" class="headerlink" title="of()方法"></a>of()方法</h4><p>该方法可以接受多个参数来创建实例，但这些参数必须是同类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br></pre></td></tr></table></figure></p>
<h4 id="from-方法"><a href="#from-方法" class="headerlink" title="from()方法"></a>from()方法</h4><p>该方法只接收数组作为参数，并抽取出数组里的元素来作为数据流中的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.from([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br></pre></td></tr></table></figure></p>
<h4 id="never-方法"><a href="#never-方法" class="headerlink" title="never()方法"></a>never()方法</h4><p>该方法创建一个永远不会发出<code>Event</code>（也不会终止）的 <code>Observable</code>序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;Int&gt;.never()</span><br></pre></td></tr></table></figure></p>
<h4 id="empty-方法"><a href="#empty-方法" class="headerlink" title="empty()方法"></a>empty()方法</h4><p>该方法创建一个空内容的<code>Observable</code>序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;Int&gt;.empty()</span><br></pre></td></tr></table></figure></p>
<h4 id="error-方法"><a href="#error-方法" class="headerlink" title="error() 方法"></a>error() 方法</h4><p>该方法创建一个不做任何操作，而是直接发送一个错误的<code>Observable</code>序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum MyError: Error &#123;</span><br><span class="line">    case A</span><br><span class="line">    case B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let observable = Observable&lt;Int&gt;.error(MyError.A)</span><br></pre></td></tr></table></figure></p>
<h4 id="range-方法"><a href="#range-方法" class="headerlink" title="range() 方法"></a>range() 方法</h4><p>该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的<code>Observable</code>序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.range(start: 1, count: 5)</span><br></pre></td></tr></table></figure></p>
<h4 id="repeatElement-方法"><a href="#repeatElement-方法" class="headerlink" title="repeatElement() 方法"></a>repeatElement() 方法</h4><p>该方法创建一个可以无限发出给定元素的<code>Event</code>的<code>Observable</code>序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.repeatElement(1)</span><br></pre></td></tr></table></figure></p>
<h4 id="generate-方法"><a href="#generate-方法" class="headerlink" title="generate() 方法"></a>generate() 方法</h4><p>该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的<code>Observable</code>序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable.generate(</span><br><span class="line">    initialState: 0,</span><br><span class="line">    condition: &#123; $0 &lt;= 10 &#125;,</span><br><span class="line">    iterate: &#123; $0 + 2 &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h4 id="interval-方法"><a href="#interval-方法" class="headerlink" title="interval() 方法"></a>interval() 方法</h4><p>这个方法创建的<code>Observable</code>序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">//next(0) next(1) next(2)......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="timer-方法"><a href="#timer-方法" class="headerlink" title="timer() 方法"></a>timer() 方法</h4><ul>
<li><p>创建的<code>Observable</code>序列在经过设定的一段时间后，产生唯一的一个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//10秒种后发出唯一的一个元素0</span><br><span class="line">let observable = Observable&lt;Int&gt;.timer(10, scheduler: MainScheduler.instance)</span><br><span class="line">observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建的<code>Observable</code>序列在经过设定的一段时间后，每隔一段时间产生一个元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//延时10秒种后，每隔1秒钟发出一个元素</span><br><span class="line">let observable = Observable&lt;Int&gt;.timer(10, period: 1, scheduler: MainScheduler.instance)</span><br><span class="line">    observable.subscribe &#123; event in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="create-方法"><a href="#create-方法" class="headerlink" title="create()方法"></a>create()方法</h4><p>该方法接受一个<code>block</code>形式的参数，任务是对每一个过来的订阅进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let observable = Observable&lt;String&gt;.create &#123; (observer) -&gt; Disposable in</span><br><span class="line">    observer.onNext(&quot;test&quot;)</span><br><span class="line">    observer.onCompleted()</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br><span class="line">observable.subscribe &#123; (element) in</span><br><span class="line">    print(element)</span><br><span class="line">&#125;</span><br><span class="line">//next(test)</span><br><span class="line">//completed</span><br></pre></td></tr></table></figure></p>
<h4 id="deferred-方法"><a href="#deferred-方法" class="headerlink" title="deferred() 方法"></a>deferred() 方法</h4><p>该个方法相当于是创建一个<code>Observable</code>工厂，通过传入一个<code>block</code>来执行延迟<code>Observable</code>序列创建的行为，而这个<code>block</code>里就是真正的实例化序列对象的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var time = 0</span><br><span class="line">let factory: Observable&lt;Int&gt; = Observable.deferred &#123;</span><br><span class="line">    time += 1</span><br><span class="line">    return Observable.just(time)</span><br><span class="line">&#125;</span><br><span class="line">factory.subscribe &#123; (event) in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line">factory.subscribe &#123; (event) in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line">factory.subscribe &#123; (event) in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line">factory.subscribe &#123; (event) in</span><br><span class="line">    print(event)</span><br><span class="line">&#125;</span><br><span class="line">/* </span><br><span class="line">打印结果</span><br><span class="line">next(1)</span><br><span class="line">completed</span><br><span class="line">next(2)</span><br><span class="line">completed</span><br><span class="line">next(3)</span><br><span class="line">completed</span><br><span class="line">next(4)</span><br><span class="line">completed</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<h3 id="特征序列"><a href="#特征序列" class="headerlink" title="特征序列"></a>特征序列</h3><p><code>Swift</code>是一个强类型语言，它相对弱类型语言更加严谨。我们可以通过类型来判断出，实例有哪些特征。同样的在<code>RxSwift</code> 里面<code>Observable</code>也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码，他们分别是<code>Single</code>、<code>Completable</code>、<code>Maybe</code>、<code>Driver</code>、<code>ControlEvent</code>、<code>ControlProperty</code></p>
<h4 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h4><p><code>Single</code>,在<code>RxSwift</code>中,对它的解释是<em>Represents a push style sequence containing 1 element</em>，它要么只能发出一个元素，要么产生一个<code>error</code>事件</p>
<ul>
<li>发出一个元素或一个<code>error</code>事件</li>
<li>不会共享状态变化<br>附：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum SingleEvent&lt;Element&gt; &#123;</span><br><span class="line">case success(Element)</span><br><span class="line">case error(Swift.Error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>比如说，我们利用<code>Single</code>实现一个网络请求，返回成功的结果或失败:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func getReop(_ repo: String) -&gt; Single&lt;[String: Any]&gt;&#123;</span><br><span class="line">    return Single&lt;[String: Any]&gt;.create(subscribe: &#123; (single) -&gt; Disposable in</span><br><span class="line">        let url = URL.init(string: &quot;https://api.github.com/repos/\(repo)&quot;)!</span><br><span class="line">        let task = URLSession.shared.dataTask(with: url, completionHandler: &#123; (data, response, error) in</span><br><span class="line">            if let error = error&#123;</span><br><span class="line">                single(.error(error))</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            guard let data = data,</span><br><span class="line">                let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),</span><br><span class="line">                let result = json as? [String: Any] else&#123;</span><br><span class="line">                    single(.error(DataError.cantParseJSON))</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">                single(.success(result))</span><br><span class="line">        &#125;)</span><br><span class="line">        task.resume()</span><br><span class="line">        return Disposables.create &#123;</span><br><span class="line">            task.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//与数据相关的错误类型</span><br><span class="line">enum DataError: Error &#123;</span><br><span class="line">    case cantParseJSON</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们想调用这个方法的时候:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let disposeBag = DisposeBag()</span><br><span class="line">getReop(&quot;ReactiveX/RxSwift&quot;).subscribe(onSuccess: &#123; (json) in</span><br><span class="line">    print(&quot;Json:\(json)&quot;)</span><br><span class="line">&#125;) &#123; (error) in</span><br><span class="line">    print(&quot;error:\(error)&quot;)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<h4 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h4><p><code>Completable</code>，在<code>RxSwift</code>中，对它的解释<em>Represents a push style sequence containing 0 elements.</em>可以理解为表示包含0个元素的推送样式序列，它要么产生<code>completed</code>事件，要么产生<code>error</code>事件。</p>
<ul>
<li>不会发出任何元素</li>
<li>只会发出一个<code>completed</code>事件或者一个<code>error</code>事件</li>
<li>不会共享状态变化<br>附：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum CompletableEvent &#123;</span><br><span class="line">    case error(Swift.Error)  </span><br><span class="line">    case completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>举个🌰:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func cacheLocally() -&gt; Completable &#123;</span><br><span class="line">    return Completable.create(subscribe: &#123; (completable) -&gt; Disposable in</span><br><span class="line">    //将数据缓存到本地（这里掠过具体的业务代码，随机成功或失败）</span><br><span class="line">    let success = (arc4random() % 2 == 0)</span><br><span class="line">    guard success else &#123;</span><br><span class="line">        completable(.error(CacheError.failedCaching))</span><br><span class="line">        return Disposables.create&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    completable(.completed)</span><br><span class="line">    return Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">enum CacheError: Error &#123;</span><br><span class="line">    case failedCaching</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cacheLocally().subscribe(onCompleted: &#123;</span><br><span class="line">    print(&quot;completed&quot;)</span><br><span class="line">&#125;) &#123; (error) in</span><br><span class="line">    print(&quot;error:\(error)&quot;)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p><code>MayBe</code>介于<code>Single</code>和<code>Completable</code>之间，它要么只能发出一个元素，要么产生一个<code>completed</code>事件，要么产生一个<code>error</code>事件。</p>
<ul>
<li>发出一个元素、或者一个<code>completed</code>事件、或者一个<code>error</code> 事件</li>
<li>不会共享状态变化<br>附：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum MaybeEvent&lt;Element&gt; &#123;</span><br><span class="line">case success(Element)</span><br><span class="line">case error(Swift.Error)</span><br><span class="line">case completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>举个🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func generateString() -&gt; Maybe&lt;String&gt;&#123;</span><br><span class="line">    return Maybe&lt;String&gt;.create(subscribe: &#123; (maybe) -&gt; Disposable in</span><br><span class="line">    maybe(.success(&quot;success&quot;))</span><br><span class="line">    maybe(.completed)</span><br><span class="line">    maybe(.error(StringError.failedGenerate))</span><br><span class="line">    return Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">enum StringError: Error &#123;</span><br><span class="line">    case failedGenerate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">generateString().subscribe(onSuccess: &#123; (element) in</span><br><span class="line">    print(&quot;success:\(element)&quot;)</span><br><span class="line">&#125;, onError: &#123; (error) in</span><br><span class="line">    print(&quot;error:\(error)&quot;)</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    print(&quot;completed&quot;)  </span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<h4 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h4><p><code>Driver</code>准确来说是<code>RxCocoa</code>的特征序列，目标是提供一种简便的方式在 UI 层编写响应式代码。</p>
<h5 id="为什么使用Driver"><a href="#为什么使用Driver" class="headerlink" title="为什么使用Driver"></a>为什么使用Driver</h5><p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html" target="_blank" rel="noopener">这部分我们引用RxSwift中文文档内容</a><br>我们举个例子来说明一下，为什么要使用<code>Driver</code><br>这是文档简介页的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let results = query.rx.text</span><br><span class="line">                    .throttle(0.3, scheduler: MainScheduler.instance)   </span><br><span class="line">                    .flatMapLatest &#123; query in</span><br><span class="line">                        fetchAutoCompleteItems(query)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .map &#123; &quot;\($0.count)&quot; &#125;</span><br><span class="line">    .bind(to: resultCount.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class="line">    (_, result, cell) in</span><br><span class="line">    cell.textLabel?.text = &quot;\(result)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>这段代码的主要目的是：</p>
<ul>
<li>取出用户输入稳定后的内容</li>
<li>向服务器请求一组结果</li>
<li>将返回的结果绑定到两个 UI 元素上：<code>tableView</code>和 显示结果数量的<code>label</code><br>代码存在的问题：</li>
<li>如果<code>fetchAutoCompleteItems</code>的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求</li>
<li>如果<code>fetchAutoCompleteItems</code>在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃</li>
<li>返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果<br>一个更好的方案是这样的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let results = query.rx.text</span><br><span class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class="line">    .flatMapLatest &#123; query in</span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">    .observeOn(MainScheduler.instance)  // 结果在主线程返回</span><br><span class="line">    .catchErrorJustReturn([])           // 错误被处理了，这样至少不会终止整个序列</span><br><span class="line">    &#125;</span><br><span class="line">    .share(replay: 1)                           // HTTP 请求是被共享的</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .map &#123; &quot;\($0.count)&quot; &#125;</span><br><span class="line">    .bind(to: resultCount.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class="line">    (_, result, cell) in</span><br><span class="line">        cell.textLabel?.text = &quot;\(result)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在一个大型系统内，要确保每一步不被遗漏是一件不太容易的事情。所以更好的选择是合理运用编译器和特征序列来确保这些必备条件都已经满足。<br>以下是使用<code>Driver</code>优化后的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let results = query.rx.text.asDriver()        // 将普通序列转换为 Driver</span><br><span class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class="line">    .flatMapLatest &#123; query in</span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .asDriver(onErrorJustReturn: [])  // 仅仅提供发生错误时的备选返回值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .map &#123; &quot;\($0.count)&quot; &#125;</span><br><span class="line">    .drive(resultCount.rx.text)               // 这里改用 `drive` 而不是 `bindTo`</span><br><span class="line">    .disposed(by: disposeBag)                 // 这样可以确保必备条件都已经满足了</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class="line">    (_, result, cell) in</span><br><span class="line">        cell.textLabel?.text = &quot;\(result)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>首先第一个<code>asDriver</code>方法将<code>ControlProperty</code>转换为<code>Driver</code><br>然后第二个变化是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.asDriver(onErrorJustReturn: [])</span><br></pre></td></tr></table></figure></p>
<p>任何可被监听的序列都可以被转换为 Driver，只要他满足 3 个条件:</p>
<ul>
<li>不会产生 error 事件</li>
<li>一定在 MainScheduler 监听（主线程监听）</li>
<li>共享状态变化<br>那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。asDriver(onErrorJustReturn: []) 相当于以下代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let safeSequence = xs</span><br><span class="line">    .observeOn(MainScheduler.instance)       // 主线程监听</span><br><span class="line">    .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误</span><br><span class="line">    .share(replay: 1, scope: .whileConnected)// 共享状态变化</span><br><span class="line">return Driver(raw: safeSequence)           // 封装</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最后使用<code>drive</code>而不是<code>bindTo</code>。</p>
<h4 id="ControlEvent"><a href="#ControlEvent" class="headerlink" title="ControlEvent"></a>ControlEvent</h4><p><code>ControlProperty</code>是专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（<code>Observable</code>），它也是<code>RxCocoa</code>的特征序列<br><code>ControlProperty</code>具有以下特征：</p>
<ul>
<li>不会产生<code>error</code>事件</li>
<li>一定在<code>MainScheduler</code>订阅（主线程订阅）</li>
<li>一定在<code>MainScheduler</code>监听（主线程监听）</li>
<li>共享状态变化<br>举个🌰：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var textField: UITextField!</span><br><span class="line">    @IBOutlet weak var label: UILabel!</span><br><span class="line">    //负责对象销毁</span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        //将textField输入的文字绑定到label上</span><br><span class="line">        textField.rx.text</span><br><span class="line">            .bind(to: label.rx.text)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">        &#125;</span><br><span class="line">    override func didReceiveMemoryWarning() &#123;</span><br><span class="line">        super.didReceiveMemoryWarning()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>有人可能会纳闷，这跟<code>ControlProperty</code>有什么关系，没看到它的影子啊。我们查看<code>textField.rx.text</code>的<code>text</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extension Reactive where Base : UITextField &#123;</span><br><span class="line">public var text: ControlProperty&lt;String?&gt; &#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public var value: ControlProperty&lt;String?&gt; &#123;</span><br><span class="line">    return base.rx.controlPropertyWithDefaultEvents(</span><br><span class="line">        getter: &#123; textField in</span><br><span class="line">        textField.text</span><br><span class="line">    &#125;,</span><br><span class="line">        setter: &#123; textField, value in</span><br><span class="line">            if textField.text != value &#123;</span><br><span class="line">            textField.text = value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原来UITextField 的<code>rx.text</code>属性类型便是 <code>ControlProperty&lt;String?&gt;</code><br>同时，这段代码也给我们启示，为控件添加属性，可以采用<code>extension Reactive where Base : UITextField</code>的方法。</p>
<h4 id="ControlEvent-1"><a href="#ControlEvent-1" class="headerlink" title="ControlEvent"></a>ControlEvent</h4><p><code>ControlEvent</code>专门用于描述 UI 控件所产生的事件，它具有跟<code>ControlProperty</code>一样的特征：</p>
<ul>
<li>不会产生<code>error</code>事件</li>
<li>一定在<code>MainScheduler</code>订阅（主线程订阅）</li>
<li>一定在<code>MainScheduler</code>监听（主线程监听）</li>
<li>共享状态变化<br>举个🌰：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">import RxSwift</span><br><span class="line">import RxCocoa</span><br><span class="line"></span><br><span class="line">class ViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    let disposeBag = DisposeBag()</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var button: UIButton!</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line"></span><br><span class="line">        //订阅按钮点击事件</span><br><span class="line">        button.rx.tap</span><br><span class="line">            .subscribe(onNext: &#123;</span><br><span class="line">                print(&quot;blick&quot;)</span><br><span class="line">            &#125;).disposed(by: disposeBag)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可能也有人会疑问，<code>ControlEvent</code>在哪？查看tap方法，会看到源码（<code>UIButton+Rx.swift</code>），这个时候就会发现 UIButton 的<code>rx.tap</code>方法类型便是<code>ControlEvent&lt;Void&gt;</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import RxSwift</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">extension Reactive where Base: UIButton &#123;</span><br><span class="line">public var tap: ControlEvent&lt;Void&gt; &#123;</span><br><span class="line">    return controlEvent(.touchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，我们就对<code>Observable</code>有了一个简单的介绍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DarrenW</p>
              <p class="site-description motion-element" itemprop="description">笨鸟先飞，知行合一。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/darren1192" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DarrenW</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
