{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"670e20f3fcb29fb927dc3449a34ef295eb7070f0","modified":1539933361839},{"_id":"themes/next/.DS_Store","hash":"c04ab2ef349f6c4989f84f79f3e67c6f2fb92da7","modified":1539933624934},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1539932867495},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1539932867495},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1539932867496},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1539932867498},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1539932867498},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1539932867498},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1539932867498},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1539932867499},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1539932867499},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1539932867499},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1539932867500},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1539932867500},{"_id":"themes/next/_config.yml","hash":"d09ab274ac81db9615d1ba914c7ec6c34b292db9","modified":1539933548510},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1539932867501},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1539932867501},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1539932867531},{"_id":"source/_posts/.DS_Store","hash":"44f551836110f1859450752322668b2fda0aa93b","modified":1539933361840},{"_id":"source/_posts/RxSwift-Observable-Observer和辅助类型.md","hash":"58e3a5d1d6f6a8f9dc01c328c0043f8bbdb6d167","modified":1539933361840},{"_id":"source/_posts/RxSwift-Observable-可观察序列.md","hash":"a679ebe655fb4a861649d39d931d31f8fda5380f","modified":1539933361841},{"_id":"source/_posts/RxSwift-Observer-观察者.md","hash":"f7931cbc05e31a14ca680eee86c89402746e6595","modified":1539933361841},{"_id":"source/_posts/RxSwift-变换操作-Transforming-Observables.md","hash":"995d31dedbc922a7a793ddaae6e3882ae35e4ae1","modified":1539933361841},{"_id":"source/_posts/RxSwift-开门第一篇.md","hash":"d9427abc71e061c1ab1f46fba42f9ad6212a2983","modified":1539933361842},{"_id":"source/_posts/RxSwift-操作符决策树.md","hash":"a2a88bd7e9a2678573080210187aa6754dc95766","modified":1539933361842},{"_id":"source/_posts/RxSwift-条件和布尔操作符-Conditional-and-Boolean-Operators.md","hash":"2a64e37d66323ed10665e996d6b1df4f2a8354e4","modified":1539933361842},{"_id":"source/_posts/RxSwift-核心.md","hash":"aa08e859be89a6f6f0e9836505099420a07397a6","modified":1539933361843},{"_id":"source/_posts/RxSwift-结合操作符.md","hash":"1a56a4450841889d83d298c1b3253459e1e5be3e","modified":1539933361843},{"_id":"source/_posts/RxSwift-过滤操作符-Filtering-Observables.md","hash":"71365a620bafd87ced6a461f54f0dc25e79ca9cf","modified":1539933361843},{"_id":"source/_posts/swift-Sequence.md","hash":"972a200d62bedcd5061e02a77b8f79cce1dcdb50","modified":1539933361844},{"_id":"source/_posts/一张图片引发的思考.md","hash":"b012f36df49932506adf6f8e82d66c8f5cbc1c4e","modified":1539933361844},{"_id":"source/_posts/源码阅读-Kingfisher.md","hash":"9d9a63433d2f35092ce22ca9807ee4c5acff2183","modified":1539933361845},{"_id":"source/tags/.DS_Store","hash":"45673a8ec47535550c1655fb6f129816c4bf94f9","modified":1539933361845},{"_id":"source/tags/index.md","hash":"47022c4e01fdf2b3afa3e1c307d1ce27e6916ec4","modified":1539933361845},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1539932867488},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1539932867490},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1539932843901},{"_id":"themes/next/.git/index","hash":"c68c6adf69424f2fc92155f4eaca1b80ee7a525c","modified":1539932964301},{"_id":"themes/next/.git/packed-refs","hash":"8e36811256ee380c2c65692f1b8f8e77c5bc33c9","modified":1539932867486},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1539932867496},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1539932867496},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1539932867497},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1539932867497},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1539932867502},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1539932867502},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1539932867503},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1539932867503},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1539932867503},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1539932867504},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1539932867504},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1539932867504},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1539932867504},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1539932867505},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1539932867505},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1539932867505},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1539932867505},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1539932867505},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1539932867506},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1539932867506},{"_id":"themes/next/layout/.DS_Store","hash":"adad15655ef7ba7e3b39a89602157c5e89d99202","modified":1539933624938},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1539932867507},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1539932867529},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1539932867529},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1539932867529},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1539932867530},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1539932867530},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1539932867531},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1539932867531},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1539932867532},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1539932867532},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1539932867644},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1539932867645},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1539932867645},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867570},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1539932843902},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1539932843902},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1539932843903},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1539932843903},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1539932843902},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1539932843904},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1539932843902},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1539932843903},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1539932843903},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1539932843904},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1539932843901},{"_id":"themes/next/.git/logs/HEAD","hash":"fec6037e001909c10a6b33b3405348f08bb4f68c","modified":1539932867489},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1539932867506},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1539932867507},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1539932867507},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1539932867507},{"_id":"themes/next/layout/_macro/post.swig","hash":"4aa7eda227587e8a33d477c77e7d3ae463c0de18","modified":1539933716204},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1539932867508},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1539932867508},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1539932867509},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1539932867509},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1539932867510},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1539932867510},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1539932867511},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1539932867512},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1539932867512},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1539932867512},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1539932867515},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1539932867517},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1539932867518},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1539932867525},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1539932867525},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1539932867525},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1539932867526},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1539932867526},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1539932867526},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1539932867526},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1539932867533},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1539932867533},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1539932867534},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1539932867534},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1539932867534},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1539932867535},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1539932867535},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1539932867535},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1539932867536},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1539932867570},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1539932867571},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1539932867571},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1539932867571},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1539932867572},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1539932867572},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1539932867573},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1539932867573},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1539932867574},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1539932867574},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1539932867574},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1539932867575},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1539932867575},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1539932867575},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1539932867576},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1539932867576},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1539932867576},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1539932867577},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1539932867577},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867518},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867518},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867560},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867560},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867561},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867569},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867570},{"_id":"themes/next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1539932867488},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1539932867511},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1539932867511},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1539932867513},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1539932867513},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1539932867513},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1539932867514},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1539932867514},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1539932867514},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1539932867514},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1539932867517},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1539932867517},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1539932867518},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1539932867519},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1539932867519},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1539932867519},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1539932867520},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1539932867520},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1539932867520},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1539932867521},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1539932867521},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1539932867521},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1539932867521},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1539932867522},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1539932867522},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1539932867522},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1539932867523},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1539932867523},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1539932867523},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1539932867523},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1539932867524},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1539932867524},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1539932867524},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1539932867524},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1539932867525},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1539932867527},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1539932867528},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1539932867528},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1539932867528},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1539932867559},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1539932867560},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1539932867560},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1539932867561},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1539932867569},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1539932867569},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1539932867569},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1539932867570},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1539932867578},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1539932867578},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1539932867578},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1539932867579},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1539932867579},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1539932867580},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1539932867580},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1539932867580},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1539932867581},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1539932867581},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1539932867582},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1539932867588},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1539932867593},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1539932867593},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1539932867594},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1539932867594},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1539932867601},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1539932867601},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1539932867602},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1539932867602},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1539932867603},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1539932867603},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1539932867604},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1539932867604},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1539932867604},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1539932867620},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1539932867622},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1539932867622},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1539932867623},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1539932867623},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1539932867623},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1539932867623},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1539932867624},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1539932867625},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1539932867625},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1539932867626},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1539932867626},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1539932867626},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1539932867627},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1539932867627},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1539932867627},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1539932867628},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1539932867628},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1539932867628},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1539932867629},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1539932867629},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1539932867629},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1539932867630},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1539932867630},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1539932867631},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1539932867631},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1539932867632},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1539932867639},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1539932867639},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1539932867642},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1539932867643},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1539932867644},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1539932867621},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"fec6037e001909c10a6b33b3405348f08bb4f68c","modified":1539932867489},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1539932867487},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1539932867527},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1539932867527},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1539932867536},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1539932867537},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1539932867537},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1539932867537},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1539932867537},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1539932867542},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1539932867550},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1539932867557},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1539932867558},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1539932867558},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1539932867558},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1539932867558},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1539932867559},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1539932867559},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1539932867561},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1539932867562},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1539932867562},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1539932867562},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1539932867563},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1539932867563},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1539932867563},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1539932867564},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1539932867565},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1539932867565},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1539932867565},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1539932867566},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1539932867566},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1539932867567},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1539932867567},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1539932867567},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1539932867568},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1539932867568},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1539932867568},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1539932867581},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1539932867587},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1539932867588},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1539932867594},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1539932867595},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1539932867595},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1539932867596},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1539932867596},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1539932867596},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1539932867599},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1539932867599},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1539932867600},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1539932867602},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1539932867603},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1539932867605},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1539932867605},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1539932867606},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1539932867638},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1539932867638},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1539932867585},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1539932867587},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1539932867619},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1539932867619},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1539932867641},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"fec6037e001909c10a6b33b3405348f08bb4f68c","modified":1539932867487},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1539932867538},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1539932867538},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1539932867539},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1539932867539},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1539932867539},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1539932867539},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1539932867540},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1539932867540},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1539932867541},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1539932867541},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1539932867541},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1539932867541},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1539932867542},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1539932867542},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1539932867543},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1539932867543},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1539932867543},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1539932867544},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1539932867544},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1539932867544},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1539932867544},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1539932867545},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1539932867545},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1539932867545},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1539932867546},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1539932867546},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1539932867546},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1539932867546},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1539932867547},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1539932867547},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1539932867547},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1539932867548},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1539932867548},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1539932867549},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1539932867549},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1539932867549},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1539932867550},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1539932867550},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1539932867550},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1539932867551},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1539932867551},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1539932867552},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1539932867552},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1539932867552},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1539932867553},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1539932867553},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1539932867553},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1539932867554},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1539932867554},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1539932867554},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1539932867555},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1539932867555},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1539932867555},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1539932867556},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1539932867556},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1539932867556},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1539932867556},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1539932867557},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1539932867564},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1539932867564},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1539932867566},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1539932867583},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1539932867583},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1539932867584},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1539932867584},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1539932867585},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1539932867597},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1539932867597},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1539932867597},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1539932867598},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1539932867598},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1539932867598},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1539932867608},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1539932867611},{"_id":"themes/next/.git/objects/pack/pack-bef4d2add504242e74ed1374f132b443073d8f8a.idx","hash":"b70c62326a6b37fa37000c4c22c5056990d5955b","modified":1539932867467},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1539932867618},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1539932867592},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1539932867636},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1539932867615},{"_id":"themes/next/.git/objects/pack/pack-bef4d2add504242e74ed1374f132b443073d8f8a.pack","hash":"dc578b9d9f8779e98d2a93a35f021ce52be5b1e4","modified":1539932867461}],"Category":[],"Data":[],"Page":[{"title":"All Tags","date":"2018-09-13T13:48:18.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: All Tags\ndate: 2018-09-13 21:48:18\ntype: \"tags\"\n---\n","updated":"2018-10-19T07:16:01.845Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjnfp0loc0001imcwz58s5elk","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"RxSwift Observer-观察者","date":"2018-09-21T15:18:04.000Z","_content":"我们在[之前](https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more)已经了解了什么是`Observer`观察者，这篇我们了解一下怎么创建观察者以及特征观察者(`AnyObserver`、`Binder`)。\n#### 在 subscribe 方法中创建\n创建观察者最直接的方法就是在`Observable`的`subscribe`方法后面描述当事件发生时，需要如何做出响应。举个🌰：\n```\nlet observable = Observable.of(1,2,3,4,5)\nobservable.subscribe(onNext: { element in\n    print(element)\n}, onError: { error in\n    print(error)\n}, onCompleted: {\n    print(\"completed\")\n})\n```\n运行结果如下：\n![运行结果.png](https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 在bind方法中创建\n我们创建一个定时生成索引数的`Observable`序列，并将索引数不断显示在`label`标签上\n举个🌰：\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{ \"当前索引数:\\($0)\" }\n                .bind { [weak self](text) in\n                    self?.label.text = text\n                }.disposed(by: disposeBag)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n运行结果：\n![bind结果.png](https://upload-images.jianshu.io/upload_images/2855070-c9f8b9f5593b1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n除了以上创建方法外，我们还可以使用其他的方式，比如`AnyObserver`和`Binder `\n#### 使用AnyObserver创建观察者\n`AnyObserver`可以用来描叙任意一种观察者\n##### 配合`subscribe `方法使用\n```\nlet observer: AnyObserver<Int> = AnyObserver { event in\n    switch event{\n    case .next(let data):\n        print(data)\n    case .error(let error):\n        print(error)\n    case .completed:\n        print(\"completed\")\n    }\n}\nlet observable = Observable.of(1,2,3,4,5)\nobservable.subscribe(observer)\n```\n运行结果如下：\n![运行结果.png](https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n##### 配合bindTo方法使用\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observer: AnyObserver<String> = AnyObserver{\n            [weak self] event in\n            switch event{\n            case .next(let text):\n                self?.label.text = text\n            default:\n            break\n            }\n        }\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{\"当前索引数:\\($0)\"}\n                .bind(to: observer)\n                .disposed(by: disposeBag )\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n}\n```\n#### Binder\nBinder 主要有以下两个特征：\n- 不会处理错误事件\n- 确保绑定都是在给定`Schedule`上执行（默认`MainScheduler`）\n\n一旦产生错误事件，在调试环境下将执行`fatalError`，在发布环境下将打印错误信息\n在上面更新`label`文字的例子中，更好的方式就是使用`Binder`。理由有二：\n- UI的更新在主线程完成\n- 只处理`next`事件\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observer: Binder<String> = Binder(label){\n            (view,text) in\n            view.text = text\n        }\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{ \"当前索引数:\\($0)\"}\n                .bind(to: observer)\n                .disposed(by: disposeBag)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n下面，我们再去实现另外一段代码：\n```\nlet observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\nobservable.map{ $0 % 2 == 0}\n        .bind(to: label.rx.isHidden)\n        .disposed(by: disposeBag)\n```\n此时label会不断的消失、出现。这段代码里我们又操作了什么？查看`label.rx.isHidden`中`isHidden`可以发现\n```\nextension Reactive where Base: UIView {\n    public var isHidden: Binder<Bool> {\n        return Binder(self.base) { view, hidden in\n            view.isHidden = hidden\n        }\n    }\n}\n```\n其实`RxCocoa`在对许多 UI 控件进行扩展时，就利用`Binder`将控件属性变成观查者，我们也可以用这种方式来创建自定义的 UI 观察者。\n\n\n\n\n\n","source":"_posts/RxSwift-Observer-观察者.md","raw":"---\ntitle: RxSwift Observer-观察者\ndate: 2018-09-21 23:18:04\ntags: RxSwift\n---\n我们在[之前](https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more)已经了解了什么是`Observer`观察者，这篇我们了解一下怎么创建观察者以及特征观察者(`AnyObserver`、`Binder`)。\n#### 在 subscribe 方法中创建\n创建观察者最直接的方法就是在`Observable`的`subscribe`方法后面描述当事件发生时，需要如何做出响应。举个🌰：\n```\nlet observable = Observable.of(1,2,3,4,5)\nobservable.subscribe(onNext: { element in\n    print(element)\n}, onError: { error in\n    print(error)\n}, onCompleted: {\n    print(\"completed\")\n})\n```\n运行结果如下：\n![运行结果.png](https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 在bind方法中创建\n我们创建一个定时生成索引数的`Observable`序列，并将索引数不断显示在`label`标签上\n举个🌰：\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{ \"当前索引数:\\($0)\" }\n                .bind { [weak self](text) in\n                    self?.label.text = text\n                }.disposed(by: disposeBag)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n运行结果：\n![bind结果.png](https://upload-images.jianshu.io/upload_images/2855070-c9f8b9f5593b1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n除了以上创建方法外，我们还可以使用其他的方式，比如`AnyObserver`和`Binder `\n#### 使用AnyObserver创建观察者\n`AnyObserver`可以用来描叙任意一种观察者\n##### 配合`subscribe `方法使用\n```\nlet observer: AnyObserver<Int> = AnyObserver { event in\n    switch event{\n    case .next(let data):\n        print(data)\n    case .error(let error):\n        print(error)\n    case .completed:\n        print(\"completed\")\n    }\n}\nlet observable = Observable.of(1,2,3,4,5)\nobservable.subscribe(observer)\n```\n运行结果如下：\n![运行结果.png](https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n##### 配合bindTo方法使用\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observer: AnyObserver<String> = AnyObserver{\n            [weak self] event in\n            switch event{\n            case .next(let text):\n                self?.label.text = text\n            default:\n            break\n            }\n        }\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{\"当前索引数:\\($0)\"}\n                .bind(to: observer)\n                .disposed(by: disposeBag )\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n}\n```\n#### Binder\nBinder 主要有以下两个特征：\n- 不会处理错误事件\n- 确保绑定都是在给定`Schedule`上执行（默认`MainScheduler`）\n\n一旦产生错误事件，在调试环境下将执行`fatalError`，在发布环境下将打印错误信息\n在上面更新`label`文字的例子中，更好的方式就是使用`Binder`。理由有二：\n- UI的更新在主线程完成\n- 只处理`next`事件\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observer: Binder<String> = Binder(label){\n            (view,text) in\n            view.text = text\n        }\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{ \"当前索引数:\\($0)\"}\n                .bind(to: observer)\n                .disposed(by: disposeBag)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n下面，我们再去实现另外一段代码：\n```\nlet observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\nobservable.map{ $0 % 2 == 0}\n        .bind(to: label.rx.isHidden)\n        .disposed(by: disposeBag)\n```\n此时label会不断的消失、出现。这段代码里我们又操作了什么？查看`label.rx.isHidden`中`isHidden`可以发现\n```\nextension Reactive where Base: UIView {\n    public var isHidden: Binder<Bool> {\n        return Binder(self.base) { view, hidden in\n            view.isHidden = hidden\n        }\n    }\n}\n```\n其实`RxCocoa`在对许多 UI 控件进行扩展时，就利用`Binder`将控件属性变成观查者，我们也可以用这种方式来创建自定义的 UI 观察者。\n\n\n\n\n\n","slug":"RxSwift-Observer-观察者","published":1,"updated":"2018-10-19T07:16:01.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0lo80000imcwah70l8p5","content":"<p>我们在<a href=\"https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more\" target=\"_blank\" rel=\"noopener\">之前</a>已经了解了什么是<code>Observer</code>观察者，这篇我们了解一下怎么创建观察者以及特征观察者(<code>AnyObserver</code>、<code>Binder</code>)。</p>\n<h4 id=\"在-subscribe-方法中创建\"><a href=\"#在-subscribe-方法中创建\" class=\"headerlink\" title=\"在 subscribe 方法中创建\"></a>在 subscribe 方法中创建</h4><p>创建观察者最直接的方法就是在<code>Observable</code>的<code>subscribe</code>方法后面描述当事件发生时，需要如何做出响应。举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(1,2,3,4,5)</span><br><span class=\"line\">observable.subscribe(onNext: &#123; element in</span><br><span class=\"line\">    print(element)</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">    print(error)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"运行结果.png\"></p>\n<h4 id=\"在bind方法中创建\"><a href=\"#在bind方法中创建\" class=\"headerlink\" title=\"在bind方法中创建\"></a>在bind方法中创建</h4><p>我们创建一个定时生成索引数的<code>Observable</code>序列，并将索引数不断显示在<code>label</code>标签上<br>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123; &quot;当前索引数:\\($0)&quot; &#125;</span><br><span class=\"line\">                .bind &#123; [weak self](text) in</span><br><span class=\"line\">                    self?.label.text = text</span><br><span class=\"line\">                &#125;.disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-c9f8b9f5593b1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"bind结果.png\"><br>除了以上创建方法外，我们还可以使用其他的方式，比如<code>AnyObserver</code>和<code>Binder</code></p>\n<h4 id=\"使用AnyObserver创建观察者\"><a href=\"#使用AnyObserver创建观察者\" class=\"headerlink\" title=\"使用AnyObserver创建观察者\"></a>使用AnyObserver创建观察者</h4><p><code>AnyObserver</code>可以用来描叙任意一种观察者</p>\n<h5 id=\"配合subscribe方法使用\"><a href=\"#配合subscribe方法使用\" class=\"headerlink\" title=\"配合subscribe方法使用\"></a>配合<code>subscribe</code>方法使用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observer: AnyObserver&lt;Int&gt; = AnyObserver &#123; event in</span><br><span class=\"line\">    switch event&#123;</span><br><span class=\"line\">    case .next(let data):</span><br><span class=\"line\">        print(data)</span><br><span class=\"line\">    case .error(let error):</span><br><span class=\"line\">        print(error)</span><br><span class=\"line\">    case .completed:</span><br><span class=\"line\">        print(&quot;completed&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let observable = Observable.of(1,2,3,4,5)</span><br><span class=\"line\">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"运行结果.png\"></p>\n<h5 id=\"配合bindTo方法使用\"><a href=\"#配合bindTo方法使用\" class=\"headerlink\" title=\"配合bindTo方法使用\"></a>配合bindTo方法使用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observer: AnyObserver&lt;String&gt; = AnyObserver&#123;</span><br><span class=\"line\">            [weak self] event in</span><br><span class=\"line\">            switch event&#123;</span><br><span class=\"line\">            case .next(let text):</span><br><span class=\"line\">                self?.label.text = text</span><br><span class=\"line\">            default:</span><br><span class=\"line\">            break</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123;&quot;当前索引数:\\($0)&quot;&#125;</span><br><span class=\"line\">                .bind(to: observer)</span><br><span class=\"line\">                .disposed(by: disposeBag )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">        // Dispose of any resources that can be recreated.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h4><p>Binder 主要有以下两个特征：</p>\n<ul>\n<li>不会处理错误事件</li>\n<li>确保绑定都是在给定<code>Schedule</code>上执行（默认<code>MainScheduler</code>）</li>\n</ul>\n<p>一旦产生错误事件，在调试环境下将执行<code>fatalError</code>，在发布环境下将打印错误信息<br>在上面更新<code>label</code>文字的例子中，更好的方式就是使用<code>Binder</code>。理由有二：</p>\n<ul>\n<li>UI的更新在主线程完成</li>\n<li>只处理<code>next</code>事件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observer: Binder&lt;String&gt; = Binder(label)&#123;</span><br><span class=\"line\">            (view,text) in</span><br><span class=\"line\">            view.text = text</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123; &quot;当前索引数:\\($0)&quot;&#125;</span><br><span class=\"line\">                .bind(to: observer)</span><br><span class=\"line\">                .disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>下面，我们再去实现另外一段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.map&#123; $0 % 2 == 0&#125;</span><br><span class=\"line\">        .bind(to: label.rx.isHidden)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>此时label会不断的消失、出现。这段代码里我们又操作了什么？查看<code>label.rx.isHidden</code>中<code>isHidden</code>可以发现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Reactive where Base: UIView &#123;</span><br><span class=\"line\">    public var isHidden: Binder&lt;Bool&gt; &#123;</span><br><span class=\"line\">        return Binder(self.base) &#123; view, hidden in</span><br><span class=\"line\">            view.isHidden = hidden</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实<code>RxCocoa</code>在对许多 UI 控件进行扩展时，就利用<code>Binder</code>将控件属性变成观查者，我们也可以用这种方式来创建自定义的 UI 观察者。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们在<a href=\"https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more\" target=\"_blank\" rel=\"noopener\">之前</a>已经了解了什么是<code>Observer</code>观察者，这篇我们了解一下怎么创建观察者以及特征观察者(<code>AnyObserver</code>、<code>Binder</code>)。</p>\n<h4 id=\"在-subscribe-方法中创建\"><a href=\"#在-subscribe-方法中创建\" class=\"headerlink\" title=\"在 subscribe 方法中创建\"></a>在 subscribe 方法中创建</h4><p>创建观察者最直接的方法就是在<code>Observable</code>的<code>subscribe</code>方法后面描述当事件发生时，需要如何做出响应。举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(1,2,3,4,5)</span><br><span class=\"line\">observable.subscribe(onNext: &#123; element in</span><br><span class=\"line\">    print(element)</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">    print(error)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"运行结果.png\"></p>\n<h4 id=\"在bind方法中创建\"><a href=\"#在bind方法中创建\" class=\"headerlink\" title=\"在bind方法中创建\"></a>在bind方法中创建</h4><p>我们创建一个定时生成索引数的<code>Observable</code>序列，并将索引数不断显示在<code>label</code>标签上<br>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123; &quot;当前索引数:\\($0)&quot; &#125;</span><br><span class=\"line\">                .bind &#123; [weak self](text) in</span><br><span class=\"line\">                    self?.label.text = text</span><br><span class=\"line\">                &#125;.disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-c9f8b9f5593b1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"bind结果.png\"><br>除了以上创建方法外，我们还可以使用其他的方式，比如<code>AnyObserver</code>和<code>Binder</code></p>\n<h4 id=\"使用AnyObserver创建观察者\"><a href=\"#使用AnyObserver创建观察者\" class=\"headerlink\" title=\"使用AnyObserver创建观察者\"></a>使用AnyObserver创建观察者</h4><p><code>AnyObserver</code>可以用来描叙任意一种观察者</p>\n<h5 id=\"配合subscribe方法使用\"><a href=\"#配合subscribe方法使用\" class=\"headerlink\" title=\"配合subscribe方法使用\"></a>配合<code>subscribe</code>方法使用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observer: AnyObserver&lt;Int&gt; = AnyObserver &#123; event in</span><br><span class=\"line\">    switch event&#123;</span><br><span class=\"line\">    case .next(let data):</span><br><span class=\"line\">        print(data)</span><br><span class=\"line\">    case .error(let error):</span><br><span class=\"line\">        print(error)</span><br><span class=\"line\">    case .completed:</span><br><span class=\"line\">        print(&quot;completed&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let observable = Observable.of(1,2,3,4,5)</span><br><span class=\"line\">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"运行结果.png\"></p>\n<h5 id=\"配合bindTo方法使用\"><a href=\"#配合bindTo方法使用\" class=\"headerlink\" title=\"配合bindTo方法使用\"></a>配合bindTo方法使用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observer: AnyObserver&lt;String&gt; = AnyObserver&#123;</span><br><span class=\"line\">            [weak self] event in</span><br><span class=\"line\">            switch event&#123;</span><br><span class=\"line\">            case .next(let text):</span><br><span class=\"line\">                self?.label.text = text</span><br><span class=\"line\">            default:</span><br><span class=\"line\">            break</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123;&quot;当前索引数:\\($0)&quot;&#125;</span><br><span class=\"line\">                .bind(to: observer)</span><br><span class=\"line\">                .disposed(by: disposeBag )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">        // Dispose of any resources that can be recreated.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h4><p>Binder 主要有以下两个特征：</p>\n<ul>\n<li>不会处理错误事件</li>\n<li>确保绑定都是在给定<code>Schedule</code>上执行（默认<code>MainScheduler</code>）</li>\n</ul>\n<p>一旦产生错误事件，在调试环境下将执行<code>fatalError</code>，在发布环境下将打印错误信息<br>在上面更新<code>label</code>文字的例子中，更好的方式就是使用<code>Binder</code>。理由有二：</p>\n<ul>\n<li>UI的更新在主线程完成</li>\n<li>只处理<code>next</code>事件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observer: Binder&lt;String&gt; = Binder(label)&#123;</span><br><span class=\"line\">            (view,text) in</span><br><span class=\"line\">            view.text = text</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123; &quot;当前索引数:\\($0)&quot;&#125;</span><br><span class=\"line\">                .bind(to: observer)</span><br><span class=\"line\">                .disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>下面，我们再去实现另外一段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.map&#123; $0 % 2 == 0&#125;</span><br><span class=\"line\">        .bind(to: label.rx.isHidden)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>此时label会不断的消失、出现。这段代码里我们又操作了什么？查看<code>label.rx.isHidden</code>中<code>isHidden</code>可以发现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Reactive where Base: UIView &#123;</span><br><span class=\"line\">    public var isHidden: Binder&lt;Bool&gt; &#123;</span><br><span class=\"line\">        return Binder(self.base) &#123; view, hidden in</span><br><span class=\"line\">            view.isHidden = hidden</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实<code>RxCocoa</code>在对许多 UI 控件进行扩展时，就利用<code>Binder</code>将控件属性变成观查者，我们也可以用这种方式来创建自定义的 UI 观察者。</p>\n"},{"title":"RxSwift-开门第一篇","date":"2018-09-18T15:07:11.000Z","_content":"## 开篇扯淡：\n&emsp;&emsp;为什么入RxSwift这个坑？因为我作为一个iOSer，主要语言是swift，日常开发已经很少使用OC。随着产品代码量日益增加，准备从MVC转成MVVM，而MVVM最搭配的就是RxSwift。所以，作为我个人来说，入RxSwift这个坑，还是比较合情合理的。\n## 正经内容：\n### ReactiveX是什么\n[ReactiveX](http://reactivex.io/)（简写: Rx）是一个可以帮助我们简化异步编程的框架.\n它拓展了[观察者模式](https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F)。使你能够自由组合多个异步事件，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。\n### 什么是RxSwift\n[RxSwift](https://github.com/ReactiveX/RxSwift) 是 [Rx](https://github.com/Reactive-Extensions/Rx.NET) 的 **Swift** 版本，它尝试将原有的一些概念移植到 iOS/macOS 平台。\n### 为什么要使用RxSwift\n>复合 - Rx 就是复合的代名词\n复用 - 因为它易复合\n清晰 - 因为声明都是不可变更的\n易用 - 因为它抽象的了异步编程，使我们统一了代码风格\n稳定 - 因为 Rx 是完全通过单元测试的  \n\n当然了，上面都是假大空，具体来说\n在编写代码时我们经常会需要检测某些值的变化，然后进行相应的处理。比如说按钮的点击事件、textFiled值的变化、tableView中cell的点击事件等等。在日常搬砖中，我们针对不同的情况，需要采用不同的事件传递方法去处理，比如**delegate**、**notifinotion**、**target-action**、**KVO**等等。\n而在RxSwift中，让程序里的事件传递响应方法做到统一，全部采用Rx的“信号链”方式。举个🌰：\n__Target Action__\n```\nbutton.addTarget(self, action: #selector(buttonEvent), for: .touchUpInside)\n```\n```\n@objc func buttonEvent(){\n    print(\"button Event\")\n}\n```\n用Rx实现\n```\nbutton.rx.tap.subscribe(onNext: { () in\n    print(\"button event\")\n}, onError: nil, onCompleted: nil, onDispo\nsed: nil)\n```\n这样一来，代码逻辑清晰可见。\n当然了，为了MVVM，还是很有学习RxSwift的必要的。\n#### RxSwift地址与安装\n传送门：[GitHub](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FReactiveX%2FRxSwift)\n这里面啥都有，无需多言。\n#### RxSwift 与 RxCocoa\nRxSwift在日常使用中，需要import\n```\nimport RxCocoa\nimport RxSwift\n```\n这个两个库的作用分别是：\n- RxSwift：它只是基于 Swift 语言的 Rx 标准实现接口库，所以 RxSwift 里不包含任何 Cocoa 或者 UI方面的类。\n- RxCocoa：是基于 RxSwift针对于 iOS开发的一个库，它通过 Extension 的方法给原生的比如 UI 控件添加了 Rx 的特性，使得我们更容易订阅和响应这些控件的事件。\n\n既然已经有了这个RxSwift开篇，希望自己坚持下去。虽然不太喜欢写文章，但这也不失为监督自己的一个方法。__笨鸟先飞，知行合一。__\n最后，感谢那些“巨人”，对于RxSwift的学习，完全是站在巨人的肩膀上，感谢他们的文章，指引了我的方向。尤其感谢[RxSwift中文文档](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/)和[航哥swift](http://www.hangge.com/)，他们的文章，对我的帮助很大，感谢。\n","source":"_posts/RxSwift-开门第一篇.md","raw":"---\ntitle: RxSwift-开门第一篇\ndate: 2018-09-18 23:07:11\ntags: RxSwift\n---\n## 开篇扯淡：\n&emsp;&emsp;为什么入RxSwift这个坑？因为我作为一个iOSer，主要语言是swift，日常开发已经很少使用OC。随着产品代码量日益增加，准备从MVC转成MVVM，而MVVM最搭配的就是RxSwift。所以，作为我个人来说，入RxSwift这个坑，还是比较合情合理的。\n## 正经内容：\n### ReactiveX是什么\n[ReactiveX](http://reactivex.io/)（简写: Rx）是一个可以帮助我们简化异步编程的框架.\n它拓展了[观察者模式](https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F)。使你能够自由组合多个异步事件，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。\n### 什么是RxSwift\n[RxSwift](https://github.com/ReactiveX/RxSwift) 是 [Rx](https://github.com/Reactive-Extensions/Rx.NET) 的 **Swift** 版本，它尝试将原有的一些概念移植到 iOS/macOS 平台。\n### 为什么要使用RxSwift\n>复合 - Rx 就是复合的代名词\n复用 - 因为它易复合\n清晰 - 因为声明都是不可变更的\n易用 - 因为它抽象的了异步编程，使我们统一了代码风格\n稳定 - 因为 Rx 是完全通过单元测试的  \n\n当然了，上面都是假大空，具体来说\n在编写代码时我们经常会需要检测某些值的变化，然后进行相应的处理。比如说按钮的点击事件、textFiled值的变化、tableView中cell的点击事件等等。在日常搬砖中，我们针对不同的情况，需要采用不同的事件传递方法去处理，比如**delegate**、**notifinotion**、**target-action**、**KVO**等等。\n而在RxSwift中，让程序里的事件传递响应方法做到统一，全部采用Rx的“信号链”方式。举个🌰：\n__Target Action__\n```\nbutton.addTarget(self, action: #selector(buttonEvent), for: .touchUpInside)\n```\n```\n@objc func buttonEvent(){\n    print(\"button Event\")\n}\n```\n用Rx实现\n```\nbutton.rx.tap.subscribe(onNext: { () in\n    print(\"button event\")\n}, onError: nil, onCompleted: nil, onDispo\nsed: nil)\n```\n这样一来，代码逻辑清晰可见。\n当然了，为了MVVM，还是很有学习RxSwift的必要的。\n#### RxSwift地址与安装\n传送门：[GitHub](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FReactiveX%2FRxSwift)\n这里面啥都有，无需多言。\n#### RxSwift 与 RxCocoa\nRxSwift在日常使用中，需要import\n```\nimport RxCocoa\nimport RxSwift\n```\n这个两个库的作用分别是：\n- RxSwift：它只是基于 Swift 语言的 Rx 标准实现接口库，所以 RxSwift 里不包含任何 Cocoa 或者 UI方面的类。\n- RxCocoa：是基于 RxSwift针对于 iOS开发的一个库，它通过 Extension 的方法给原生的比如 UI 控件添加了 Rx 的特性，使得我们更容易订阅和响应这些控件的事件。\n\n既然已经有了这个RxSwift开篇，希望自己坚持下去。虽然不太喜欢写文章，但这也不失为监督自己的一个方法。__笨鸟先飞，知行合一。__\n最后，感谢那些“巨人”，对于RxSwift的学习，完全是站在巨人的肩膀上，感谢他们的文章，指引了我的方向。尤其感谢[RxSwift中文文档](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/)和[航哥swift](http://www.hangge.com/)，他们的文章，对我的帮助很大，感谢。\n","slug":"RxSwift-开门第一篇","published":1,"updated":"2018-10-19T07:16:01.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0lod0002imcwnn6w5pj0","content":"<h2 id=\"开篇扯淡：\"><a href=\"#开篇扯淡：\" class=\"headerlink\" title=\"开篇扯淡：\"></a>开篇扯淡：</h2><p>&emsp;&emsp;为什么入RxSwift这个坑？因为我作为一个iOSer，主要语言是swift，日常开发已经很少使用OC。随着产品代码量日益增加，准备从MVC转成MVVM，而MVVM最搭配的就是RxSwift。所以，作为我个人来说，入RxSwift这个坑，还是比较合情合理的。</p>\n<h2 id=\"正经内容：\"><a href=\"#正经内容：\" class=\"headerlink\" title=\"正经内容：\"></a>正经内容：</h2><h3 id=\"ReactiveX是什么\"><a href=\"#ReactiveX是什么\" class=\"headerlink\" title=\"ReactiveX是什么\"></a>ReactiveX是什么</h3><p><a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"noopener\">ReactiveX</a>（简写: Rx）是一个可以帮助我们简化异步编程的框架.<br>它拓展了<a href=\"https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">观察者模式</a>。使你能够自由组合多个异步事件，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。</p>\n<h3 id=\"什么是RxSwift\"><a href=\"#什么是RxSwift\" class=\"headerlink\" title=\"什么是RxSwift\"></a>什么是RxSwift</h3><p><a href=\"https://github.com/ReactiveX/RxSwift\" target=\"_blank\" rel=\"noopener\">RxSwift</a> 是 <a href=\"https://github.com/Reactive-Extensions/Rx.NET\" target=\"_blank\" rel=\"noopener\">Rx</a> 的 <strong>Swift</strong> 版本，它尝试将原有的一些概念移植到 iOS/macOS 平台。</p>\n<h3 id=\"为什么要使用RxSwift\"><a href=\"#为什么要使用RxSwift\" class=\"headerlink\" title=\"为什么要使用RxSwift\"></a>为什么要使用RxSwift</h3><blockquote>\n<p>复合 - Rx 就是复合的代名词<br>复用 - 因为它易复合<br>清晰 - 因为声明都是不可变更的<br>易用 - 因为它抽象的了异步编程，使我们统一了代码风格<br>稳定 - 因为 Rx 是完全通过单元测试的  </p>\n</blockquote>\n<p>当然了，上面都是假大空，具体来说<br>在编写代码时我们经常会需要检测某些值的变化，然后进行相应的处理。比如说按钮的点击事件、textFiled值的变化、tableView中cell的点击事件等等。在日常搬砖中，我们针对不同的情况，需要采用不同的事件传递方法去处理，比如<strong>delegate</strong>、<strong>notifinotion</strong>、<strong>target-action</strong>、<strong>KVO</strong>等等。<br>而在RxSwift中，让程序里的事件传递响应方法做到统一，全部采用Rx的“信号链”方式。举个🌰：<br><strong>Target Action</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.addTarget(self, action: #selector(buttonEvent), for: .touchUpInside)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc func buttonEvent()&#123;</span><br><span class=\"line\">    print(&quot;button Event&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用Rx实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.rx.tap.subscribe(onNext: &#123; () in</span><br><span class=\"line\">    print(&quot;button event&quot;)</span><br><span class=\"line\">&#125;, onError: nil, onCompleted: nil, onDispo</span><br><span class=\"line\">sed: nil)</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，代码逻辑清晰可见。<br>当然了，为了MVVM，还是很有学习RxSwift的必要的。</p>\n<h4 id=\"RxSwift地址与安装\"><a href=\"#RxSwift地址与安装\" class=\"headerlink\" title=\"RxSwift地址与安装\"></a>RxSwift地址与安装</h4><p>传送门：<a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FReactiveX%2FRxSwift\" target=\"_blank\" rel=\"noopener\">GitHub</a><br>这里面啥都有，无需多言。</p>\n<h4 id=\"RxSwift-与-RxCocoa\"><a href=\"#RxSwift-与-RxCocoa\" class=\"headerlink\" title=\"RxSwift 与 RxCocoa\"></a>RxSwift 与 RxCocoa</h4><p>RxSwift在日常使用中，需要import<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br></pre></td></tr></table></figure></p>\n<p>这个两个库的作用分别是：</p>\n<ul>\n<li>RxSwift：它只是基于 Swift 语言的 Rx 标准实现接口库，所以 RxSwift 里不包含任何 Cocoa 或者 UI方面的类。</li>\n<li>RxCocoa：是基于 RxSwift针对于 iOS开发的一个库，它通过 Extension 的方法给原生的比如 UI 控件添加了 Rx 的特性，使得我们更容易订阅和响应这些控件的事件。</li>\n</ul>\n<p>既然已经有了这个RxSwift开篇，希望自己坚持下去。虽然不太喜欢写文章，但这也不失为监督自己的一个方法。<strong>笨鸟先飞，知行合一。</strong><br>最后，感谢那些“巨人”，对于RxSwift的学习，完全是站在巨人的肩膀上，感谢他们的文章，指引了我的方向。尤其感谢<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/\" target=\"_blank\" rel=\"noopener\">RxSwift中文文档</a>和<a href=\"http://www.hangge.com/\" target=\"_blank\" rel=\"noopener\">航哥swift</a>，他们的文章，对我的帮助很大，感谢。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"开篇扯淡：\"><a href=\"#开篇扯淡：\" class=\"headerlink\" title=\"开篇扯淡：\"></a>开篇扯淡：</h2><p>&emsp;&emsp;为什么入RxSwift这个坑？因为我作为一个iOSer，主要语言是swift，日常开发已经很少使用OC。随着产品代码量日益增加，准备从MVC转成MVVM，而MVVM最搭配的就是RxSwift。所以，作为我个人来说，入RxSwift这个坑，还是比较合情合理的。</p>\n<h2 id=\"正经内容：\"><a href=\"#正经内容：\" class=\"headerlink\" title=\"正经内容：\"></a>正经内容：</h2><h3 id=\"ReactiveX是什么\"><a href=\"#ReactiveX是什么\" class=\"headerlink\" title=\"ReactiveX是什么\"></a>ReactiveX是什么</h3><p><a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"noopener\">ReactiveX</a>（简写: Rx）是一个可以帮助我们简化异步编程的框架.<br>它拓展了<a href=\"https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">观察者模式</a>。使你能够自由组合多个异步事件，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。</p>\n<h3 id=\"什么是RxSwift\"><a href=\"#什么是RxSwift\" class=\"headerlink\" title=\"什么是RxSwift\"></a>什么是RxSwift</h3><p><a href=\"https://github.com/ReactiveX/RxSwift\" target=\"_blank\" rel=\"noopener\">RxSwift</a> 是 <a href=\"https://github.com/Reactive-Extensions/Rx.NET\" target=\"_blank\" rel=\"noopener\">Rx</a> 的 <strong>Swift</strong> 版本，它尝试将原有的一些概念移植到 iOS/macOS 平台。</p>\n<h3 id=\"为什么要使用RxSwift\"><a href=\"#为什么要使用RxSwift\" class=\"headerlink\" title=\"为什么要使用RxSwift\"></a>为什么要使用RxSwift</h3><blockquote>\n<p>复合 - Rx 就是复合的代名词<br>复用 - 因为它易复合<br>清晰 - 因为声明都是不可变更的<br>易用 - 因为它抽象的了异步编程，使我们统一了代码风格<br>稳定 - 因为 Rx 是完全通过单元测试的  </p>\n</blockquote>\n<p>当然了，上面都是假大空，具体来说<br>在编写代码时我们经常会需要检测某些值的变化，然后进行相应的处理。比如说按钮的点击事件、textFiled值的变化、tableView中cell的点击事件等等。在日常搬砖中，我们针对不同的情况，需要采用不同的事件传递方法去处理，比如<strong>delegate</strong>、<strong>notifinotion</strong>、<strong>target-action</strong>、<strong>KVO</strong>等等。<br>而在RxSwift中，让程序里的事件传递响应方法做到统一，全部采用Rx的“信号链”方式。举个🌰：<br><strong>Target Action</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.addTarget(self, action: #selector(buttonEvent), for: .touchUpInside)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc func buttonEvent()&#123;</span><br><span class=\"line\">    print(&quot;button Event&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用Rx实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.rx.tap.subscribe(onNext: &#123; () in</span><br><span class=\"line\">    print(&quot;button event&quot;)</span><br><span class=\"line\">&#125;, onError: nil, onCompleted: nil, onDispo</span><br><span class=\"line\">sed: nil)</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，代码逻辑清晰可见。<br>当然了，为了MVVM，还是很有学习RxSwift的必要的。</p>\n<h4 id=\"RxSwift地址与安装\"><a href=\"#RxSwift地址与安装\" class=\"headerlink\" title=\"RxSwift地址与安装\"></a>RxSwift地址与安装</h4><p>传送门：<a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FReactiveX%2FRxSwift\" target=\"_blank\" rel=\"noopener\">GitHub</a><br>这里面啥都有，无需多言。</p>\n<h4 id=\"RxSwift-与-RxCocoa\"><a href=\"#RxSwift-与-RxCocoa\" class=\"headerlink\" title=\"RxSwift 与 RxCocoa\"></a>RxSwift 与 RxCocoa</h4><p>RxSwift在日常使用中，需要import<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br></pre></td></tr></table></figure></p>\n<p>这个两个库的作用分别是：</p>\n<ul>\n<li>RxSwift：它只是基于 Swift 语言的 Rx 标准实现接口库，所以 RxSwift 里不包含任何 Cocoa 或者 UI方面的类。</li>\n<li>RxCocoa：是基于 RxSwift针对于 iOS开发的一个库，它通过 Extension 的方法给原生的比如 UI 控件添加了 Rx 的特性，使得我们更容易订阅和响应这些控件的事件。</li>\n</ul>\n<p>既然已经有了这个RxSwift开篇，希望自己坚持下去。虽然不太喜欢写文章，但这也不失为监督自己的一个方法。<strong>笨鸟先飞，知行合一。</strong><br>最后，感谢那些“巨人”，对于RxSwift的学习，完全是站在巨人的肩膀上，感谢他们的文章，指引了我的方向。尤其感谢<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/\" target=\"_blank\" rel=\"noopener\">RxSwift中文文档</a>和<a href=\"http://www.hangge.com/\" target=\"_blank\" rel=\"noopener\">航哥swift</a>，他们的文章，对我的帮助很大，感谢。</p>\n"},{"title":"RxSwift 条件和布尔操作符(Conditional and Boolean Operators)","date":"2018-09-27T13:31:24.000Z","_content":"条件和布尔操作会根据条件发射或变换`Observables`，或者对他们做布尔运算。\n#### 1.amb\n当你传入多个`Observables`到`amb`操作符时，它将取其中一个`Observable`：第一个产生事件的那个`Observable`，可以是一个`next`，`error`或者`completed`事件。`amb`将忽略掉其他的`Observables`。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-84522567d0c59097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<Int>()\nlet subject2 = PublishSubject<Int>()\nlet subject3 = PublishSubject<Int>()\n\nsubject1.amb(subject2)\n        .amb(subject3)\n        .subscribe{ print($0.element!) }\n        .disposed(by: disposeBag)\n\nsubject2.onNext(1)\nsubject1.onNext(20)\nsubject2.onNext(2)\nsubject1.onNext(40)\nsubject3.onNext(0)\nsubject2.onNext(3)\nsubject1.onNext(60)\nsubject3.onNext(0)\nsubject3.onNext(0)\n```\n运行结果：\n```\n1\n2\n3\n```\n#### 2. takeWhile\n该方法依次判断`Observable`序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-df28e3c3f9466030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 2, 3, 4, 3, 2, 1)\n        .takeWhile { $0 < 4 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果：\n```\n1\n2\n3\n```\n#### 3. takeUntil\n`takeUntil`操作符将镜像源`Observable`，它同时观测第二个`Observable`。一旦第二个`Observable`发出一个元素或者产生一个终止事件，那个镜像的`Observable`将立即终止。\n\n![takeUntil.png](https://upload-images.jianshu.io/upload_images/2855070-0445e18465f29f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<String>()\nlet subject2 = PublishSubject<String>()\n\nsubject1.takeUntil(subject2)\n        .subscribe { print($0) }\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"A\")\nsubject1.onNext(\"B\")\nsubject2.onNext(\"我可以让它中止\")\nsubject1.onNext(\"C\")\n```\n结果如下：\n```\nnext(A)\nnext(B)\ncompleted\n```\n#### 4. skipUntil\n- 同上面的`takeUntil`一样，`skipUntil`除了订阅源`Observable`外，通过`skipUntil`方法我们还可以监视另外一个`Observable`， 即`notifier` 。\n- 与`takeUntil`相反的是。源`Observable`序列事件默认会一直跳过，直到`notifier`发出值或 complete 通知\n\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-5063471ccc8c9bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject = PublishSubject<String>()\nlet notifier = PublishSubject<String>()\n\nsubject.skipUntil(notifier)\n        .subscribe (onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nnotifier.onNext(\"接收消息\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\nsubject.onNext(\"E\")\nnotifier.onNext(\"接收消息\")\nsubject.onNext(\"F\")\n```\n结果如下：\n```\nC\nD\nE\nF\n```\n#### 5. skipWhile\n`skipWhile`操作符可以让你忽略源`Observable`中头几个元素，直到元素的判定为否。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-cf1e93804e5b79e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 3, 6, 4, 7, 2)\n        .skipWhile{ $0 < 5 }\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n6\n4\n7\n2\n```\n","source":"_posts/RxSwift-条件和布尔操作符-Conditional-and-Boolean-Operators.md","raw":"---\ntitle: RxSwift 条件和布尔操作符(Conditional and Boolean Operators)\ndate: 2018-09-27 21:31:24\ntags: RxSwift\n---\n条件和布尔操作会根据条件发射或变换`Observables`，或者对他们做布尔运算。\n#### 1.amb\n当你传入多个`Observables`到`amb`操作符时，它将取其中一个`Observable`：第一个产生事件的那个`Observable`，可以是一个`next`，`error`或者`completed`事件。`amb`将忽略掉其他的`Observables`。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-84522567d0c59097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<Int>()\nlet subject2 = PublishSubject<Int>()\nlet subject3 = PublishSubject<Int>()\n\nsubject1.amb(subject2)\n        .amb(subject3)\n        .subscribe{ print($0.element!) }\n        .disposed(by: disposeBag)\n\nsubject2.onNext(1)\nsubject1.onNext(20)\nsubject2.onNext(2)\nsubject1.onNext(40)\nsubject3.onNext(0)\nsubject2.onNext(3)\nsubject1.onNext(60)\nsubject3.onNext(0)\nsubject3.onNext(0)\n```\n运行结果：\n```\n1\n2\n3\n```\n#### 2. takeWhile\n该方法依次判断`Observable`序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-df28e3c3f9466030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 2, 3, 4, 3, 2, 1)\n        .takeWhile { $0 < 4 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果：\n```\n1\n2\n3\n```\n#### 3. takeUntil\n`takeUntil`操作符将镜像源`Observable`，它同时观测第二个`Observable`。一旦第二个`Observable`发出一个元素或者产生一个终止事件，那个镜像的`Observable`将立即终止。\n\n![takeUntil.png](https://upload-images.jianshu.io/upload_images/2855070-0445e18465f29f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<String>()\nlet subject2 = PublishSubject<String>()\n\nsubject1.takeUntil(subject2)\n        .subscribe { print($0) }\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"A\")\nsubject1.onNext(\"B\")\nsubject2.onNext(\"我可以让它中止\")\nsubject1.onNext(\"C\")\n```\n结果如下：\n```\nnext(A)\nnext(B)\ncompleted\n```\n#### 4. skipUntil\n- 同上面的`takeUntil`一样，`skipUntil`除了订阅源`Observable`外，通过`skipUntil`方法我们还可以监视另外一个`Observable`， 即`notifier` 。\n- 与`takeUntil`相反的是。源`Observable`序列事件默认会一直跳过，直到`notifier`发出值或 complete 通知\n\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-5063471ccc8c9bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject = PublishSubject<String>()\nlet notifier = PublishSubject<String>()\n\nsubject.skipUntil(notifier)\n        .subscribe (onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nnotifier.onNext(\"接收消息\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\nsubject.onNext(\"E\")\nnotifier.onNext(\"接收消息\")\nsubject.onNext(\"F\")\n```\n结果如下：\n```\nC\nD\nE\nF\n```\n#### 5. skipWhile\n`skipWhile`操作符可以让你忽略源`Observable`中头几个元素，直到元素的判定为否。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-cf1e93804e5b79e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 3, 6, 4, 7, 2)\n        .skipWhile{ $0 < 5 }\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n6\n4\n7\n2\n```\n","slug":"RxSwift-条件和布尔操作符-Conditional-and-Boolean-Operators","published":1,"updated":"2018-10-19T07:16:01.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0loh0004imcwz9xc4l16","content":"<p>条件和布尔操作会根据条件发射或变换<code>Observables</code>，或者对他们做布尔运算。</p>\n<h4 id=\"1-amb\"><a href=\"#1-amb\" class=\"headerlink\" title=\"1.amb\"></a>1.amb</h4><p>当你传入多个<code>Observables</code>到<code>amb</code>操作符时，它将取其中一个<code>Observable</code>：第一个产生事件的那个<code>Observable</code>，可以是一个<code>next</code>，<code>error</code>或者<code>completed</code>事件。<code>amb</code>将忽略掉其他的<code>Observables</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-84522567d0c59097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject3 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.amb(subject2)</span><br><span class=\"line\">        .amb(subject3)</span><br><span class=\"line\">        .subscribe&#123; print($0.element!) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject2.onNext(1)</span><br><span class=\"line\">subject1.onNext(20)</span><br><span class=\"line\">subject2.onNext(2)</span><br><span class=\"line\">subject1.onNext(40)</span><br><span class=\"line\">subject3.onNext(0)</span><br><span class=\"line\">subject2.onNext(3)</span><br><span class=\"line\">subject1.onNext(60)</span><br><span class=\"line\">subject3.onNext(0)</span><br><span class=\"line\">subject3.onNext(0)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-takeWhile\"><a href=\"#2-takeWhile\" class=\"headerlink\" title=\"2. takeWhile\"></a>2. takeWhile</h4><p>该方法依次判断<code>Observable</code>序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-df28e3c3f9466030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 3, 2, 1)</span><br><span class=\"line\">        .takeWhile &#123; $0 &lt; 4 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-takeUntil\"><a href=\"#3-takeUntil\" class=\"headerlink\" title=\"3. takeUntil\"></a>3. takeUntil</h4><p><code>takeUntil</code>操作符将镜像源<code>Observable</code>，它同时观测第二个<code>Observable</code>。一旦第二个<code>Observable</code>发出一个元素或者产生一个终止事件，那个镜像的<code>Observable</code>将立即终止。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-0445e18465f29f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"takeUntil.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.takeUntil(subject2)</span><br><span class=\"line\">        .subscribe &#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;我可以让它中止&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(A)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-skipUntil\"><a href=\"#4-skipUntil\" class=\"headerlink\" title=\"4. skipUntil\"></a>4. skipUntil</h4><ul>\n<li>同上面的<code>takeUntil</code>一样，<code>skipUntil</code>除了订阅源<code>Observable</code>外，通过<code>skipUntil</code>方法我们还可以监视另外一个<code>Observable</code>， 即<code>notifier</code> 。</li>\n<li>与<code>takeUntil</code>相反的是。源<code>Observable</code>序列事件默认会一直跳过，直到<code>notifier</code>发出值或 complete 通知</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-5063471ccc8c9bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let notifier = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.skipUntil(notifier)</span><br><span class=\"line\">        .subscribe (onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;接收消息&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">subject.onNext(&quot;E&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;接收消息&quot;)</span><br><span class=\"line\">subject.onNext(&quot;F&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">E</span><br><span class=\"line\">F</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-skipWhile\"><a href=\"#5-skipWhile\" class=\"headerlink\" title=\"5. skipWhile\"></a>5. skipWhile</h4><p><code>skipWhile</code>操作符可以让你忽略源<code>Observable</code>中头几个元素，直到元素的判定为否。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-cf1e93804e5b79e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(1, 3, 6, 4, 7, 2)</span><br><span class=\"line\">        .skipWhile&#123; $0 &lt; 5 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">4</span><br><span class=\"line\">7</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>条件和布尔操作会根据条件发射或变换<code>Observables</code>，或者对他们做布尔运算。</p>\n<h4 id=\"1-amb\"><a href=\"#1-amb\" class=\"headerlink\" title=\"1.amb\"></a>1.amb</h4><p>当你传入多个<code>Observables</code>到<code>amb</code>操作符时，它将取其中一个<code>Observable</code>：第一个产生事件的那个<code>Observable</code>，可以是一个<code>next</code>，<code>error</code>或者<code>completed</code>事件。<code>amb</code>将忽略掉其他的<code>Observables</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-84522567d0c59097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject3 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.amb(subject2)</span><br><span class=\"line\">        .amb(subject3)</span><br><span class=\"line\">        .subscribe&#123; print($0.element!) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject2.onNext(1)</span><br><span class=\"line\">subject1.onNext(20)</span><br><span class=\"line\">subject2.onNext(2)</span><br><span class=\"line\">subject1.onNext(40)</span><br><span class=\"line\">subject3.onNext(0)</span><br><span class=\"line\">subject2.onNext(3)</span><br><span class=\"line\">subject1.onNext(60)</span><br><span class=\"line\">subject3.onNext(0)</span><br><span class=\"line\">subject3.onNext(0)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-takeWhile\"><a href=\"#2-takeWhile\" class=\"headerlink\" title=\"2. takeWhile\"></a>2. takeWhile</h4><p>该方法依次判断<code>Observable</code>序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-df28e3c3f9466030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 3, 2, 1)</span><br><span class=\"line\">        .takeWhile &#123; $0 &lt; 4 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-takeUntil\"><a href=\"#3-takeUntil\" class=\"headerlink\" title=\"3. takeUntil\"></a>3. takeUntil</h4><p><code>takeUntil</code>操作符将镜像源<code>Observable</code>，它同时观测第二个<code>Observable</code>。一旦第二个<code>Observable</code>发出一个元素或者产生一个终止事件，那个镜像的<code>Observable</code>将立即终止。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-0445e18465f29f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"takeUntil.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.takeUntil(subject2)</span><br><span class=\"line\">        .subscribe &#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;我可以让它中止&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(A)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-skipUntil\"><a href=\"#4-skipUntil\" class=\"headerlink\" title=\"4. skipUntil\"></a>4. skipUntil</h4><ul>\n<li>同上面的<code>takeUntil</code>一样，<code>skipUntil</code>除了订阅源<code>Observable</code>外，通过<code>skipUntil</code>方法我们还可以监视另外一个<code>Observable</code>， 即<code>notifier</code> 。</li>\n<li>与<code>takeUntil</code>相反的是。源<code>Observable</code>序列事件默认会一直跳过，直到<code>notifier</code>发出值或 complete 通知</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-5063471ccc8c9bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let notifier = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.skipUntil(notifier)</span><br><span class=\"line\">        .subscribe (onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;接收消息&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">subject.onNext(&quot;E&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;接收消息&quot;)</span><br><span class=\"line\">subject.onNext(&quot;F&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">E</span><br><span class=\"line\">F</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-skipWhile\"><a href=\"#5-skipWhile\" class=\"headerlink\" title=\"5. skipWhile\"></a>5. skipWhile</h4><p><code>skipWhile</code>操作符可以让你忽略源<code>Observable</code>中头几个元素，直到元素的判定为否。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-cf1e93804e5b79e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(1, 3, 6, 4, 7, 2)</span><br><span class=\"line\">        .skipWhile&#123; $0 &lt; 5 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">4</span><br><span class=\"line\">7</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n"},{"title":"RxSwift 核心","date":"2018-09-19T12:49:45.000Z","_content":"在这篇中，简单介绍一下RxSwift的核心内容，首先献祭上一张图：\n![RxSwiftCore.png](https://upload-images.jianshu.io/upload_images/2855070-90edfb06fc5c1b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- Observable:产生事件\n- Observer: 响应事件\n- Operator:创建变化组合事件\n- Disposable:管理绑定（订阅）的生命周期\n- Schedulers:线程队列调配\n## Observable 可被监听的序列\nObservable实质上就是一个Sequence。序列分为有穷序列和无穷序列，主要就是用来形成一条数据流。比如说：我们通过nickname和password向服务器请求用户信息，它就是一个有穷数列，当数据传输完毕，这个序列就闭合了。当我们去监测某个按钮的点击，我们不知道会点击多少次，这就是无穷序列。而我们所有的操作产生的数据都会通过Observable传输。\nObservable<T> 这个类就是Rx 框架的基础，我们称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable<T> 对象会随着时间推移不定期地发出 event(element : T) 。\n举个🌰：\n```\nlet observable = Observable.of(\"A\", \"B\", \"C\")\nobservable.subscribe(onNext: { element in\nprint(element)\n}, onError: { error in\nprint(error)\n}, onCompleted: {\nprint(\"completed\")\n}, onDisposed: {\nprint(\"disposed\")\n})\n```\n这里subscribe后面的onNext,onError, onCompleted 分别响应我们创建 json 时，构建函数里面的onNext,onError, onCompleted 事件。我们称这些事件为 Event。\nEvent的定义如下：\n```\npublic enum Event<Element> {\n/// Next element is produced.\ncase next(Element)\n/// Sequence terminated with an error.\ncase error(Swift.Error)\n/// Sequence completed successfully.\ncase completed\n}\n```\n可以看出Event就是一个枚举，也就是说一个 Observable 是可以发出 3 种不同类型的 Event 事件。\n- next:序列产生了一个新的元素\n- error:创建序列时产生了一个错误，导致序列终止\n- completed:序列的所有元素都已经成功产生，整个序列已经完成\n我们通过这些Event实现业务逻辑。\n##  Observer 观察者\n观察者（Observer）的作用就是监听事件，然后对这个事件做出响应，或者说任何响应事件的行为都是观察者。比如：\n- 当前视频播放到30分钟时，弹出视频小剧场(广告)，后者就是观察者。\n- 当前温度高于30度，打开空调降温，后者就是观察者。\n- 当你点击视频拍摄时，系统弹出弹框问你是否同意使用摄像头，后者就是观察者。\n- ······\n举个🌰：\n```\ntap.subscribe(onNext: { [weak self] in\nself?.showAlert()\n}, onError: { error in\nprint(\"发生错误： \\(error.localizedDescription)\")\n}, onCompleted: {\nprint(\"任务完成\")\n})\n```\n在这里，弹出提示框就是观察者。\n创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述，事件发生时，需要如何做出响应。而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的。此外，我们还有AnyObserver、Binder方式创建观察者。\n## Operator  操作符\n操作符可以帮助大家创建新的序列，或者变化组合原有的序列，从而生成一个新的序列。可以对比一下Swift中的高阶函数。具体使用方法暂不做介绍，只举个🌰：\n```\nlet obserable = Observable<Int>.of(1,2,3,4,5,6,7,8,9,10)\nobserable.filter{ $0 > 5}\n.subscribe(onNext: { print($0) })\n//6 7 8 9 10\n```\n\n## Disposable  可被清除的资源\n一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。激活之后要一直等到它发出了.error或者 .completed的 event 后，它才被终结。而如果我们想提前释放这些资源或者取消订阅的话，可以对返回的可被清除的资源（Disposable） 调用 dispose 方法：\n```\nvar disposable: Disposable?\n\noverride func viewWillAppear(_ animated: Bool) {\nsuper.viewWillAppear(animated)\n\nself.disposable = textField.rx.text.orEmpty\n.subscribe(onNext: { text in print(text) })\n}\n\noverride func viewWillDisappear(_ animated: Bool) {\nsuper.viewWillDisappear(animated)\n\nself.disposable?.dispose()\n}\n```\n当然了，这个方法并不建议。因为Swift是使用ARC管理内存，所有推荐使用清除包（DisposeBag） 来实现这种订阅管理机制。我们可以把一个 DisposeBag对象看成一个垃圾袋，把用过的订阅行为都放进去，这个DisposeBag 就会在自己快要dealloc 的时候，对它里面的所有订阅行为都调用 dispose()方法\n```\nlet disposeBag = DisposeBag()\n\n//第1个Observable，及其订阅\nlet observable1 = Observable.of(\"A\", \"B\", \"C\")\nobservable1.subscribe { event in\nprint(event)\n}.disposed(by: disposeBag)\n\n//第2个Observable，及其订阅\nlet observable2 = Observable.of(1, 2, 3)\nobservable2.subscribe { event in\nprint(event)\n}.disposed(by: disposeBag)\n\n```\n此外，还有一种takeUntil，这里就不做过多描述了。\n## Schedulers 调度器\nSchedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。\n在Swift中，我们写一个GCD这么写：\n```\n// 后台取得数据，主线程处理结果\nDispatchQueue.global(qos: .userInitiated).async {\nlet data = try? Data(contentsOf: url)\nDispatchQueue.main.async {\nself.data = data\n}\n}\n```\n如果用RxSwift去实现，就这么写:\n```\nlet rxData: Observable<Data> = ...\n\nrxData\n.subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))\n.observeOn(MainScheduler.instance)\n.subscribe(onNext: { [weak self] data in\nself?.data = data\n})\n.disposed(by: disposeBag)\n```\n在这里，我们用subscribeOn来决定数据序列的构建函数在哪个 Scheduler 上运行，用observeOn来决定在哪个 Scheduler 监听这个数据序列。比如说：在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn切到后台去发送请求并解析数据，最后用 observeOn切换到主线程更新页面。此外，我们来应该了解：\n- MainScheduler：代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。\n- SerialDispatchQueueScheduler：抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。\n- ConcurrentDispatchQueueScheduler：抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。\n- OperationQueueScheduler：抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。\n\n","source":"_posts/RxSwift-核心.md","raw":"---\ntitle: RxSwift 核心\ndate: 2018-09-19 20:49:45\ntags: RxSwift\n---\n在这篇中，简单介绍一下RxSwift的核心内容，首先献祭上一张图：\n![RxSwiftCore.png](https://upload-images.jianshu.io/upload_images/2855070-90edfb06fc5c1b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- Observable:产生事件\n- Observer: 响应事件\n- Operator:创建变化组合事件\n- Disposable:管理绑定（订阅）的生命周期\n- Schedulers:线程队列调配\n## Observable 可被监听的序列\nObservable实质上就是一个Sequence。序列分为有穷序列和无穷序列，主要就是用来形成一条数据流。比如说：我们通过nickname和password向服务器请求用户信息，它就是一个有穷数列，当数据传输完毕，这个序列就闭合了。当我们去监测某个按钮的点击，我们不知道会点击多少次，这就是无穷序列。而我们所有的操作产生的数据都会通过Observable传输。\nObservable<T> 这个类就是Rx 框架的基础，我们称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable<T> 对象会随着时间推移不定期地发出 event(element : T) 。\n举个🌰：\n```\nlet observable = Observable.of(\"A\", \"B\", \"C\")\nobservable.subscribe(onNext: { element in\nprint(element)\n}, onError: { error in\nprint(error)\n}, onCompleted: {\nprint(\"completed\")\n}, onDisposed: {\nprint(\"disposed\")\n})\n```\n这里subscribe后面的onNext,onError, onCompleted 分别响应我们创建 json 时，构建函数里面的onNext,onError, onCompleted 事件。我们称这些事件为 Event。\nEvent的定义如下：\n```\npublic enum Event<Element> {\n/// Next element is produced.\ncase next(Element)\n/// Sequence terminated with an error.\ncase error(Swift.Error)\n/// Sequence completed successfully.\ncase completed\n}\n```\n可以看出Event就是一个枚举，也就是说一个 Observable 是可以发出 3 种不同类型的 Event 事件。\n- next:序列产生了一个新的元素\n- error:创建序列时产生了一个错误，导致序列终止\n- completed:序列的所有元素都已经成功产生，整个序列已经完成\n我们通过这些Event实现业务逻辑。\n##  Observer 观察者\n观察者（Observer）的作用就是监听事件，然后对这个事件做出响应，或者说任何响应事件的行为都是观察者。比如：\n- 当前视频播放到30分钟时，弹出视频小剧场(广告)，后者就是观察者。\n- 当前温度高于30度，打开空调降温，后者就是观察者。\n- 当你点击视频拍摄时，系统弹出弹框问你是否同意使用摄像头，后者就是观察者。\n- ······\n举个🌰：\n```\ntap.subscribe(onNext: { [weak self] in\nself?.showAlert()\n}, onError: { error in\nprint(\"发生错误： \\(error.localizedDescription)\")\n}, onCompleted: {\nprint(\"任务完成\")\n})\n```\n在这里，弹出提示框就是观察者。\n创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述，事件发生时，需要如何做出响应。而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的。此外，我们还有AnyObserver、Binder方式创建观察者。\n## Operator  操作符\n操作符可以帮助大家创建新的序列，或者变化组合原有的序列，从而生成一个新的序列。可以对比一下Swift中的高阶函数。具体使用方法暂不做介绍，只举个🌰：\n```\nlet obserable = Observable<Int>.of(1,2,3,4,5,6,7,8,9,10)\nobserable.filter{ $0 > 5}\n.subscribe(onNext: { print($0) })\n//6 7 8 9 10\n```\n\n## Disposable  可被清除的资源\n一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。激活之后要一直等到它发出了.error或者 .completed的 event 后，它才被终结。而如果我们想提前释放这些资源或者取消订阅的话，可以对返回的可被清除的资源（Disposable） 调用 dispose 方法：\n```\nvar disposable: Disposable?\n\noverride func viewWillAppear(_ animated: Bool) {\nsuper.viewWillAppear(animated)\n\nself.disposable = textField.rx.text.orEmpty\n.subscribe(onNext: { text in print(text) })\n}\n\noverride func viewWillDisappear(_ animated: Bool) {\nsuper.viewWillDisappear(animated)\n\nself.disposable?.dispose()\n}\n```\n当然了，这个方法并不建议。因为Swift是使用ARC管理内存，所有推荐使用清除包（DisposeBag） 来实现这种订阅管理机制。我们可以把一个 DisposeBag对象看成一个垃圾袋，把用过的订阅行为都放进去，这个DisposeBag 就会在自己快要dealloc 的时候，对它里面的所有订阅行为都调用 dispose()方法\n```\nlet disposeBag = DisposeBag()\n\n//第1个Observable，及其订阅\nlet observable1 = Observable.of(\"A\", \"B\", \"C\")\nobservable1.subscribe { event in\nprint(event)\n}.disposed(by: disposeBag)\n\n//第2个Observable，及其订阅\nlet observable2 = Observable.of(1, 2, 3)\nobservable2.subscribe { event in\nprint(event)\n}.disposed(by: disposeBag)\n\n```\n此外，还有一种takeUntil，这里就不做过多描述了。\n## Schedulers 调度器\nSchedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。\n在Swift中，我们写一个GCD这么写：\n```\n// 后台取得数据，主线程处理结果\nDispatchQueue.global(qos: .userInitiated).async {\nlet data = try? Data(contentsOf: url)\nDispatchQueue.main.async {\nself.data = data\n}\n}\n```\n如果用RxSwift去实现，就这么写:\n```\nlet rxData: Observable<Data> = ...\n\nrxData\n.subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))\n.observeOn(MainScheduler.instance)\n.subscribe(onNext: { [weak self] data in\nself?.data = data\n})\n.disposed(by: disposeBag)\n```\n在这里，我们用subscribeOn来决定数据序列的构建函数在哪个 Scheduler 上运行，用observeOn来决定在哪个 Scheduler 监听这个数据序列。比如说：在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn切到后台去发送请求并解析数据，最后用 observeOn切换到主线程更新页面。此外，我们来应该了解：\n- MainScheduler：代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。\n- SerialDispatchQueueScheduler：抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。\n- ConcurrentDispatchQueueScheduler：抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。\n- OperationQueueScheduler：抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。\n\n","slug":"RxSwift-核心","published":1,"updated":"2018-10-19T07:16:01.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0loj0005imcwp650b507","content":"<p>在这篇中，简单介绍一下RxSwift的核心内容，首先献祭上一张图：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-90edfb06fc5c1b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RxSwiftCore.png\"></p>\n<ul>\n<li>Observable:产生事件</li>\n<li>Observer: 响应事件</li>\n<li>Operator:创建变化组合事件</li>\n<li>Disposable:管理绑定（订阅）的生命周期</li>\n<li>Schedulers:线程队列调配<h2 id=\"Observable-可被监听的序列\"><a href=\"#Observable-可被监听的序列\" class=\"headerlink\" title=\"Observable 可被监听的序列\"></a>Observable 可被监听的序列</h2>Observable实质上就是一个Sequence。序列分为有穷序列和无穷序列，主要就是用来形成一条数据流。比如说：我们通过nickname和password向服务器请求用户信息，它就是一个有穷数列，当数据传输完毕，这个序列就闭合了。当我们去监测某个按钮的点击，我们不知道会点击多少次，这就是无穷序列。而我们所有的操作产生的数据都会通过Observable传输。<br>Observable<t> 这个类就是Rx 框架的基础，我们称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable<t> 对象会随着时间推移不定期地发出 event(element : T) 。<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class=\"line\">observable.subscribe(onNext: &#123; element in</span><br><span class=\"line\">print(element)</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">print(error)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;, onDisposed: &#123;</span><br><span class=\"line\">print(&quot;disposed&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</t></t></li>\n</ul>\n<p>这里subscribe后面的onNext,onError, onCompleted 分别响应我们创建 json 时，构建函数里面的onNext,onError, onCompleted 事件。我们称这些事件为 Event。<br>Event的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Event&lt;Element&gt; &#123;</span><br><span class=\"line\">/// Next element is produced.</span><br><span class=\"line\">case next(Element)</span><br><span class=\"line\">/// Sequence terminated with an error.</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">/// Sequence completed successfully.</span><br><span class=\"line\">case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出Event就是一个枚举，也就是说一个 Observable 是可以发出 3 种不同类型的 Event 事件。</p>\n<ul>\n<li>next:序列产生了一个新的元素</li>\n<li>error:创建序列时产生了一个错误，导致序列终止</li>\n<li>completed:序列的所有元素都已经成功产生，整个序列已经完成<br>我们通过这些Event实现业务逻辑。<h2 id=\"Observer-观察者\"><a href=\"#Observer-观察者\" class=\"headerlink\" title=\"Observer 观察者\"></a>Observer 观察者</h2>观察者（Observer）的作用就是监听事件，然后对这个事件做出响应，或者说任何响应事件的行为都是观察者。比如：</li>\n<li>当前视频播放到30分钟时，弹出视频小剧场(广告)，后者就是观察者。</li>\n<li>当前温度高于30度，打开空调降温，后者就是观察者。</li>\n<li>当你点击视频拍摄时，系统弹出弹框问你是否同意使用摄像头，后者就是观察者。</li>\n<li>······<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tap.subscribe(onNext: &#123; [weak self] in</span><br><span class=\"line\">self?.showAlert()</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">print(&quot;发生错误： \\(error.localizedDescription)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">print(&quot;任务完成&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在这里，弹出提示框就是观察者。<br>创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述，事件发生时，需要如何做出响应。而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的。此外，我们还有AnyObserver、Binder方式创建观察者。</p>\n<h2 id=\"Operator-操作符\"><a href=\"#Operator-操作符\" class=\"headerlink\" title=\"Operator  操作符\"></a>Operator  操作符</h2><p>操作符可以帮助大家创建新的序列，或者变化组合原有的序列，从而生成一个新的序列。可以对比一下Swift中的高阶函数。具体使用方法暂不做介绍，只举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obserable = Observable&lt;Int&gt;.of(1,2,3,4,5,6,7,8,9,10)</span><br><span class=\"line\">obserable.filter&#123; $0 &gt; 5&#125;</span><br><span class=\"line\">.subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">//6 7 8 9 10</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Disposable-可被清除的资源\"><a href=\"#Disposable-可被清除的资源\" class=\"headerlink\" title=\"Disposable  可被清除的资源\"></a>Disposable  可被清除的资源</h2><p>一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。激活之后要一直等到它发出了.error或者 .completed的 event 后，它才被终结。而如果我们想提前释放这些资源或者取消订阅的话，可以对返回的可被清除的资源（Disposable） 调用 dispose 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var disposable: Disposable?</span><br><span class=\"line\"></span><br><span class=\"line\">override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class=\"line\">super.viewWillAppear(animated)</span><br><span class=\"line\"></span><br><span class=\"line\">self.disposable = textField.rx.text.orEmpty</span><br><span class=\"line\">.subscribe(onNext: &#123; text in print(text) &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">override func viewWillDisappear(_ animated: Bool) &#123;</span><br><span class=\"line\">super.viewWillDisappear(animated)</span><br><span class=\"line\"></span><br><span class=\"line\">self.disposable?.dispose()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然了，这个方法并不建议。因为Swift是使用ARC管理内存，所有推荐使用清除包（DisposeBag） 来实现这种订阅管理机制。我们可以把一个 DisposeBag对象看成一个垃圾袋，把用过的订阅行为都放进去，这个DisposeBag 就会在自己快要dealloc 的时候，对它里面的所有订阅行为都调用 dispose()方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">//第1个Observable，及其订阅</span><br><span class=\"line\">let observable1 = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class=\"line\">observable1.subscribe &#123; event in</span><br><span class=\"line\">print(event)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">//第2个Observable，及其订阅</span><br><span class=\"line\">let observable2 = Observable.of(1, 2, 3)</span><br><span class=\"line\">observable2.subscribe &#123; event in</span><br><span class=\"line\">print(event)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>此外，还有一种takeUntil，这里就不做过多描述了。</p>\n<h2 id=\"Schedulers-调度器\"><a href=\"#Schedulers-调度器\" class=\"headerlink\" title=\"Schedulers 调度器\"></a>Schedulers 调度器</h2><p>Schedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。<br>在Swift中，我们写一个GCD这么写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 后台取得数据，主线程处理结果</span><br><span class=\"line\">DispatchQueue.global(qos: .userInitiated).async &#123;</span><br><span class=\"line\">let data = try? Data(contentsOf: url)</span><br><span class=\"line\">DispatchQueue.main.async &#123;</span><br><span class=\"line\">self.data = data</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用RxSwift去实现，就这么写:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let rxData: Observable&lt;Data&gt; = ...</span><br><span class=\"line\"></span><br><span class=\"line\">rxData</span><br><span class=\"line\">.subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))</span><br><span class=\"line\">.observeOn(MainScheduler.instance)</span><br><span class=\"line\">.subscribe(onNext: &#123; [weak self] data in</span><br><span class=\"line\">self?.data = data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>在这里，我们用subscribeOn来决定数据序列的构建函数在哪个 Scheduler 上运行，用observeOn来决定在哪个 Scheduler 监听这个数据序列。比如说：在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn切到后台去发送请求并解析数据，最后用 observeOn切换到主线程更新页面。此外，我们来应该了解：</p>\n<ul>\n<li>MainScheduler：代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。</li>\n<li>SerialDispatchQueueScheduler：抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。</li>\n<li>ConcurrentDispatchQueueScheduler：抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。</li>\n<li>OperationQueueScheduler：抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在这篇中，简单介绍一下RxSwift的核心内容，首先献祭上一张图：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-90edfb06fc5c1b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RxSwiftCore.png\"></p>\n<ul>\n<li>Observable:产生事件</li>\n<li>Observer: 响应事件</li>\n<li>Operator:创建变化组合事件</li>\n<li>Disposable:管理绑定（订阅）的生命周期</li>\n<li>Schedulers:线程队列调配<h2 id=\"Observable-可被监听的序列\"><a href=\"#Observable-可被监听的序列\" class=\"headerlink\" title=\"Observable 可被监听的序列\"></a>Observable 可被监听的序列</h2>Observable实质上就是一个Sequence。序列分为有穷序列和无穷序列，主要就是用来形成一条数据流。比如说：我们通过nickname和password向服务器请求用户信息，它就是一个有穷数列，当数据传输完毕，这个序列就闭合了。当我们去监测某个按钮的点击，我们不知道会点击多少次，这就是无穷序列。而我们所有的操作产生的数据都会通过Observable传输。<br>Observable<t> 这个类就是Rx 框架的基础，我们称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable<t> 对象会随着时间推移不定期地发出 event(element : T) 。<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class=\"line\">observable.subscribe(onNext: &#123; element in</span><br><span class=\"line\">print(element)</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">print(error)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;, onDisposed: &#123;</span><br><span class=\"line\">print(&quot;disposed&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</t></t></li>\n</ul>\n<p>这里subscribe后面的onNext,onError, onCompleted 分别响应我们创建 json 时，构建函数里面的onNext,onError, onCompleted 事件。我们称这些事件为 Event。<br>Event的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Event&lt;Element&gt; &#123;</span><br><span class=\"line\">/// Next element is produced.</span><br><span class=\"line\">case next(Element)</span><br><span class=\"line\">/// Sequence terminated with an error.</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">/// Sequence completed successfully.</span><br><span class=\"line\">case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出Event就是一个枚举，也就是说一个 Observable 是可以发出 3 种不同类型的 Event 事件。</p>\n<ul>\n<li>next:序列产生了一个新的元素</li>\n<li>error:创建序列时产生了一个错误，导致序列终止</li>\n<li>completed:序列的所有元素都已经成功产生，整个序列已经完成<br>我们通过这些Event实现业务逻辑。<h2 id=\"Observer-观察者\"><a href=\"#Observer-观察者\" class=\"headerlink\" title=\"Observer 观察者\"></a>Observer 观察者</h2>观察者（Observer）的作用就是监听事件，然后对这个事件做出响应，或者说任何响应事件的行为都是观察者。比如：</li>\n<li>当前视频播放到30分钟时，弹出视频小剧场(广告)，后者就是观察者。</li>\n<li>当前温度高于30度，打开空调降温，后者就是观察者。</li>\n<li>当你点击视频拍摄时，系统弹出弹框问你是否同意使用摄像头，后者就是观察者。</li>\n<li>······<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tap.subscribe(onNext: &#123; [weak self] in</span><br><span class=\"line\">self?.showAlert()</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">print(&quot;发生错误： \\(error.localizedDescription)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">print(&quot;任务完成&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在这里，弹出提示框就是观察者。<br>创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述，事件发生时，需要如何做出响应。而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的。此外，我们还有AnyObserver、Binder方式创建观察者。</p>\n<h2 id=\"Operator-操作符\"><a href=\"#Operator-操作符\" class=\"headerlink\" title=\"Operator  操作符\"></a>Operator  操作符</h2><p>操作符可以帮助大家创建新的序列，或者变化组合原有的序列，从而生成一个新的序列。可以对比一下Swift中的高阶函数。具体使用方法暂不做介绍，只举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obserable = Observable&lt;Int&gt;.of(1,2,3,4,5,6,7,8,9,10)</span><br><span class=\"line\">obserable.filter&#123; $0 &gt; 5&#125;</span><br><span class=\"line\">.subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">//6 7 8 9 10</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Disposable-可被清除的资源\"><a href=\"#Disposable-可被清除的资源\" class=\"headerlink\" title=\"Disposable  可被清除的资源\"></a>Disposable  可被清除的资源</h2><p>一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。激活之后要一直等到它发出了.error或者 .completed的 event 后，它才被终结。而如果我们想提前释放这些资源或者取消订阅的话，可以对返回的可被清除的资源（Disposable） 调用 dispose 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var disposable: Disposable?</span><br><span class=\"line\"></span><br><span class=\"line\">override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class=\"line\">super.viewWillAppear(animated)</span><br><span class=\"line\"></span><br><span class=\"line\">self.disposable = textField.rx.text.orEmpty</span><br><span class=\"line\">.subscribe(onNext: &#123; text in print(text) &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">override func viewWillDisappear(_ animated: Bool) &#123;</span><br><span class=\"line\">super.viewWillDisappear(animated)</span><br><span class=\"line\"></span><br><span class=\"line\">self.disposable?.dispose()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然了，这个方法并不建议。因为Swift是使用ARC管理内存，所有推荐使用清除包（DisposeBag） 来实现这种订阅管理机制。我们可以把一个 DisposeBag对象看成一个垃圾袋，把用过的订阅行为都放进去，这个DisposeBag 就会在自己快要dealloc 的时候，对它里面的所有订阅行为都调用 dispose()方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">//第1个Observable，及其订阅</span><br><span class=\"line\">let observable1 = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class=\"line\">observable1.subscribe &#123; event in</span><br><span class=\"line\">print(event)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">//第2个Observable，及其订阅</span><br><span class=\"line\">let observable2 = Observable.of(1, 2, 3)</span><br><span class=\"line\">observable2.subscribe &#123; event in</span><br><span class=\"line\">print(event)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>此外，还有一种takeUntil，这里就不做过多描述了。</p>\n<h2 id=\"Schedulers-调度器\"><a href=\"#Schedulers-调度器\" class=\"headerlink\" title=\"Schedulers 调度器\"></a>Schedulers 调度器</h2><p>Schedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。<br>在Swift中，我们写一个GCD这么写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 后台取得数据，主线程处理结果</span><br><span class=\"line\">DispatchQueue.global(qos: .userInitiated).async &#123;</span><br><span class=\"line\">let data = try? Data(contentsOf: url)</span><br><span class=\"line\">DispatchQueue.main.async &#123;</span><br><span class=\"line\">self.data = data</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用RxSwift去实现，就这么写:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let rxData: Observable&lt;Data&gt; = ...</span><br><span class=\"line\"></span><br><span class=\"line\">rxData</span><br><span class=\"line\">.subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))</span><br><span class=\"line\">.observeOn(MainScheduler.instance)</span><br><span class=\"line\">.subscribe(onNext: &#123; [weak self] data in</span><br><span class=\"line\">self?.data = data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>在这里，我们用subscribeOn来决定数据序列的构建函数在哪个 Scheduler 上运行，用observeOn来决定在哪个 Scheduler 监听这个数据序列。比如说：在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn切到后台去发送请求并解析数据，最后用 observeOn切换到主线程更新页面。此外，我们来应该了解：</p>\n<ul>\n<li>MainScheduler：代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。</li>\n<li>SerialDispatchQueueScheduler：抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。</li>\n<li>ConcurrentDispatchQueueScheduler：抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。</li>\n<li>OperationQueueScheduler：抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。</li>\n</ul>\n"},{"title":"RxSwift 结合操作符","date":"2018-09-28T13:47:21.000Z","_content":"结合操作（或者称合并操作）指的是将多个`Observable`序列进行组合，拼装成一个新的`Observable`序列。\n#### 1. startWith\n该方法会在`Observable`序列开始之前插入一些事件元素。即发出事件消息之前，会先发出这些预先插入的事件消息。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-1e67a4bb28af2c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(2, 3)\n        .startWith(1)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\n2\n3\n```\n#### 2. concat\n- `concat`操作符将多个`Observables`按顺序串联起来，当前一个`Observable`元素发送完毕后，后一个 Observable 才可以开始发出元素。\n- `concat`将等待前一个 Observable 产生完成事件后，才对后一个`Observable`进行订阅。如果后一个是“热”`Observable`，在它前一个`Observable`产生完成事件前，所产生的元素将不会被发送出来。\n\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-8a8303ad65144b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\net disposeBag = DisposeBag()\n\nlet subject1 = BehaviorSubject.init(value: \"1\")\nlet subject2 = BehaviorSubject.init(value: \"A\")\n\nlet variable = Variable.init(subject1)\nvariable.asObservable()\n        .concat()\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"2\")\nsubject1.onNext(\"3\")\n\nvariable.value = subject2\nsubject2.onNext(\"I would be ignored\")\nsubject2.onNext(\"B\")\n\nsubject1.onCompleted()\nsubject2.onNext(\"C\")\n```\n结果如下：\n```\nnext(1)\nnext(2)\nnext(3)\nnext(B)\nnext(C)\n```\n#### 3. merge\n- 通过使用`merge`操作符你可以将多个`Observables`合并成一个，当某一个`Observable`发出一个元素时，他就将这个元素发出。\n- 如果，某一个`Observable`发出一个`onError`事件，那么被合并的`Observable`也会将它发出，并且立即终止序列。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-4982880854a4f8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<Int>()\nlet subject2 = PublishSubject<Int>()\n\nObservable.of(subject1, subject2)\n        .merge()\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject1.onNext(20)\nsubject1.onNext(40)\nsubject1.onNext(60)\nsubject2.onNext(1)\nsubject1.onNext(80)\nsubject1.onNext(100)\nsubject2.onNext(1)\n```\n结果如下：\n```\n20\n40\n60\n1\n80\n100\n1\n```\n#### 4. zip\n`zip`操作符将多个(最多不超过8个)`Observables`的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的`Observable`的第一个元素，是由每一个源`Observables`的第一个元素组合出来的。它的第二个元素 ，是由每一个源`Observables`的第二个元素组合出来的。它的第三个元素 ，是由每一个源`Observables`的第三个元素组合出来的，以此类推。它的元素数量等于源`Observables`中元素数量最少的那个。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-ae17319dd7d0a940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet first = PublishSubject<String>()\nlet second = PublishSubject<String>()\n\nObservable.zip(first, second) { $0 + $1 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nfirst.onNext(\"1\")\nsecond.onNext(\"A\")\nfirst.onNext(\"2\")\nsecond.onNext(\"B\")\nsecond.onNext(\"C\")\nsecond.onNext(\"D\")\nfirst.onNext(\"3\")\nfirst.onNext(\"4\")\n```\n结果如下：\n```\n1A\n2B\n3C\n4D\n```\n#### 5. combineLatest\n`combineLatest`操作符将多个`Observables`中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源`Observables`中任何一个发出一个元素，他都会发出一个元素（前提是，这些`Observables`曾经发出过元素）。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-2fab45bfd4b8c814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet first = PublishSubject<String>()\nlet second = PublishSubject<String>()\n\nObservable.combineLatest(first, second) { $0 + $1 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nfirst.onNext(\"1\")\nsecond.onNext(\"A\")\nfirst.onNext(\"2\")\nsecond.onNext(\"B\")\nsecond.onNext(\"C\")\nsecond.onNext(\"D\")\nfirst.onNext(\"3\")\nfirst.onNext(\"4\")\n```\n结果如下：\n```\n1A\n2A\n2B\n2C\n2D\n3D\n4D\n```\n#### 6. withLatestFrom\n`withLatestFrom`操作符将两个`Observables`中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。当第一个`Observable`发出一个元素时，就立即取出第二个`Observable`中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-9bfeb60b798296e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<String>()\nlet subject2 = PublishSubject<String>()\n\nsubject1.withLatestFrom(subject2)\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"A\")\nsubject2.onNext(\"1\")\nsubject1.onNext(\"B\")\nsubject1.onNext(\"C\")\nsubject2.onNext(\"2\")\nsubject1.onNext(\"D\")\n\n```\n结果如下：\n```\n1\n1\n2\n```\n","source":"_posts/RxSwift-结合操作符.md","raw":"---\ntitle: RxSwift 结合操作符\ndate: 2018-09-28 21:47:21\ntags: RxSwift\n---\n结合操作（或者称合并操作）指的是将多个`Observable`序列进行组合，拼装成一个新的`Observable`序列。\n#### 1. startWith\n该方法会在`Observable`序列开始之前插入一些事件元素。即发出事件消息之前，会先发出这些预先插入的事件消息。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-1e67a4bb28af2c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(2, 3)\n        .startWith(1)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\n2\n3\n```\n#### 2. concat\n- `concat`操作符将多个`Observables`按顺序串联起来，当前一个`Observable`元素发送完毕后，后一个 Observable 才可以开始发出元素。\n- `concat`将等待前一个 Observable 产生完成事件后，才对后一个`Observable`进行订阅。如果后一个是“热”`Observable`，在它前一个`Observable`产生完成事件前，所产生的元素将不会被发送出来。\n\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-8a8303ad65144b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\net disposeBag = DisposeBag()\n\nlet subject1 = BehaviorSubject.init(value: \"1\")\nlet subject2 = BehaviorSubject.init(value: \"A\")\n\nlet variable = Variable.init(subject1)\nvariable.asObservable()\n        .concat()\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"2\")\nsubject1.onNext(\"3\")\n\nvariable.value = subject2\nsubject2.onNext(\"I would be ignored\")\nsubject2.onNext(\"B\")\n\nsubject1.onCompleted()\nsubject2.onNext(\"C\")\n```\n结果如下：\n```\nnext(1)\nnext(2)\nnext(3)\nnext(B)\nnext(C)\n```\n#### 3. merge\n- 通过使用`merge`操作符你可以将多个`Observables`合并成一个，当某一个`Observable`发出一个元素时，他就将这个元素发出。\n- 如果，某一个`Observable`发出一个`onError`事件，那么被合并的`Observable`也会将它发出，并且立即终止序列。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-4982880854a4f8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<Int>()\nlet subject2 = PublishSubject<Int>()\n\nObservable.of(subject1, subject2)\n        .merge()\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject1.onNext(20)\nsubject1.onNext(40)\nsubject1.onNext(60)\nsubject2.onNext(1)\nsubject1.onNext(80)\nsubject1.onNext(100)\nsubject2.onNext(1)\n```\n结果如下：\n```\n20\n40\n60\n1\n80\n100\n1\n```\n#### 4. zip\n`zip`操作符将多个(最多不超过8个)`Observables`的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的`Observable`的第一个元素，是由每一个源`Observables`的第一个元素组合出来的。它的第二个元素 ，是由每一个源`Observables`的第二个元素组合出来的。它的第三个元素 ，是由每一个源`Observables`的第三个元素组合出来的，以此类推。它的元素数量等于源`Observables`中元素数量最少的那个。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-ae17319dd7d0a940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet first = PublishSubject<String>()\nlet second = PublishSubject<String>()\n\nObservable.zip(first, second) { $0 + $1 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nfirst.onNext(\"1\")\nsecond.onNext(\"A\")\nfirst.onNext(\"2\")\nsecond.onNext(\"B\")\nsecond.onNext(\"C\")\nsecond.onNext(\"D\")\nfirst.onNext(\"3\")\nfirst.onNext(\"4\")\n```\n结果如下：\n```\n1A\n2B\n3C\n4D\n```\n#### 5. combineLatest\n`combineLatest`操作符将多个`Observables`中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源`Observables`中任何一个发出一个元素，他都会发出一个元素（前提是，这些`Observables`曾经发出过元素）。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-2fab45bfd4b8c814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet first = PublishSubject<String>()\nlet second = PublishSubject<String>()\n\nObservable.combineLatest(first, second) { $0 + $1 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nfirst.onNext(\"1\")\nsecond.onNext(\"A\")\nfirst.onNext(\"2\")\nsecond.onNext(\"B\")\nsecond.onNext(\"C\")\nsecond.onNext(\"D\")\nfirst.onNext(\"3\")\nfirst.onNext(\"4\")\n```\n结果如下：\n```\n1A\n2A\n2B\n2C\n2D\n3D\n4D\n```\n#### 6. withLatestFrom\n`withLatestFrom`操作符将两个`Observables`中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。当第一个`Observable`发出一个元素时，就立即取出第二个`Observable`中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-9bfeb60b798296e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<String>()\nlet subject2 = PublishSubject<String>()\n\nsubject1.withLatestFrom(subject2)\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"A\")\nsubject2.onNext(\"1\")\nsubject1.onNext(\"B\")\nsubject1.onNext(\"C\")\nsubject2.onNext(\"2\")\nsubject1.onNext(\"D\")\n\n```\n结果如下：\n```\n1\n1\n2\n```\n","slug":"RxSwift-结合操作符","published":1,"updated":"2018-10-19T07:16:01.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0lok0006imcwg10lko2z","content":"<p>结合操作（或者称合并操作）指的是将多个<code>Observable</code>序列进行组合，拼装成一个新的<code>Observable</code>序列。</p>\n<h4 id=\"1-startWith\"><a href=\"#1-startWith\" class=\"headerlink\" title=\"1. startWith\"></a>1. startWith</h4><p>该方法会在<code>Observable</code>序列开始之前插入一些事件元素。即发出事件消息之前，会先发出这些预先插入的事件消息。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-1e67a4bb28af2c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(2, 3)</span><br><span class=\"line\">        .startWith(1)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-concat\"><a href=\"#2-concat\" class=\"headerlink\" title=\"2. concat\"></a>2. concat</h4><ul>\n<li><code>concat</code>操作符将多个<code>Observables</code>按顺序串联起来，当前一个<code>Observable</code>元素发送完毕后，后一个 Observable 才可以开始发出元素。</li>\n<li><code>concat</code>将等待前一个 Observable 产生完成事件后，才对后一个<code>Observable</code>进行订阅。如果后一个是“热”<code>Observable</code>，在它前一个<code>Observable</code>产生完成事件前，所产生的元素将不会被发送出来。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-8a8303ad65144b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">et disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = BehaviorSubject.init(value: &quot;1&quot;)</span><br><span class=\"line\">let subject2 = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">let variable = Variable.init(subject1)</span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .concat()</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;2&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;3&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.value = subject2</span><br><span class=\"line\">subject2.onNext(&quot;I would be ignored&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;B&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onCompleted()</span><br><span class=\"line\">subject2.onNext(&quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(1)</span><br><span class=\"line\">next(2)</span><br><span class=\"line\">next(3)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">next(C)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-merge\"><a href=\"#3-merge\" class=\"headerlink\" title=\"3. merge\"></a>3. merge</h4><ul>\n<li>通过使用<code>merge</code>操作符你可以将多个<code>Observables</code>合并成一个，当某一个<code>Observable</code>发出一个元素时，他就将这个元素发出。</li>\n<li>如果，某一个<code>Observable</code>发出一个<code>onError</code>事件，那么被合并的<code>Observable</code>也会将它发出，并且立即终止序列。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4982880854a4f8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(subject1, subject2)</span><br><span class=\"line\">        .merge()</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(20)</span><br><span class=\"line\">subject1.onNext(40)</span><br><span class=\"line\">subject1.onNext(60)</span><br><span class=\"line\">subject2.onNext(1)</span><br><span class=\"line\">subject1.onNext(80)</span><br><span class=\"line\">subject1.onNext(100)</span><br><span class=\"line\">subject2.onNext(1)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20</span><br><span class=\"line\">40</span><br><span class=\"line\">60</span><br><span class=\"line\">1</span><br><span class=\"line\">80</span><br><span class=\"line\">100</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-zip\"><a href=\"#4-zip\" class=\"headerlink\" title=\"4. zip\"></a>4. zip</h4><p><code>zip</code>操作符将多个(最多不超过8个)<code>Observables</code>的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的<code>Observable</code>的第一个元素，是由每一个源<code>Observables</code>的第一个元素组合出来的。它的第二个元素 ，是由每一个源<code>Observables</code>的第二个元素组合出来的。它的第三个元素 ，是由每一个源<code>Observables</code>的第三个元素组合出来的，以此类推。它的元素数量等于源<code>Observables</code>中元素数量最少的那个。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ae17319dd7d0a940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let first = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let second = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.zip(first, second) &#123; $0 + $1 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">second.onNext(&quot;A&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\">second.onNext(&quot;B&quot;)</span><br><span class=\"line\">second.onNext(&quot;C&quot;)</span><br><span class=\"line\">second.onNext(&quot;D&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br><span class=\"line\">first.onNext(&quot;4&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1A</span><br><span class=\"line\">2B</span><br><span class=\"line\">3C</span><br><span class=\"line\">4D</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-combineLatest\"><a href=\"#5-combineLatest\" class=\"headerlink\" title=\"5. combineLatest\"></a>5. combineLatest</h4><p><code>combineLatest</code>操作符将多个<code>Observables</code>中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源<code>Observables</code>中任何一个发出一个元素，他都会发出一个元素（前提是，这些<code>Observables</code>曾经发出过元素）。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-2fab45bfd4b8c814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let first = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let second = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.combineLatest(first, second) &#123; $0 + $1 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">second.onNext(&quot;A&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\">second.onNext(&quot;B&quot;)</span><br><span class=\"line\">second.onNext(&quot;C&quot;)</span><br><span class=\"line\">second.onNext(&quot;D&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br><span class=\"line\">first.onNext(&quot;4&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1A</span><br><span class=\"line\">2A</span><br><span class=\"line\">2B</span><br><span class=\"line\">2C</span><br><span class=\"line\">2D</span><br><span class=\"line\">3D</span><br><span class=\"line\">4D</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-withLatestFrom\"><a href=\"#6-withLatestFrom\" class=\"headerlink\" title=\"6. withLatestFrom\"></a>6. withLatestFrom</h4><p><code>withLatestFrom</code>操作符将两个<code>Observables</code>中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。当第一个<code>Observable</code>发出一个元素时，就立即取出第二个<code>Observable</code>中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-9bfeb60b798296e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.withLatestFrom(subject2)</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;1&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;2&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;D&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>结合操作（或者称合并操作）指的是将多个<code>Observable</code>序列进行组合，拼装成一个新的<code>Observable</code>序列。</p>\n<h4 id=\"1-startWith\"><a href=\"#1-startWith\" class=\"headerlink\" title=\"1. startWith\"></a>1. startWith</h4><p>该方法会在<code>Observable</code>序列开始之前插入一些事件元素。即发出事件消息之前，会先发出这些预先插入的事件消息。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-1e67a4bb28af2c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(2, 3)</span><br><span class=\"line\">        .startWith(1)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-concat\"><a href=\"#2-concat\" class=\"headerlink\" title=\"2. concat\"></a>2. concat</h4><ul>\n<li><code>concat</code>操作符将多个<code>Observables</code>按顺序串联起来，当前一个<code>Observable</code>元素发送完毕后，后一个 Observable 才可以开始发出元素。</li>\n<li><code>concat</code>将等待前一个 Observable 产生完成事件后，才对后一个<code>Observable</code>进行订阅。如果后一个是“热”<code>Observable</code>，在它前一个<code>Observable</code>产生完成事件前，所产生的元素将不会被发送出来。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-8a8303ad65144b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">et disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = BehaviorSubject.init(value: &quot;1&quot;)</span><br><span class=\"line\">let subject2 = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">let variable = Variable.init(subject1)</span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .concat()</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;2&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;3&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.value = subject2</span><br><span class=\"line\">subject2.onNext(&quot;I would be ignored&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;B&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onCompleted()</span><br><span class=\"line\">subject2.onNext(&quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(1)</span><br><span class=\"line\">next(2)</span><br><span class=\"line\">next(3)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">next(C)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-merge\"><a href=\"#3-merge\" class=\"headerlink\" title=\"3. merge\"></a>3. merge</h4><ul>\n<li>通过使用<code>merge</code>操作符你可以将多个<code>Observables</code>合并成一个，当某一个<code>Observable</code>发出一个元素时，他就将这个元素发出。</li>\n<li>如果，某一个<code>Observable</code>发出一个<code>onError</code>事件，那么被合并的<code>Observable</code>也会将它发出，并且立即终止序列。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4982880854a4f8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(subject1, subject2)</span><br><span class=\"line\">        .merge()</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(20)</span><br><span class=\"line\">subject1.onNext(40)</span><br><span class=\"line\">subject1.onNext(60)</span><br><span class=\"line\">subject2.onNext(1)</span><br><span class=\"line\">subject1.onNext(80)</span><br><span class=\"line\">subject1.onNext(100)</span><br><span class=\"line\">subject2.onNext(1)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20</span><br><span class=\"line\">40</span><br><span class=\"line\">60</span><br><span class=\"line\">1</span><br><span class=\"line\">80</span><br><span class=\"line\">100</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-zip\"><a href=\"#4-zip\" class=\"headerlink\" title=\"4. zip\"></a>4. zip</h4><p><code>zip</code>操作符将多个(最多不超过8个)<code>Observables</code>的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的<code>Observable</code>的第一个元素，是由每一个源<code>Observables</code>的第一个元素组合出来的。它的第二个元素 ，是由每一个源<code>Observables</code>的第二个元素组合出来的。它的第三个元素 ，是由每一个源<code>Observables</code>的第三个元素组合出来的，以此类推。它的元素数量等于源<code>Observables</code>中元素数量最少的那个。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ae17319dd7d0a940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let first = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let second = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.zip(first, second) &#123; $0 + $1 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">second.onNext(&quot;A&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\">second.onNext(&quot;B&quot;)</span><br><span class=\"line\">second.onNext(&quot;C&quot;)</span><br><span class=\"line\">second.onNext(&quot;D&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br><span class=\"line\">first.onNext(&quot;4&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1A</span><br><span class=\"line\">2B</span><br><span class=\"line\">3C</span><br><span class=\"line\">4D</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-combineLatest\"><a href=\"#5-combineLatest\" class=\"headerlink\" title=\"5. combineLatest\"></a>5. combineLatest</h4><p><code>combineLatest</code>操作符将多个<code>Observables</code>中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源<code>Observables</code>中任何一个发出一个元素，他都会发出一个元素（前提是，这些<code>Observables</code>曾经发出过元素）。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-2fab45bfd4b8c814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let first = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let second = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.combineLatest(first, second) &#123; $0 + $1 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">second.onNext(&quot;A&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\">second.onNext(&quot;B&quot;)</span><br><span class=\"line\">second.onNext(&quot;C&quot;)</span><br><span class=\"line\">second.onNext(&quot;D&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br><span class=\"line\">first.onNext(&quot;4&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1A</span><br><span class=\"line\">2A</span><br><span class=\"line\">2B</span><br><span class=\"line\">2C</span><br><span class=\"line\">2D</span><br><span class=\"line\">3D</span><br><span class=\"line\">4D</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-withLatestFrom\"><a href=\"#6-withLatestFrom\" class=\"headerlink\" title=\"6. withLatestFrom\"></a>6. withLatestFrom</h4><p><code>withLatestFrom</code>操作符将两个<code>Observables</code>中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。当第一个<code>Observable</code>发出一个元素时，就立即取出第二个<code>Observable</code>中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-9bfeb60b798296e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.withLatestFrom(subject2)</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;1&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;2&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;D&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n"},{"title":"RxSwift 过滤操作符(Filtering Observables)","date":"2018-09-26T13:30:34.000Z","_content":"过滤操作指的是从源`Observable`中选择特定的数据发送。\n#### 1. filter\n`filter`操作符将通过你提供的判定方法过滤一个`Observable`。\n![filter.png](https://upload-images.jianshu.io/upload_images/2855070-7403d9c225aec4cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nObservable.of(2, 30, 22, 5, 60, 1)\n        .filter{ $0 > 10 }\n        .subscribe(onNext: { print( $0 )})\n        .disposed(by: disposeBag)\n```\n输出结果：\n```\n30\n22\n60\n```\n#### 2. distinctUntilChanged\n`distinctUntilChanged`操作符将阻止`Observable`发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。\n![distinctUntilChanged.png](https://upload-images.jianshu.io/upload_images/2855070-0c5afa37f9610704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 2, 1, 3)\n        .distinctUntilChanged()\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n输出结果：\n```\n1\n2\n1\n3\n```\n#### 3. single\n- 限制只发送一次事件，或者满足条件的第一个事件。\n- 如果存在有多个事件或者没有事件都会发出一个`error`事件。\n- 如果只有一个事件，则不会发出`error`事件\n\n![single.png](https://upload-images.jianshu.io/upload_images/2855070-29bfd143ec29394e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 4, 4, 5)\n        .single()\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n\nObservable.of(\"A\")\n        .single()\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\nUnhandled error happened: Sequence contains more than one element.\nsubscription called from:\nA\n```\n#### 4. elementAt\n`elementAt`操作符将拉取`Observable`序列中指定索引数的元素，然后将它作为唯一的元素发出。\n![elementAt.png](https://upload-images.jianshu.io/upload_images/2855070-b8ac9409cc9bf25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .elementAt(2)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n3\n```\n#### 5. ignoreElements\n- 该操作符可以忽略掉所有的元素，只发出`error`或`completed`事件。\n- 如果我们并不关心`Observable`的任何元素，只想知道`Observable`在什么时候终止，那就可以使用`ignoreElements`操作符。\n\n![ignoreElements.png](https://upload-images.jianshu.io/upload_images/2855070-bcadae47ddc7f71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 4, 4, 5)\n        .ignoreElements()\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\ncompleted\n```\n#### 6.take\n该方法实现仅发送`Observable`序列中的前`n`个事件，在满足数量之后会自动`.completed`\n![take.png](https://upload-images.jianshu.io/upload_images/2855070-ba890655a1787c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .take(2)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\n2\n```\n#### 7. takeLast\n该方法实现仅发送`Observable`序列中的后`n`个事件\n![takeLast.png](https://upload-images.jianshu.io/upload_images/2855070-3e60ff6e411e234c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .takeLast(1)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n4\n```\n#### 8. skip\n该方法用于跳过源`Observable`序列发出的前`n`个事件。\n![skip.png](https://upload-images.jianshu.io/upload_images/2855070-439c4618a9901d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .skip(2)\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n3\n4\n```\n#### 9. Sample\n- `Sample`除了订阅源`Observable`外，还可以监视另外一个`Observable`， 即`notifier`。\n每当收到`notifier`事件，就会从源序列取一个最新的事件并发送。而如果两次`notifier`事件之间没有源序列的事件，则不发送值。\n\n![sample.png](https://upload-images.jianshu.io/upload_images/2855070-509212ce29f1c102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet source = PublishSubject<Int>()\nlet notifier = PublishSubject<String>()\n\nsource.sample(notifier)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n\nsource.onNext(1)\n\nnotifier.onNext(\"A\")\n\nsource.onNext(2)\n\nnotifier.onNext(\"B\")\nnotifier.onNext(\"C\")\n\nsource.onNext(3)\nsource.onNext(4)\n\nnotifier.onNext(\"D\")\n\nsource.onNext(5)\n\nnotifier.onCompleted()\n```\n结果如下：\n```\n1\n2\n4\n5\n```\n#### 10. debounce\n- `debounce`操作符可以用来_过滤掉高频产生的元素_，它只会发出这种元素：该元素产生后，一段时间内没有新元素产生。\n- 换句话说就是，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉。\n- `debounce`常用在_用户输入_的时候，不需要每个字母敲进去都发送一个事件，而是稍等一下取最后一个事件。\n\n![debounce.png](https://upload-images.jianshu.io/upload_images/2855070-b313fa33f47012ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\n\n//定义好每个事件里的值以及发送的时间\nlet times = [\n[ \"value\": 1, \"time\": 0.1 ],\n[ \"value\": 2, \"time\": 1.1 ],\n[ \"value\": 3, \"time\": 1.2 ],\n[ \"value\": 4, \"time\": 1.2 ],\n[ \"value\": 5, \"time\": 1.4 ],\n[ \"value\": 6, \"time\": 2.1 ]\n]\n\n//生成对应的 Observable 序列并订阅\nObservable.from(times)\n        .flatMap { item in\n            return Observable.of(Int(item[\"value\"]!))\n                            .delaySubscription(Double(item[\"time\"]!),scheduler: MainScheduler.instance)\n                }\n        .debounce(0.5, scheduler: MainScheduler.instance) //只发出与下一个间隔超过0.5秒的元素\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n```\n运行结果......为啥我啥也没打印出来？？？\n![u=4240739968,2514380758&fm=27&gp=0.jpg](https://upload-images.jianshu.io/upload_images/2855070-bafa66b6f115f0c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个留在下回思考......\n但据可靠信息，咳咳咳，打印出来的应该是\n```\n1\n5\n6\n```\n\n","source":"_posts/RxSwift-过滤操作符-Filtering-Observables.md","raw":"---\ntitle: RxSwift 过滤操作符(Filtering Observables)\ndate: 2018-09-26 21:30:34\ntags: RxSwift\n---\n过滤操作指的是从源`Observable`中选择特定的数据发送。\n#### 1. filter\n`filter`操作符将通过你提供的判定方法过滤一个`Observable`。\n![filter.png](https://upload-images.jianshu.io/upload_images/2855070-7403d9c225aec4cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nObservable.of(2, 30, 22, 5, 60, 1)\n        .filter{ $0 > 10 }\n        .subscribe(onNext: { print( $0 )})\n        .disposed(by: disposeBag)\n```\n输出结果：\n```\n30\n22\n60\n```\n#### 2. distinctUntilChanged\n`distinctUntilChanged`操作符将阻止`Observable`发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。\n![distinctUntilChanged.png](https://upload-images.jianshu.io/upload_images/2855070-0c5afa37f9610704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 2, 1, 3)\n        .distinctUntilChanged()\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n输出结果：\n```\n1\n2\n1\n3\n```\n#### 3. single\n- 限制只发送一次事件，或者满足条件的第一个事件。\n- 如果存在有多个事件或者没有事件都会发出一个`error`事件。\n- 如果只有一个事件，则不会发出`error`事件\n\n![single.png](https://upload-images.jianshu.io/upload_images/2855070-29bfd143ec29394e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 4, 4, 5)\n        .single()\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n\nObservable.of(\"A\")\n        .single()\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\nUnhandled error happened: Sequence contains more than one element.\nsubscription called from:\nA\n```\n#### 4. elementAt\n`elementAt`操作符将拉取`Observable`序列中指定索引数的元素，然后将它作为唯一的元素发出。\n![elementAt.png](https://upload-images.jianshu.io/upload_images/2855070-b8ac9409cc9bf25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .elementAt(2)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n3\n```\n#### 5. ignoreElements\n- 该操作符可以忽略掉所有的元素，只发出`error`或`completed`事件。\n- 如果我们并不关心`Observable`的任何元素，只想知道`Observable`在什么时候终止，那就可以使用`ignoreElements`操作符。\n\n![ignoreElements.png](https://upload-images.jianshu.io/upload_images/2855070-bcadae47ddc7f71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 4, 4, 5)\n        .ignoreElements()\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\ncompleted\n```\n#### 6.take\n该方法实现仅发送`Observable`序列中的前`n`个事件，在满足数量之后会自动`.completed`\n![take.png](https://upload-images.jianshu.io/upload_images/2855070-ba890655a1787c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .take(2)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\n2\n```\n#### 7. takeLast\n该方法实现仅发送`Observable`序列中的后`n`个事件\n![takeLast.png](https://upload-images.jianshu.io/upload_images/2855070-3e60ff6e411e234c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .takeLast(1)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n4\n```\n#### 8. skip\n该方法用于跳过源`Observable`序列发出的前`n`个事件。\n![skip.png](https://upload-images.jianshu.io/upload_images/2855070-439c4618a9901d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .skip(2)\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n3\n4\n```\n#### 9. Sample\n- `Sample`除了订阅源`Observable`外，还可以监视另外一个`Observable`， 即`notifier`。\n每当收到`notifier`事件，就会从源序列取一个最新的事件并发送。而如果两次`notifier`事件之间没有源序列的事件，则不发送值。\n\n![sample.png](https://upload-images.jianshu.io/upload_images/2855070-509212ce29f1c102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet source = PublishSubject<Int>()\nlet notifier = PublishSubject<String>()\n\nsource.sample(notifier)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n\nsource.onNext(1)\n\nnotifier.onNext(\"A\")\n\nsource.onNext(2)\n\nnotifier.onNext(\"B\")\nnotifier.onNext(\"C\")\n\nsource.onNext(3)\nsource.onNext(4)\n\nnotifier.onNext(\"D\")\n\nsource.onNext(5)\n\nnotifier.onCompleted()\n```\n结果如下：\n```\n1\n2\n4\n5\n```\n#### 10. debounce\n- `debounce`操作符可以用来_过滤掉高频产生的元素_，它只会发出这种元素：该元素产生后，一段时间内没有新元素产生。\n- 换句话说就是，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉。\n- `debounce`常用在_用户输入_的时候，不需要每个字母敲进去都发送一个事件，而是稍等一下取最后一个事件。\n\n![debounce.png](https://upload-images.jianshu.io/upload_images/2855070-b313fa33f47012ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\n\n//定义好每个事件里的值以及发送的时间\nlet times = [\n[ \"value\": 1, \"time\": 0.1 ],\n[ \"value\": 2, \"time\": 1.1 ],\n[ \"value\": 3, \"time\": 1.2 ],\n[ \"value\": 4, \"time\": 1.2 ],\n[ \"value\": 5, \"time\": 1.4 ],\n[ \"value\": 6, \"time\": 2.1 ]\n]\n\n//生成对应的 Observable 序列并订阅\nObservable.from(times)\n        .flatMap { item in\n            return Observable.of(Int(item[\"value\"]!))\n                            .delaySubscription(Double(item[\"time\"]!),scheduler: MainScheduler.instance)\n                }\n        .debounce(0.5, scheduler: MainScheduler.instance) //只发出与下一个间隔超过0.5秒的元素\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n```\n运行结果......为啥我啥也没打印出来？？？\n![u=4240739968,2514380758&fm=27&gp=0.jpg](https://upload-images.jianshu.io/upload_images/2855070-bafa66b6f115f0c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个留在下回思考......\n但据可靠信息，咳咳咳，打印出来的应该是\n```\n1\n5\n6\n```\n\n","slug":"RxSwift-过滤操作符-Filtering-Observables","published":1,"updated":"2018-10-19T07:16:01.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0lon0009imcw0sccdjdl","content":"<p>过滤操作指的是从源<code>Observable</code>中选择特定的数据发送。</p>\n<h4 id=\"1-filter\"><a href=\"#1-filter\" class=\"headerlink\" title=\"1. filter\"></a>1. filter</h4><p><code>filter</code>操作符将通过你提供的判定方法过滤一个<code>Observable</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-7403d9c225aec4cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"filter.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(2, 30, 22, 5, 60, 1)</span><br><span class=\"line\">        .filter&#123; $0 &gt; 10 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print( $0 )&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30</span><br><span class=\"line\">22</span><br><span class=\"line\">60</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-distinctUntilChanged\"><a href=\"#2-distinctUntilChanged\" class=\"headerlink\" title=\"2. distinctUntilChanged\"></a>2. distinctUntilChanged</h4><p><code>distinctUntilChanged</code>操作符将阻止<code>Observable</code>发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-0c5afa37f9610704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"distinctUntilChanged.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 2, 1, 3)</span><br><span class=\"line\">        .distinctUntilChanged()</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-single\"><a href=\"#3-single\" class=\"headerlink\" title=\"3. single\"></a>3. single</h4><ul>\n<li>限制只发送一次事件，或者满足条件的第一个事件。</li>\n<li>如果存在有多个事件或者没有事件都会发出一个<code>error</code>事件。</li>\n<li>如果只有一个事件，则不会发出<code>error</code>事件</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-29bfd143ec29394e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"single.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 4, 4, 5)</span><br><span class=\"line\">        .single()</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(&quot;A&quot;)</span><br><span class=\"line\">        .single()</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">Unhandled error happened: Sequence contains more than one element.</span><br><span class=\"line\">subscription called from:</span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-elementAt\"><a href=\"#4-elementAt\" class=\"headerlink\" title=\"4. elementAt\"></a>4. elementAt</h4><p><code>elementAt</code>操作符将拉取<code>Observable</code>序列中指定索引数的元素，然后将它作为唯一的元素发出。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b8ac9409cc9bf25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"elementAt.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .elementAt(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-ignoreElements\"><a href=\"#5-ignoreElements\" class=\"headerlink\" title=\"5. ignoreElements\"></a>5. ignoreElements</h4><ul>\n<li>该操作符可以忽略掉所有的元素，只发出<code>error</code>或<code>completed</code>事件。</li>\n<li>如果我们并不关心<code>Observable</code>的任何元素，只想知道<code>Observable</code>在什么时候终止，那就可以使用<code>ignoreElements</code>操作符。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bcadae47ddc7f71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ignoreElements.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 4, 4, 5)</span><br><span class=\"line\">        .ignoreElements()</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-take\"><a href=\"#6-take\" class=\"headerlink\" title=\"6.take\"></a>6.take</h4><p>该方法实现仅发送<code>Observable</code>序列中的前<code>n</code>个事件，在满足数量之后会自动<code>.completed</code><br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ba890655a1787c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"take.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .take(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-takeLast\"><a href=\"#7-takeLast\" class=\"headerlink\" title=\"7. takeLast\"></a>7. takeLast</h4><p>该方法实现仅发送<code>Observable</code>序列中的后<code>n</code>个事件<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-3e60ff6e411e234c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"takeLast.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .takeLast(1)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-skip\"><a href=\"#8-skip\" class=\"headerlink\" title=\"8. skip\"></a>8. skip</h4><p>该方法用于跳过源<code>Observable</code>序列发出的前<code>n</code>个事件。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-439c4618a9901d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"skip.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .skip(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"9-Sample\"><a href=\"#9-Sample\" class=\"headerlink\" title=\"9. Sample\"></a>9. Sample</h4><ul>\n<li><code>Sample</code>除了订阅源<code>Observable</code>外，还可以监视另外一个<code>Observable</code>， 即<code>notifier</code>。<br>每当收到<code>notifier</code>事件，就会从源序列取一个最新的事件并发送。而如果两次<code>notifier</code>事件之间没有源序列的事件，则不发送值。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-509212ce29f1c102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"sample.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let source = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let notifier = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">source.sample(notifier)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(1)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;A&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(2)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;B&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(3)</span><br><span class=\"line\">source.onNext(4)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;D&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(5)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onCompleted()</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"10-debounce\"><a href=\"#10-debounce\" class=\"headerlink\" title=\"10. debounce\"></a>10. debounce</h4><ul>\n<li><code>debounce</code>操作符可以用来<em>过滤掉高频产生的元素</em>，它只会发出这种元素：该元素产生后，一段时间内没有新元素产生。</li>\n<li>换句话说就是，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉。</li>\n<li><code>debounce</code>常用在<em>用户输入</em>的时候，不需要每个字母敲进去都发送一个事件，而是稍等一下取最后一个事件。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b313fa33f47012ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"debounce.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">//定义好每个事件里的值以及发送的时间</span><br><span class=\"line\">let times = [</span><br><span class=\"line\">[ &quot;value&quot;: 1, &quot;time&quot;: 0.1 ],</span><br><span class=\"line\">[ &quot;value&quot;: 2, &quot;time&quot;: 1.1 ],</span><br><span class=\"line\">[ &quot;value&quot;: 3, &quot;time&quot;: 1.2 ],</span><br><span class=\"line\">[ &quot;value&quot;: 4, &quot;time&quot;: 1.2 ],</span><br><span class=\"line\">[ &quot;value&quot;: 5, &quot;time&quot;: 1.4 ],</span><br><span class=\"line\">[ &quot;value&quot;: 6, &quot;time&quot;: 2.1 ]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">//生成对应的 Observable 序列并订阅</span><br><span class=\"line\">Observable.from(times)</span><br><span class=\"line\">        .flatMap &#123; item in</span><br><span class=\"line\">            return Observable.of(Int(item[&quot;value&quot;]!))</span><br><span class=\"line\">                            .delaySubscription(Double(item[&quot;time&quot;]!),scheduler: MainScheduler.instance)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        .debounce(0.5, scheduler: MainScheduler.instance) //只发出与下一个间隔超过0.5秒的元素</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>运行结果……为啥我啥也没打印出来？？？<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bafa66b6f115f0c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"u=4240739968,2514380758&amp;fm=27&amp;gp=0.jpg\"><br>这个留在下回思考……<br>但据可靠信息，咳咳咳，打印出来的应该是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>过滤操作指的是从源<code>Observable</code>中选择特定的数据发送。</p>\n<h4 id=\"1-filter\"><a href=\"#1-filter\" class=\"headerlink\" title=\"1. filter\"></a>1. filter</h4><p><code>filter</code>操作符将通过你提供的判定方法过滤一个<code>Observable</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-7403d9c225aec4cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"filter.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(2, 30, 22, 5, 60, 1)</span><br><span class=\"line\">        .filter&#123; $0 &gt; 10 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print( $0 )&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30</span><br><span class=\"line\">22</span><br><span class=\"line\">60</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-distinctUntilChanged\"><a href=\"#2-distinctUntilChanged\" class=\"headerlink\" title=\"2. distinctUntilChanged\"></a>2. distinctUntilChanged</h4><p><code>distinctUntilChanged</code>操作符将阻止<code>Observable</code>发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-0c5afa37f9610704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"distinctUntilChanged.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 2, 1, 3)</span><br><span class=\"line\">        .distinctUntilChanged()</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-single\"><a href=\"#3-single\" class=\"headerlink\" title=\"3. single\"></a>3. single</h4><ul>\n<li>限制只发送一次事件，或者满足条件的第一个事件。</li>\n<li>如果存在有多个事件或者没有事件都会发出一个<code>error</code>事件。</li>\n<li>如果只有一个事件，则不会发出<code>error</code>事件</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-29bfd143ec29394e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"single.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 4, 4, 5)</span><br><span class=\"line\">        .single()</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(&quot;A&quot;)</span><br><span class=\"line\">        .single()</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">Unhandled error happened: Sequence contains more than one element.</span><br><span class=\"line\">subscription called from:</span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-elementAt\"><a href=\"#4-elementAt\" class=\"headerlink\" title=\"4. elementAt\"></a>4. elementAt</h4><p><code>elementAt</code>操作符将拉取<code>Observable</code>序列中指定索引数的元素，然后将它作为唯一的元素发出。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b8ac9409cc9bf25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"elementAt.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .elementAt(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-ignoreElements\"><a href=\"#5-ignoreElements\" class=\"headerlink\" title=\"5. ignoreElements\"></a>5. ignoreElements</h4><ul>\n<li>该操作符可以忽略掉所有的元素，只发出<code>error</code>或<code>completed</code>事件。</li>\n<li>如果我们并不关心<code>Observable</code>的任何元素，只想知道<code>Observable</code>在什么时候终止，那就可以使用<code>ignoreElements</code>操作符。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bcadae47ddc7f71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ignoreElements.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 4, 4, 5)</span><br><span class=\"line\">        .ignoreElements()</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-take\"><a href=\"#6-take\" class=\"headerlink\" title=\"6.take\"></a>6.take</h4><p>该方法实现仅发送<code>Observable</code>序列中的前<code>n</code>个事件，在满足数量之后会自动<code>.completed</code><br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ba890655a1787c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"take.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .take(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-takeLast\"><a href=\"#7-takeLast\" class=\"headerlink\" title=\"7. takeLast\"></a>7. takeLast</h4><p>该方法实现仅发送<code>Observable</code>序列中的后<code>n</code>个事件<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-3e60ff6e411e234c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"takeLast.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .takeLast(1)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-skip\"><a href=\"#8-skip\" class=\"headerlink\" title=\"8. skip\"></a>8. skip</h4><p>该方法用于跳过源<code>Observable</code>序列发出的前<code>n</code>个事件。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-439c4618a9901d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"skip.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .skip(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"9-Sample\"><a href=\"#9-Sample\" class=\"headerlink\" title=\"9. Sample\"></a>9. Sample</h4><ul>\n<li><code>Sample</code>除了订阅源<code>Observable</code>外，还可以监视另外一个<code>Observable</code>， 即<code>notifier</code>。<br>每当收到<code>notifier</code>事件，就会从源序列取一个最新的事件并发送。而如果两次<code>notifier</code>事件之间没有源序列的事件，则不发送值。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-509212ce29f1c102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"sample.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let source = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let notifier = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">source.sample(notifier)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(1)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;A&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(2)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;B&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(3)</span><br><span class=\"line\">source.onNext(4)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;D&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(5)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onCompleted()</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"10-debounce\"><a href=\"#10-debounce\" class=\"headerlink\" title=\"10. debounce\"></a>10. debounce</h4><ul>\n<li><code>debounce</code>操作符可以用来<em>过滤掉高频产生的元素</em>，它只会发出这种元素：该元素产生后，一段时间内没有新元素产生。</li>\n<li>换句话说就是，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉。</li>\n<li><code>debounce</code>常用在<em>用户输入</em>的时候，不需要每个字母敲进去都发送一个事件，而是稍等一下取最后一个事件。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b313fa33f47012ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"debounce.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">//定义好每个事件里的值以及发送的时间</span><br><span class=\"line\">let times = [</span><br><span class=\"line\">[ &quot;value&quot;: 1, &quot;time&quot;: 0.1 ],</span><br><span class=\"line\">[ &quot;value&quot;: 2, &quot;time&quot;: 1.1 ],</span><br><span class=\"line\">[ &quot;value&quot;: 3, &quot;time&quot;: 1.2 ],</span><br><span class=\"line\">[ &quot;value&quot;: 4, &quot;time&quot;: 1.2 ],</span><br><span class=\"line\">[ &quot;value&quot;: 5, &quot;time&quot;: 1.4 ],</span><br><span class=\"line\">[ &quot;value&quot;: 6, &quot;time&quot;: 2.1 ]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">//生成对应的 Observable 序列并订阅</span><br><span class=\"line\">Observable.from(times)</span><br><span class=\"line\">        .flatMap &#123; item in</span><br><span class=\"line\">            return Observable.of(Int(item[&quot;value&quot;]!))</span><br><span class=\"line\">                            .delaySubscription(Double(item[&quot;time&quot;]!),scheduler: MainScheduler.instance)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        .debounce(0.5, scheduler: MainScheduler.instance) //只发出与下一个间隔超过0.5秒的元素</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>运行结果……为啥我啥也没打印出来？？？<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bafa66b6f115f0c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"u=4240739968,2514380758&amp;fm=27&amp;gp=0.jpg\"><br>这个留在下回思考……<br>但据可靠信息，咳咳咳，打印出来的应该是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure></p>\n"},{"title":"swift 内联序列函数sequence","date":"2018-09-13T12:24:08.000Z","_content":"在看RxSwift文章的时候，有人说到了Sequence。恕小弟才疏学浅，在日常搬砖中没有使用到它，所以在此记录一下。 \nsequence是在swift3就出现的。使用它们可以返回一个无限序列。我们可以给他们一个初始值，或者初始状态，然后他们便会以懒加载的方式应用到一个闭包。方法如下：\n```\n1.public func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)>\n2.public func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State>\n```\n### 方法1：\n```\npublic func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)>\n```\nfirst:从序列返回的第一个元素\nnext:一个闭包，它接受前一个sequence元素并返回下一个元素\n举个🌰，我们想打印从1-100范围内所有的偶数\n```\nfor i in sequence(first: 1, next: { $0 * 2}){\n    if i > 100{\n        break\n    }\n    print(i)\n}\n```\n或者，我们也可以把处理逻辑，状态判断放在next闭包里面，🌰：\n```\nfor _ in sequence(first: 1, next: {\n    print($0)\n    let value = $0 * 2\n    return value <= 100 ? value : nil\n}){}\n```\n在文档中还有一个🌰，从某一个树节点一直向上遍历到根节点\n```\nfor node in sequence(first: leaf, next: { $0.parent }) {\n    // node is leaf, then leaf.parent, then leaf.parent.parent, etc.\n}\n```\n### 方法2：\n```\npublic func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State>\n```\n这个方法是设置个初始状态（可变的），后面将其传 入next 闭包改变状态，并获取下一个序列，依次类推。举个🌰：我们制定X轴Y轴最大值，列出内部所有的整点：\n```\n// 实现方法\nfunc cartesianSequence(xCount: Int, yCount: Int) -> UnfoldSequence<PointType, Int>{\n    // assert断言\n    assert(xCount > 0 && yCount > 0, \"必须使用正整数创建序列\")\n    return sequence(state: 0, next: { (index: inout Int) -> PointType? in\n    guard index < xCount * yCount else {\n        return nil\n        }\n    defer{\n        index += 1\n    }\n    return (x: index % xCount, y :index / xCount)\n    })\n}\n// 调用方法\nfor point in cartesianSequence(xCount: 3, yCount: 3){\n    print(\"x:\\(point.x), y:\\(point.y)\")\n    /*\n    x:0, y:0 x:1, y:0 x:2, y:0\n    x:0, y:1 x:1, y:1 x:2, y:1 \n    x:0, y:2 x:1, y:2 x:2, y:2\n    */\n}\n```\n","source":"_posts/swift-Sequence.md","raw":"---\ntitle: swift 内联序列函数sequence\ndate: 2018-09-13 20:24:08\ntags: swift 冷门方法\n---\n在看RxSwift文章的时候，有人说到了Sequence。恕小弟才疏学浅，在日常搬砖中没有使用到它，所以在此记录一下。 \nsequence是在swift3就出现的。使用它们可以返回一个无限序列。我们可以给他们一个初始值，或者初始状态，然后他们便会以懒加载的方式应用到一个闭包。方法如下：\n```\n1.public func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)>\n2.public func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State>\n```\n### 方法1：\n```\npublic func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)>\n```\nfirst:从序列返回的第一个元素\nnext:一个闭包，它接受前一个sequence元素并返回下一个元素\n举个🌰，我们想打印从1-100范围内所有的偶数\n```\nfor i in sequence(first: 1, next: { $0 * 2}){\n    if i > 100{\n        break\n    }\n    print(i)\n}\n```\n或者，我们也可以把处理逻辑，状态判断放在next闭包里面，🌰：\n```\nfor _ in sequence(first: 1, next: {\n    print($0)\n    let value = $0 * 2\n    return value <= 100 ? value : nil\n}){}\n```\n在文档中还有一个🌰，从某一个树节点一直向上遍历到根节点\n```\nfor node in sequence(first: leaf, next: { $0.parent }) {\n    // node is leaf, then leaf.parent, then leaf.parent.parent, etc.\n}\n```\n### 方法2：\n```\npublic func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State>\n```\n这个方法是设置个初始状态（可变的），后面将其传 入next 闭包改变状态，并获取下一个序列，依次类推。举个🌰：我们制定X轴Y轴最大值，列出内部所有的整点：\n```\n// 实现方法\nfunc cartesianSequence(xCount: Int, yCount: Int) -> UnfoldSequence<PointType, Int>{\n    // assert断言\n    assert(xCount > 0 && yCount > 0, \"必须使用正整数创建序列\")\n    return sequence(state: 0, next: { (index: inout Int) -> PointType? in\n    guard index < xCount * yCount else {\n        return nil\n        }\n    defer{\n        index += 1\n    }\n    return (x: index % xCount, y :index / xCount)\n    })\n}\n// 调用方法\nfor point in cartesianSequence(xCount: 3, yCount: 3){\n    print(\"x:\\(point.x), y:\\(point.y)\")\n    /*\n    x:0, y:0 x:1, y:0 x:2, y:0\n    x:0, y:1 x:1, y:1 x:2, y:1 \n    x:0, y:2 x:1, y:2 x:2, y:2\n    */\n}\n```\n","slug":"swift-Sequence","published":1,"updated":"2018-10-19T07:16:01.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0lop000bimcweon6ioy8","content":"<p>在看RxSwift文章的时候，有人说到了Sequence。恕小弟才疏学浅，在日常搬砖中没有使用到它，所以在此记录一下。<br>sequence是在swift3就出现的。使用它们可以返回一个无限序列。我们可以给他们一个初始值，或者初始状态，然后他们便会以懒加载的方式应用到一个闭包。方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.public func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt;</span><br><span class=\"line\">2.public func sequence&lt;T, State&gt;(state: State, next: @escaping (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法1：\"><a href=\"#方法1：\" class=\"headerlink\" title=\"方法1：\"></a>方法1：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt;</span><br></pre></td></tr></table></figure>\n<p>first:从序列返回的第一个元素<br>next:一个闭包，它接受前一个sequence元素并返回下一个元素<br>举个🌰，我们想打印从1-100范围内所有的偶数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in sequence(first: 1, next: &#123; $0 * 2&#125;)&#123;</span><br><span class=\"line\">    if i &gt; 100&#123;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者，我们也可以把处理逻辑，状态判断放在next闭包里面，🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for _ in sequence(first: 1, next: &#123;</span><br><span class=\"line\">    print($0)</span><br><span class=\"line\">    let value = $0 * 2</span><br><span class=\"line\">    return value &lt;= 100 ? value : nil</span><br><span class=\"line\">&#125;)&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在文档中还有一个🌰，从某一个树节点一直向上遍历到根节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for node in sequence(first: leaf, next: &#123; $0.parent &#125;) &#123;</span><br><span class=\"line\">    // node is leaf, then leaf.parent, then leaf.parent.parent, etc.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法2：\"><a href=\"#方法2：\" class=\"headerlink\" title=\"方法2：\"></a>方法2：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public func sequence&lt;T, State&gt;(state: State, next: @escaping (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt;</span><br></pre></td></tr></table></figure>\n<p>这个方法是设置个初始状态（可变的），后面将其传 入next 闭包改变状态，并获取下一个序列，依次类推。举个🌰：我们制定X轴Y轴最大值，列出内部所有的整点：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 实现方法</span><br><span class=\"line\">func cartesianSequence(xCount: Int, yCount: Int) -&gt; UnfoldSequence&lt;PointType, Int&gt;&#123;</span><br><span class=\"line\">    // assert断言</span><br><span class=\"line\">    assert(xCount &gt; 0 &amp;&amp; yCount &gt; 0, &quot;必须使用正整数创建序列&quot;)</span><br><span class=\"line\">    return sequence(state: 0, next: &#123; (index: inout Int) -&gt; PointType? in</span><br><span class=\"line\">    guard index &lt; xCount * yCount else &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    defer&#123;</span><br><span class=\"line\">        index += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (x: index % xCount, y :index / xCount)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 调用方法</span><br><span class=\"line\">for point in cartesianSequence(xCount: 3, yCount: 3)&#123;</span><br><span class=\"line\">    print(&quot;x:\\(point.x), y:\\(point.y)&quot;)</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    x:0, y:0 x:1, y:0 x:2, y:0</span><br><span class=\"line\">    x:0, y:1 x:1, y:1 x:2, y:1 </span><br><span class=\"line\">    x:0, y:2 x:1, y:2 x:2, y:2</span><br><span class=\"line\">    */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在看RxSwift文章的时候，有人说到了Sequence。恕小弟才疏学浅，在日常搬砖中没有使用到它，所以在此记录一下。<br>sequence是在swift3就出现的。使用它们可以返回一个无限序列。我们可以给他们一个初始值，或者初始状态，然后他们便会以懒加载的方式应用到一个闭包。方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.public func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt;</span><br><span class=\"line\">2.public func sequence&lt;T, State&gt;(state: State, next: @escaping (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法1：\"><a href=\"#方法1：\" class=\"headerlink\" title=\"方法1：\"></a>方法1：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt;</span><br></pre></td></tr></table></figure>\n<p>first:从序列返回的第一个元素<br>next:一个闭包，它接受前一个sequence元素并返回下一个元素<br>举个🌰，我们想打印从1-100范围内所有的偶数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in sequence(first: 1, next: &#123; $0 * 2&#125;)&#123;</span><br><span class=\"line\">    if i &gt; 100&#123;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者，我们也可以把处理逻辑，状态判断放在next闭包里面，🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for _ in sequence(first: 1, next: &#123;</span><br><span class=\"line\">    print($0)</span><br><span class=\"line\">    let value = $0 * 2</span><br><span class=\"line\">    return value &lt;= 100 ? value : nil</span><br><span class=\"line\">&#125;)&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在文档中还有一个🌰，从某一个树节点一直向上遍历到根节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for node in sequence(first: leaf, next: &#123; $0.parent &#125;) &#123;</span><br><span class=\"line\">    // node is leaf, then leaf.parent, then leaf.parent.parent, etc.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法2：\"><a href=\"#方法2：\" class=\"headerlink\" title=\"方法2：\"></a>方法2：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public func sequence&lt;T, State&gt;(state: State, next: @escaping (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt;</span><br></pre></td></tr></table></figure>\n<p>这个方法是设置个初始状态（可变的），后面将其传 入next 闭包改变状态，并获取下一个序列，依次类推。举个🌰：我们制定X轴Y轴最大值，列出内部所有的整点：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 实现方法</span><br><span class=\"line\">func cartesianSequence(xCount: Int, yCount: Int) -&gt; UnfoldSequence&lt;PointType, Int&gt;&#123;</span><br><span class=\"line\">    // assert断言</span><br><span class=\"line\">    assert(xCount &gt; 0 &amp;&amp; yCount &gt; 0, &quot;必须使用正整数创建序列&quot;)</span><br><span class=\"line\">    return sequence(state: 0, next: &#123; (index: inout Int) -&gt; PointType? in</span><br><span class=\"line\">    guard index &lt; xCount * yCount else &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    defer&#123;</span><br><span class=\"line\">        index += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (x: index % xCount, y :index / xCount)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 调用方法</span><br><span class=\"line\">for point in cartesianSequence(xCount: 3, yCount: 3)&#123;</span><br><span class=\"line\">    print(&quot;x:\\(point.x), y:\\(point.y)&quot;)</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    x:0, y:0 x:1, y:0 x:2, y:0</span><br><span class=\"line\">    x:0, y:1 x:1, y:1 x:2, y:1 </span><br><span class=\"line\">    x:0, y:2 x:1, y:2 x:2, y:2</span><br><span class=\"line\">    */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"一张图片引发的思考","date":"2018-10-18T06:09:38.000Z","_content":"## 背景：\n前段时间做微信小程序分享，用了某家的SDK，然鹅......他们家SDK只能上传`png`、`jpeg`格式的图片，微信不是可以上传`Data`吗？？？？\n![???.jpeg](https://upload-images.jianshu.io/upload_images/2855070-1e640864e3ce90f4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我吭哧吭哧半天用`UIImageJPEGRepresentation`压缩图片，然后在生成图片，也没把图片传上去。我当时想肯定是图片大小有问题，因为微信限制128KB以内。我查看保存在沙盒里的图片才32KB啊？？怎么会上传不上去呢？再查看`Image`的`Data`大小，噗~~~168KB。好吧，我被打败了。最后还是用微信原生SDK才搞定，直接传一个`Data`过去，多开心，多easy。\n## 正文\n好的，扯了这么多，其实就是想说一下为啥会有今天这篇大水文。在解决问题的过程中，我对iOS加载图片的理解稍微深入了那么一丢丢。现在，就水一下我理解的那么一丢丢东西。\n### 图片经过哪些流程加载到屏幕上\n1. 从磁盘拷贝数据到内核缓冲区\n2. 从内核缓冲区复制数据到用户空间（内存级别拷贝）\n3. 生成`UIImage`，把`UIImage`赋值给`UIImageView`\n4. 如果图像数据为未解码的PNG/JPG，解码为位图数据\n5. 隐式`CATransaction`捕获到`UIImageView`图层树的变化\n6. 主线程`Runloop`提交`CATransaction`，开始进行图像渲染\n6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐\n6.2 GPU处理位图数据，进行渲染\n\n其中第四点就是导致我32KB变168KB的“罪魁祸首”。为啥这么说呢？先了解一些东西。\n\n### PNG\n`PNG`只支持无损压缩，所以它的压缩比是有上限的。它有`alpha`通道，支持图片透明。此外xcode会对png格式进行特殊的优化处理，而对于其他图片不做处理，所以我们一些小图标经常用`PNG`。\n#### JPEG\n`JPEG`支持有损压缩，不含有`alpha`通道，它可以通过图片质量换取内存空间。网络图片最好选用`JPEG`，可以节省流量、提高下载速度。\n### 位图\n我们是否可以直接使用图片，使其显示在屏幕上呢？答案显然后__不可以__。图片经过解压后，变成位图数据。那么[位图](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3)是什么呢?苹果给出的解释是\n> A bitmap image (or sampled image) is an array of pixels (or samples)\n\n位图是一个像素数组。至于怎么将像素绘制到屏幕上，可以看[这篇文章](https://objccn.io/issue-3-1/)，就不做过多叙述（人家说的很明白）。\n### 解码\n解码其实就是将图片的二进制数据转换成像素数据。这个过程是比较耗时的，不能使用 GPU 硬解码，只能通过 CPU 软解码实现（硬解码是通过解码电路实现，软解码是通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码）。解码后的文件大小计算公式\n> 解压缩后的图片大小 = 图片的像素宽  * 图片的像素高  * 每个像素所占的字节数 (4)\n\n每个像素所占的字节数为什么是4呢？因为我们所使用的位图大部分是32位的RGBA模式，这种模式位图的一个像素所占内存为32位，也就是4个字节的长度 。[出处在此](https://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use)\n所以，本地保存的32KB的图片，解码就是168KB了。（解压缩后的数据）\n![恍然大悟.jpg](https://upload-images.jianshu.io/upload_images/2855070-2e399ff3e5457a17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 压缩图片\n不过分享某一张图片的时候，我用`UIImageJPEGRepresentation`方法压缩不到128KB一下？？？什么图片这么大？后来问一下后台才知道，这张图片是相机拍摄的，尺寸非常大，只能重新设置图片尺寸。献上我的代码\n```\n\nfunc compressImage(_ image: UIImage, toByte maxLength: Int) -> Data?{\n    var compression: CGFloat = 1\n\n    var data = UIImageJPEGRepresentation(image, compression)!\n        if data.count <= maxLength {\n        return data\n    }\n\n    var max: CGFloat = 1\n    var min: CGFloat = 0\n\n    let newSize = CGSize.init(width: 200, height: 160)\n    UIGraphicsBeginImageContext(newSize)\n    image.draw(in: CGRect.init(x: 0, y: 0, width: newSize.width, height: newSize.height))\n    let newImage = UIGraphicsGetImageFromCurrentImageContext()!\n    UIGraphicsEndImageContext()\n    data = UIImageJPEGRepresentation(newImage, 1.0)!\n    if data.count <= maxLength {\n        return data\n    }\n\n    for _ in 0..<10 {\n        compression = (max + min) / 2\n        data = UIImageJPEGRepresentation(newImage, compression)!\n\n        if CGFloat(data.count) < CGFloat(maxLength) * 0.9 {\n            min = compression\n        } else if data.count > maxLength {\n            max = compression\n        } else {\n            break\n        }\n    }\n\n    return data\n}\n\n```\n## 图片加载\n通常我们说图片加载会用到两种方法：`imageNamed `、`imageWithContentsOfFile `，我们简单介绍这两种方法\n### imageNamed\n该方法的特点在于可以缓存已经加载的图片；使用时，先根据文件名在系统缓存中寻找图片，如果找到了就返回；如果没有，就在`Bundle`内查找到文件名，找到后把这个文件名放到`UIImage`里返回，并没有进行实际的文件读取和解码。当`UIImage`第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。\n### imageWithContentsOfFile\n该方法仅加载图片，不缓存图像数据，其解码依然要等到第一次显示该图片的时候。\n对于这两种方法，我们可以做出如下比较：\n- 本地（Assets）保存的图标加载使用`imageNamed`\n- 经常使用且文件不大的图片使用`imageNamed`\n- 对于一些文件较大的图片使用`imageWithContentsOfFile`，当然最好的办法是用`UIGraphicsBeginImageContext`方法重新绘制图片\n\n此外，在 WWDC 2018上，苹果为我们建议了一种大家平时使用较少的大图加载方式，它的实际占用内存与理论值最为接近。\n```\nfunc downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -> UIImage\n{\n    let sourceOpt = [kCGImageSourceShouldCache : false] as  CFDictionary\n// 其他场景可以用createwithdata (data并未decode,所占内存没那么大),\n    let source = CGImageSourceCreateWithURL(imageURL as CFURL, sourceOpt)!\n\n    let maxDimension = max(pointSize.width, pointSize.height) * scale\n    let downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : true,\n                         kCGImageSourceShouldCacheImmediately : true ,\n                         kCGImageSourceCreateThumbnailWithTransform : true,\n                         kCGImageSourceThumbnailMaxPixelSize : maxDimension] as CFDictionary\n    let downsampleImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOpt)!\n    return UIImage(cgImage: downsampleImage)\n}\n```\n## 参考\n[iOS图片加载速度极限优化—FastImageCache解析](http://blog.cnbang.net/tech/2578/)\n[谈谈 iOS 中图片的解压缩](http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina)\n[iOS中的图片使用方式、内存对比和最佳实践](https://juejin.im/post/5b2ddfa7e51d4553156be305)\n\n\n\n\n\n","source":"_posts/一张图片引发的思考.md","raw":"---\ntitle: 一张图片引发的思考\ndate: 2018-10-18 14:09:38\ntags: 其它\n---\n## 背景：\n前段时间做微信小程序分享，用了某家的SDK，然鹅......他们家SDK只能上传`png`、`jpeg`格式的图片，微信不是可以上传`Data`吗？？？？\n![???.jpeg](https://upload-images.jianshu.io/upload_images/2855070-1e640864e3ce90f4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我吭哧吭哧半天用`UIImageJPEGRepresentation`压缩图片，然后在生成图片，也没把图片传上去。我当时想肯定是图片大小有问题，因为微信限制128KB以内。我查看保存在沙盒里的图片才32KB啊？？怎么会上传不上去呢？再查看`Image`的`Data`大小，噗~~~168KB。好吧，我被打败了。最后还是用微信原生SDK才搞定，直接传一个`Data`过去，多开心，多easy。\n## 正文\n好的，扯了这么多，其实就是想说一下为啥会有今天这篇大水文。在解决问题的过程中，我对iOS加载图片的理解稍微深入了那么一丢丢。现在，就水一下我理解的那么一丢丢东西。\n### 图片经过哪些流程加载到屏幕上\n1. 从磁盘拷贝数据到内核缓冲区\n2. 从内核缓冲区复制数据到用户空间（内存级别拷贝）\n3. 生成`UIImage`，把`UIImage`赋值给`UIImageView`\n4. 如果图像数据为未解码的PNG/JPG，解码为位图数据\n5. 隐式`CATransaction`捕获到`UIImageView`图层树的变化\n6. 主线程`Runloop`提交`CATransaction`，开始进行图像渲染\n6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐\n6.2 GPU处理位图数据，进行渲染\n\n其中第四点就是导致我32KB变168KB的“罪魁祸首”。为啥这么说呢？先了解一些东西。\n\n### PNG\n`PNG`只支持无损压缩，所以它的压缩比是有上限的。它有`alpha`通道，支持图片透明。此外xcode会对png格式进行特殊的优化处理，而对于其他图片不做处理，所以我们一些小图标经常用`PNG`。\n#### JPEG\n`JPEG`支持有损压缩，不含有`alpha`通道，它可以通过图片质量换取内存空间。网络图片最好选用`JPEG`，可以节省流量、提高下载速度。\n### 位图\n我们是否可以直接使用图片，使其显示在屏幕上呢？答案显然后__不可以__。图片经过解压后，变成位图数据。那么[位图](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3)是什么呢?苹果给出的解释是\n> A bitmap image (or sampled image) is an array of pixels (or samples)\n\n位图是一个像素数组。至于怎么将像素绘制到屏幕上，可以看[这篇文章](https://objccn.io/issue-3-1/)，就不做过多叙述（人家说的很明白）。\n### 解码\n解码其实就是将图片的二进制数据转换成像素数据。这个过程是比较耗时的，不能使用 GPU 硬解码，只能通过 CPU 软解码实现（硬解码是通过解码电路实现，软解码是通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码）。解码后的文件大小计算公式\n> 解压缩后的图片大小 = 图片的像素宽  * 图片的像素高  * 每个像素所占的字节数 (4)\n\n每个像素所占的字节数为什么是4呢？因为我们所使用的位图大部分是32位的RGBA模式，这种模式位图的一个像素所占内存为32位，也就是4个字节的长度 。[出处在此](https://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use)\n所以，本地保存的32KB的图片，解码就是168KB了。（解压缩后的数据）\n![恍然大悟.jpg](https://upload-images.jianshu.io/upload_images/2855070-2e399ff3e5457a17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 压缩图片\n不过分享某一张图片的时候，我用`UIImageJPEGRepresentation`方法压缩不到128KB一下？？？什么图片这么大？后来问一下后台才知道，这张图片是相机拍摄的，尺寸非常大，只能重新设置图片尺寸。献上我的代码\n```\n\nfunc compressImage(_ image: UIImage, toByte maxLength: Int) -> Data?{\n    var compression: CGFloat = 1\n\n    var data = UIImageJPEGRepresentation(image, compression)!\n        if data.count <= maxLength {\n        return data\n    }\n\n    var max: CGFloat = 1\n    var min: CGFloat = 0\n\n    let newSize = CGSize.init(width: 200, height: 160)\n    UIGraphicsBeginImageContext(newSize)\n    image.draw(in: CGRect.init(x: 0, y: 0, width: newSize.width, height: newSize.height))\n    let newImage = UIGraphicsGetImageFromCurrentImageContext()!\n    UIGraphicsEndImageContext()\n    data = UIImageJPEGRepresentation(newImage, 1.0)!\n    if data.count <= maxLength {\n        return data\n    }\n\n    for _ in 0..<10 {\n        compression = (max + min) / 2\n        data = UIImageJPEGRepresentation(newImage, compression)!\n\n        if CGFloat(data.count) < CGFloat(maxLength) * 0.9 {\n            min = compression\n        } else if data.count > maxLength {\n            max = compression\n        } else {\n            break\n        }\n    }\n\n    return data\n}\n\n```\n## 图片加载\n通常我们说图片加载会用到两种方法：`imageNamed `、`imageWithContentsOfFile `，我们简单介绍这两种方法\n### imageNamed\n该方法的特点在于可以缓存已经加载的图片；使用时，先根据文件名在系统缓存中寻找图片，如果找到了就返回；如果没有，就在`Bundle`内查找到文件名，找到后把这个文件名放到`UIImage`里返回，并没有进行实际的文件读取和解码。当`UIImage`第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。\n### imageWithContentsOfFile\n该方法仅加载图片，不缓存图像数据，其解码依然要等到第一次显示该图片的时候。\n对于这两种方法，我们可以做出如下比较：\n- 本地（Assets）保存的图标加载使用`imageNamed`\n- 经常使用且文件不大的图片使用`imageNamed`\n- 对于一些文件较大的图片使用`imageWithContentsOfFile`，当然最好的办法是用`UIGraphicsBeginImageContext`方法重新绘制图片\n\n此外，在 WWDC 2018上，苹果为我们建议了一种大家平时使用较少的大图加载方式，它的实际占用内存与理论值最为接近。\n```\nfunc downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -> UIImage\n{\n    let sourceOpt = [kCGImageSourceShouldCache : false] as  CFDictionary\n// 其他场景可以用createwithdata (data并未decode,所占内存没那么大),\n    let source = CGImageSourceCreateWithURL(imageURL as CFURL, sourceOpt)!\n\n    let maxDimension = max(pointSize.width, pointSize.height) * scale\n    let downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : true,\n                         kCGImageSourceShouldCacheImmediately : true ,\n                         kCGImageSourceCreateThumbnailWithTransform : true,\n                         kCGImageSourceThumbnailMaxPixelSize : maxDimension] as CFDictionary\n    let downsampleImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOpt)!\n    return UIImage(cgImage: downsampleImage)\n}\n```\n## 参考\n[iOS图片加载速度极限优化—FastImageCache解析](http://blog.cnbang.net/tech/2578/)\n[谈谈 iOS 中图片的解压缩](http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina)\n[iOS中的图片使用方式、内存对比和最佳实践](https://juejin.im/post/5b2ddfa7e51d4553156be305)\n\n\n\n\n\n","slug":"一张图片引发的思考","published":1,"updated":"2018-10-19T07:16:01.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0los000eimcwtcudkmy9","content":"<h2 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h2><p>前段时间做微信小程序分享，用了某家的SDK，然鹅……他们家SDK只能上传<code>png</code>、<code>jpeg</code>格式的图片，微信不是可以上传<code>Data</code>吗？？？？<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-1e640864e3ce90f4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"???.jpeg\"><br>我吭哧吭哧半天用<code>UIImageJPEGRepresentation</code>压缩图片，然后在生成图片，也没把图片传上去。我当时想肯定是图片大小有问题，因为微信限制128KB以内。我查看保存在沙盒里的图片才32KB啊？？怎么会上传不上去呢？再查看<code>Image</code>的<code>Data</code>大小，噗~~~168KB。好吧，我被打败了。最后还是用微信原生SDK才搞定，直接传一个<code>Data</code>过去，多开心，多easy。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>好的，扯了这么多，其实就是想说一下为啥会有今天这篇大水文。在解决问题的过程中，我对iOS加载图片的理解稍微深入了那么一丢丢。现在，就水一下我理解的那么一丢丢东西。</p>\n<h3 id=\"图片经过哪些流程加载到屏幕上\"><a href=\"#图片经过哪些流程加载到屏幕上\" class=\"headerlink\" title=\"图片经过哪些流程加载到屏幕上\"></a>图片经过哪些流程加载到屏幕上</h3><ol>\n<li>从磁盘拷贝数据到内核缓冲区</li>\n<li>从内核缓冲区复制数据到用户空间（内存级别拷贝）</li>\n<li>生成<code>UIImage</code>，把<code>UIImage</code>赋值给<code>UIImageView</code></li>\n<li>如果图像数据为未解码的PNG/JPG，解码为位图数据</li>\n<li>隐式<code>CATransaction</code>捕获到<code>UIImageView</code>图层树的变化</li>\n<li>主线程<code>Runloop</code>提交<code>CATransaction</code>，开始进行图像渲染<br>6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐<br>6.2 GPU处理位图数据，进行渲染</li>\n</ol>\n<p>其中第四点就是导致我32KB变168KB的“罪魁祸首”。为啥这么说呢？先了解一些东西。</p>\n<h3 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h3><p><code>PNG</code>只支持无损压缩，所以它的压缩比是有上限的。它有<code>alpha</code>通道，支持图片透明。此外xcode会对png格式进行特殊的优化处理，而对于其他图片不做处理，所以我们一些小图标经常用<code>PNG</code>。</p>\n<h4 id=\"JPEG\"><a href=\"#JPEG\" class=\"headerlink\" title=\"JPEG\"></a>JPEG</h4><p><code>JPEG</code>支持有损压缩，不含有<code>alpha</code>通道，它可以通过图片质量换取内存空间。网络图片最好选用<code>JPEG</code>，可以节省流量、提高下载速度。</p>\n<h3 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h3><p>我们是否可以直接使用图片，使其显示在屏幕上呢？答案显然后<strong>不可以</strong>。图片经过解压后，变成位图数据。那么<a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3\" target=\"_blank\" rel=\"noopener\">位图</a>是什么呢?苹果给出的解释是</p>\n<blockquote>\n<p>A bitmap image (or sampled image) is an array of pixels (or samples)</p>\n</blockquote>\n<p>位图是一个像素数组。至于怎么将像素绘制到屏幕上，可以看<a href=\"https://objccn.io/issue-3-1/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，就不做过多叙述（人家说的很明白）。</p>\n<h3 id=\"解码\"><a href=\"#解码\" class=\"headerlink\" title=\"解码\"></a>解码</h3><p>解码其实就是将图片的二进制数据转换成像素数据。这个过程是比较耗时的，不能使用 GPU 硬解码，只能通过 CPU 软解码实现（硬解码是通过解码电路实现，软解码是通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码）。解码后的文件大小计算公式</p>\n<blockquote>\n<p>解压缩后的图片大小 = 图片的像素宽  <em> 图片的像素高  </em> 每个像素所占的字节数 (4)</p>\n</blockquote>\n<p>每个像素所占的字节数为什么是4呢？因为我们所使用的位图大部分是32位的RGBA模式，这种模式位图的一个像素所占内存为32位，也就是4个字节的长度 。<a href=\"https://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use\" target=\"_blank\" rel=\"noopener\">出处在此</a><br>所以，本地保存的32KB的图片，解码就是168KB了。（解压缩后的数据）<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-2e399ff3e5457a17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"恍然大悟.jpg\"></p>\n<h3 id=\"压缩图片\"><a href=\"#压缩图片\" class=\"headerlink\" title=\"压缩图片\"></a>压缩图片</h3><p>不过分享某一张图片的时候，我用<code>UIImageJPEGRepresentation</code>方法压缩不到128KB一下？？？什么图片这么大？后来问一下后台才知道，这张图片是相机拍摄的，尺寸非常大，只能重新设置图片尺寸。献上我的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">func compressImage(_ image: UIImage, toByte maxLength: Int) -&gt; Data?&#123;</span><br><span class=\"line\">    var compression: CGFloat = 1</span><br><span class=\"line\"></span><br><span class=\"line\">    var data = UIImageJPEGRepresentation(image, compression)!</span><br><span class=\"line\">        if data.count &lt;= maxLength &#123;</span><br><span class=\"line\">        return data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var max: CGFloat = 1</span><br><span class=\"line\">    var min: CGFloat = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    let newSize = CGSize.init(width: 200, height: 160)</span><br><span class=\"line\">    UIGraphicsBeginImageContext(newSize)</span><br><span class=\"line\">    image.draw(in: CGRect.init(x: 0, y: 0, width: newSize.width, height: newSize.height))</span><br><span class=\"line\">    let newImage = UIGraphicsGetImageFromCurrentImageContext()!</span><br><span class=\"line\">    UIGraphicsEndImageContext()</span><br><span class=\"line\">    data = UIImageJPEGRepresentation(newImage, 1.0)!</span><br><span class=\"line\">    if data.count &lt;= maxLength &#123;</span><br><span class=\"line\">        return data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for _ in 0..&lt;10 &#123;</span><br><span class=\"line\">        compression = (max + min) / 2</span><br><span class=\"line\">        data = UIImageJPEGRepresentation(newImage, compression)!</span><br><span class=\"line\"></span><br><span class=\"line\">        if CGFloat(data.count) &lt; CGFloat(maxLength) * 0.9 &#123;</span><br><span class=\"line\">            min = compression</span><br><span class=\"line\">        &#125; else if data.count &gt; maxLength &#123;</span><br><span class=\"line\">            max = compression</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            break</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return data</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"图片加载\"><a href=\"#图片加载\" class=\"headerlink\" title=\"图片加载\"></a>图片加载</h2><p>通常我们说图片加载会用到两种方法：<code>imageNamed</code>、<code>imageWithContentsOfFile</code>，我们简单介绍这两种方法</p>\n<h3 id=\"imageNamed\"><a href=\"#imageNamed\" class=\"headerlink\" title=\"imageNamed\"></a>imageNamed</h3><p>该方法的特点在于可以缓存已经加载的图片；使用时，先根据文件名在系统缓存中寻找图片，如果找到了就返回；如果没有，就在<code>Bundle</code>内查找到文件名，找到后把这个文件名放到<code>UIImage</code>里返回，并没有进行实际的文件读取和解码。当<code>UIImage</code>第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。</p>\n<h3 id=\"imageWithContentsOfFile\"><a href=\"#imageWithContentsOfFile\" class=\"headerlink\" title=\"imageWithContentsOfFile\"></a>imageWithContentsOfFile</h3><p>该方法仅加载图片，不缓存图像数据，其解码依然要等到第一次显示该图片的时候。<br>对于这两种方法，我们可以做出如下比较：</p>\n<ul>\n<li>本地（Assets）保存的图标加载使用<code>imageNamed</code></li>\n<li>经常使用且文件不大的图片使用<code>imageNamed</code></li>\n<li>对于一些文件较大的图片使用<code>imageWithContentsOfFile</code>，当然最好的办法是用<code>UIGraphicsBeginImageContext</code>方法重新绘制图片</li>\n</ul>\n<p>此外，在 WWDC 2018上，苹果为我们建议了一种大家平时使用较少的大图加载方式，它的实际占用内存与理论值最为接近。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -&gt; UIImage</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let sourceOpt = [kCGImageSourceShouldCache : false] as  CFDictionary</span><br><span class=\"line\">// 其他场景可以用createwithdata (data并未decode,所占内存没那么大),</span><br><span class=\"line\">    let source = CGImageSourceCreateWithURL(imageURL as CFURL, sourceOpt)!</span><br><span class=\"line\"></span><br><span class=\"line\">    let maxDimension = max(pointSize.width, pointSize.height) * scale</span><br><span class=\"line\">    let downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : true,</span><br><span class=\"line\">                         kCGImageSourceShouldCacheImmediately : true ,</span><br><span class=\"line\">                         kCGImageSourceCreateThumbnailWithTransform : true,</span><br><span class=\"line\">                         kCGImageSourceThumbnailMaxPixelSize : maxDimension] as CFDictionary</span><br><span class=\"line\">    let downsampleImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOpt)!</span><br><span class=\"line\">    return UIImage(cgImage: downsampleImage)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.cnbang.net/tech/2578/\" target=\"_blank\" rel=\"noopener\">iOS图片加载速度极限优化—FastImageCache解析</a><br><a href=\"http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina\" target=\"_blank\" rel=\"noopener\">谈谈 iOS 中图片的解压缩</a><br><a href=\"https://juejin.im/post/5b2ddfa7e51d4553156be305\" target=\"_blank\" rel=\"noopener\">iOS中的图片使用方式、内存对比和最佳实践</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h2><p>前段时间做微信小程序分享，用了某家的SDK，然鹅……他们家SDK只能上传<code>png</code>、<code>jpeg</code>格式的图片，微信不是可以上传<code>Data</code>吗？？？？<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-1e640864e3ce90f4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"???.jpeg\"><br>我吭哧吭哧半天用<code>UIImageJPEGRepresentation</code>压缩图片，然后在生成图片，也没把图片传上去。我当时想肯定是图片大小有问题，因为微信限制128KB以内。我查看保存在沙盒里的图片才32KB啊？？怎么会上传不上去呢？再查看<code>Image</code>的<code>Data</code>大小，噗~~~168KB。好吧，我被打败了。最后还是用微信原生SDK才搞定，直接传一个<code>Data</code>过去，多开心，多easy。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>好的，扯了这么多，其实就是想说一下为啥会有今天这篇大水文。在解决问题的过程中，我对iOS加载图片的理解稍微深入了那么一丢丢。现在，就水一下我理解的那么一丢丢东西。</p>\n<h3 id=\"图片经过哪些流程加载到屏幕上\"><a href=\"#图片经过哪些流程加载到屏幕上\" class=\"headerlink\" title=\"图片经过哪些流程加载到屏幕上\"></a>图片经过哪些流程加载到屏幕上</h3><ol>\n<li>从磁盘拷贝数据到内核缓冲区</li>\n<li>从内核缓冲区复制数据到用户空间（内存级别拷贝）</li>\n<li>生成<code>UIImage</code>，把<code>UIImage</code>赋值给<code>UIImageView</code></li>\n<li>如果图像数据为未解码的PNG/JPG，解码为位图数据</li>\n<li>隐式<code>CATransaction</code>捕获到<code>UIImageView</code>图层树的变化</li>\n<li>主线程<code>Runloop</code>提交<code>CATransaction</code>，开始进行图像渲染<br>6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐<br>6.2 GPU处理位图数据，进行渲染</li>\n</ol>\n<p>其中第四点就是导致我32KB变168KB的“罪魁祸首”。为啥这么说呢？先了解一些东西。</p>\n<h3 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h3><p><code>PNG</code>只支持无损压缩，所以它的压缩比是有上限的。它有<code>alpha</code>通道，支持图片透明。此外xcode会对png格式进行特殊的优化处理，而对于其他图片不做处理，所以我们一些小图标经常用<code>PNG</code>。</p>\n<h4 id=\"JPEG\"><a href=\"#JPEG\" class=\"headerlink\" title=\"JPEG\"></a>JPEG</h4><p><code>JPEG</code>支持有损压缩，不含有<code>alpha</code>通道，它可以通过图片质量换取内存空间。网络图片最好选用<code>JPEG</code>，可以节省流量、提高下载速度。</p>\n<h3 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h3><p>我们是否可以直接使用图片，使其显示在屏幕上呢？答案显然后<strong>不可以</strong>。图片经过解压后，变成位图数据。那么<a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3\" target=\"_blank\" rel=\"noopener\">位图</a>是什么呢?苹果给出的解释是</p>\n<blockquote>\n<p>A bitmap image (or sampled image) is an array of pixels (or samples)</p>\n</blockquote>\n<p>位图是一个像素数组。至于怎么将像素绘制到屏幕上，可以看<a href=\"https://objccn.io/issue-3-1/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，就不做过多叙述（人家说的很明白）。</p>\n<h3 id=\"解码\"><a href=\"#解码\" class=\"headerlink\" title=\"解码\"></a>解码</h3><p>解码其实就是将图片的二进制数据转换成像素数据。这个过程是比较耗时的，不能使用 GPU 硬解码，只能通过 CPU 软解码实现（硬解码是通过解码电路实现，软解码是通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码）。解码后的文件大小计算公式</p>\n<blockquote>\n<p>解压缩后的图片大小 = 图片的像素宽  <em> 图片的像素高  </em> 每个像素所占的字节数 (4)</p>\n</blockquote>\n<p>每个像素所占的字节数为什么是4呢？因为我们所使用的位图大部分是32位的RGBA模式，这种模式位图的一个像素所占内存为32位，也就是4个字节的长度 。<a href=\"https://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use\" target=\"_blank\" rel=\"noopener\">出处在此</a><br>所以，本地保存的32KB的图片，解码就是168KB了。（解压缩后的数据）<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-2e399ff3e5457a17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"恍然大悟.jpg\"></p>\n<h3 id=\"压缩图片\"><a href=\"#压缩图片\" class=\"headerlink\" title=\"压缩图片\"></a>压缩图片</h3><p>不过分享某一张图片的时候，我用<code>UIImageJPEGRepresentation</code>方法压缩不到128KB一下？？？什么图片这么大？后来问一下后台才知道，这张图片是相机拍摄的，尺寸非常大，只能重新设置图片尺寸。献上我的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">func compressImage(_ image: UIImage, toByte maxLength: Int) -&gt; Data?&#123;</span><br><span class=\"line\">    var compression: CGFloat = 1</span><br><span class=\"line\"></span><br><span class=\"line\">    var data = UIImageJPEGRepresentation(image, compression)!</span><br><span class=\"line\">        if data.count &lt;= maxLength &#123;</span><br><span class=\"line\">        return data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var max: CGFloat = 1</span><br><span class=\"line\">    var min: CGFloat = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    let newSize = CGSize.init(width: 200, height: 160)</span><br><span class=\"line\">    UIGraphicsBeginImageContext(newSize)</span><br><span class=\"line\">    image.draw(in: CGRect.init(x: 0, y: 0, width: newSize.width, height: newSize.height))</span><br><span class=\"line\">    let newImage = UIGraphicsGetImageFromCurrentImageContext()!</span><br><span class=\"line\">    UIGraphicsEndImageContext()</span><br><span class=\"line\">    data = UIImageJPEGRepresentation(newImage, 1.0)!</span><br><span class=\"line\">    if data.count &lt;= maxLength &#123;</span><br><span class=\"line\">        return data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for _ in 0..&lt;10 &#123;</span><br><span class=\"line\">        compression = (max + min) / 2</span><br><span class=\"line\">        data = UIImageJPEGRepresentation(newImage, compression)!</span><br><span class=\"line\"></span><br><span class=\"line\">        if CGFloat(data.count) &lt; CGFloat(maxLength) * 0.9 &#123;</span><br><span class=\"line\">            min = compression</span><br><span class=\"line\">        &#125; else if data.count &gt; maxLength &#123;</span><br><span class=\"line\">            max = compression</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            break</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return data</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"图片加载\"><a href=\"#图片加载\" class=\"headerlink\" title=\"图片加载\"></a>图片加载</h2><p>通常我们说图片加载会用到两种方法：<code>imageNamed</code>、<code>imageWithContentsOfFile</code>，我们简单介绍这两种方法</p>\n<h3 id=\"imageNamed\"><a href=\"#imageNamed\" class=\"headerlink\" title=\"imageNamed\"></a>imageNamed</h3><p>该方法的特点在于可以缓存已经加载的图片；使用时，先根据文件名在系统缓存中寻找图片，如果找到了就返回；如果没有，就在<code>Bundle</code>内查找到文件名，找到后把这个文件名放到<code>UIImage</code>里返回，并没有进行实际的文件读取和解码。当<code>UIImage</code>第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。</p>\n<h3 id=\"imageWithContentsOfFile\"><a href=\"#imageWithContentsOfFile\" class=\"headerlink\" title=\"imageWithContentsOfFile\"></a>imageWithContentsOfFile</h3><p>该方法仅加载图片，不缓存图像数据，其解码依然要等到第一次显示该图片的时候。<br>对于这两种方法，我们可以做出如下比较：</p>\n<ul>\n<li>本地（Assets）保存的图标加载使用<code>imageNamed</code></li>\n<li>经常使用且文件不大的图片使用<code>imageNamed</code></li>\n<li>对于一些文件较大的图片使用<code>imageWithContentsOfFile</code>，当然最好的办法是用<code>UIGraphicsBeginImageContext</code>方法重新绘制图片</li>\n</ul>\n<p>此外，在 WWDC 2018上，苹果为我们建议了一种大家平时使用较少的大图加载方式，它的实际占用内存与理论值最为接近。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -&gt; UIImage</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let sourceOpt = [kCGImageSourceShouldCache : false] as  CFDictionary</span><br><span class=\"line\">// 其他场景可以用createwithdata (data并未decode,所占内存没那么大),</span><br><span class=\"line\">    let source = CGImageSourceCreateWithURL(imageURL as CFURL, sourceOpt)!</span><br><span class=\"line\"></span><br><span class=\"line\">    let maxDimension = max(pointSize.width, pointSize.height) * scale</span><br><span class=\"line\">    let downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : true,</span><br><span class=\"line\">                         kCGImageSourceShouldCacheImmediately : true ,</span><br><span class=\"line\">                         kCGImageSourceCreateThumbnailWithTransform : true,</span><br><span class=\"line\">                         kCGImageSourceThumbnailMaxPixelSize : maxDimension] as CFDictionary</span><br><span class=\"line\">    let downsampleImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOpt)!</span><br><span class=\"line\">    return UIImage(cgImage: downsampleImage)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.cnbang.net/tech/2578/\" target=\"_blank\" rel=\"noopener\">iOS图片加载速度极限优化—FastImageCache解析</a><br><a href=\"http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina\" target=\"_blank\" rel=\"noopener\">谈谈 iOS 中图片的解压缩</a><br><a href=\"https://juejin.im/post/5b2ddfa7e51d4553156be305\" target=\"_blank\" rel=\"noopener\">iOS中的图片使用方式、内存对比和最佳实践</a></p>\n"},{"title":"RxSwift Observable&Observer和辅助类型","date":"2018-09-22T15:49:42.000Z","_content":"在我们日常开发中，有一些既可是`Observable`又可是`Observer`。举个🌰：\n```\nlet observable = textField.rx.text\nobservable.subscribe(onNext: { text in show(text: text) })\n```\n在这行代码中，`textField`当前文本就是一个`Observable`，当用户在`textField`中输入时，就会`show`文本内容。\n再举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet observer = textField.rx.text\nlet observable = Observable<String>.just(\"A\")\nobservable.bind(to: observer)\n        .disposed(by: disposeBag)\n```\n这个时候，屏幕上就会显示：\n![textField.png](https://upload-images.jianshu.io/upload_images/2855070-a113479a0f2d92f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时，`textField`的当前文本就是`Observer`。\n此外，框架中还有一些辅助类型，既可是`Observable`又可是`Observer`。\n#### 1. AsyncSubject\n`AsyncSubject `将在`Observable`产生完成事件后，发出最后一个元素（仅仅只有最后一个元素）。如果`Observable`没有发出任何元素，只有一个完成事件，那`AsyncSubject`也只有一个完成事件。如果`Observable`因`error`中止，那么`AsyncSubject`只会将`error`发送出来，不会发出其它元素。\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建一个AsyncSubject\nlet subject = AsyncSubject<String>()\n//订阅subject\nsubject.subscribe{ print($0) }\n    .disposed(by: disposeBag)\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\nsubject.onCompleted()\n```\n这个时候输出：\n```\nnext(D)\ncompleted\n```\n\n此时我们再改造一下：\n```\nlet subject = AsyncSubject<String>()\nsubject.subscribe{ print($0) }\n    .disposed(by: disposeBag)\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\n//SubjectError 自己定义的enum Error\nsubject.onError(SubjectError.error)\n```\n就会输出：\n```\nerror(error)\n```\n#### 2. PublishSubject\n`PublishSubject`是将对观察者发送`订阅后产生的元素`，而在订阅前发出的元素将不会发送给观察者。\n- `PublishSubject`是最普通的`Subject`，它不需要初始值就能创建\n- `PublishSubject`的订阅者从他们开始订阅的时间点起，可以收到订阅后`Subject`发出的新`Event`，而不会收到他们在订阅前已发出的`Event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n//由于当前没有订阅，所以不输出\nsubject.onNext(\"🐶\")\n//第一次订阅\nsubject.subscribe(onNext: { (element) in\n    print(\"第一次订阅:\\(element)\")\n}, onCompleted: {\n    print(\"completed\")\n}).disposed(by: disposeBag)\n//当前有一个订阅，输出\nsubject.onNext(\"🐱\")\n\n//第二次订阅\nsubject.subscribe(onNext: { (element) in\n    print(\"第二次订阅:\\(element)\")\n}, onCompleted: {\n    print(\"completed\")\n}).disposed(by: disposeBag)\n//当前有两个订阅 输出\nsubject.onNext(\"🐹\")\n\n//结束subject\nsubject.onCompleted()\n//再次发出.next事件\nsubject.onNext(\"🐯\")\n```\n显示如下：\n```\n第一次订阅:🐱\n第一次订阅:🐹\n第二次订阅:🐹\n第一次订阅:completed\n第二次订阅:completed\n第三次订阅:completed\n```\n\n####  3. ReplaySubject\n`ReplaySubject`将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的`ReplaySubject`，有的只会将最新的n个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把`ReplaySubject`当作观察者来使用，注意不要在多个线程调用`onNext`,`onError`或`onCompleted`。这样会导致无序调用，将造成意想不到的结果。\n- `ReplaySubject`在创建时候需要设置一个`bufferSize`，表示它对于它发送过的`event`的缓存个数\n- 比如一个`ReplaySubject`的`bufferSize`设置为 2，它发出了 3 个`.next`的`event`，那么它会将后两个（最近的两个）`event`给缓存起来。此时如果有一个`subscriber`订阅了这个 `ReplaySubject`，那么这个`subscriber`就会立即收到前面缓存的两个`.next`的`event`\n- 如果一个`subscriber`订阅已经结束的`ReplaySubject`，除了会收到缓存的`.next`的`event`外，还会收到那个终结的`.error`或者`.complete`的`event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建\nlet subject = ReplaySubject<String>.create(bufferSize: 0)\n//第1次订阅subject\nsubject.subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\n//第二次订阅\nsubject.subscribe{ print(\"第二次订阅:\\($0)\" )}\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\n```\n输出结果：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n```\n当`bufferSize`改成1时，结果就变成了：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第二次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n\n```\n如果是2的话，结果就变成了：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第二次订阅:next(A)\n第二次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n```\n\n#### 4. BehaviorSubject\n`BehaviorSubject `会把`Observable `最新元素发出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果`Observable `因为`error`事件而中止，则不会发出任何元素，将`error`事件发出来。\n- `BehaviorSubject`需要通过一个默认初始值来创建\n- 当一个订阅者来订阅它的时候，这个订阅者会立即收到 `BehaviorSubjects`上一个发出的`event`。之后就跟正常的情况一样，它也会接收到`BehaviorSubject`之后发出的新的`event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建一个BehaviorSubject\nlet subject = BehaviorSubject.init(value: \"🐭\")\n//第一次订阅\nsubject.subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"🐯\")\n//发送error事件\nsubject.onError(NSError(domain: \"local\", code: 0, userInfo: nil))\n//第二次订阅\nsubject.subscribe{ print(\"第二次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n```\n输出结果：\n```\n第一次订阅:next(🐭)\n第一次订阅:next(🐯)\n第一次订阅:error(Error Domain=local Code=0 \"(null)\")\n第二次订阅:error(Error Domain=local Code=0 \"(null)\")\n```\n#### 4. Variable\n在`RxSwift`中，`Variable `相当于`Swift`中的`var`。\n- `Variable`其实就是对`BehaviorSubject`的封装，所以它也必须要通过一个默认的初始值进行创建。\n- `Variable`具有`BehaviorSubject`的功能，能够向它的订阅者发出上一个`event`以及之后新创建的`event`。\n- 不同的是，`Variable`还会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送`.complete`的`event`，不需要也不能手动给`Variables`发送`completed`或者`error`事件来结束它。\n- 简单地说就是`Variable`有一个`value`属性，我们改变这个`value`属性的值就相当于调用一般`Subjects`的`onNext()`方法，而这个最新的`onNext()`的值就被保存在`value`属性里了，直到我们再次修改它。\n- `Variables`本身没有`subscribe()`方法，但是所有`Subjects`都有一个`asObservable()`方法。我们可以使用这个方法返回这个`Variable`的`Observable`类型，拿到这个`Observable`类型我们就能订阅它了。\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet variable = Variable.init(\"A\")\nvariable.value = \"B\"\n//第一次订阅\nvariable.asObservable().subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//修改value\nvariable.value = \"C\"\n//第二次订阅\nvariable.asObservable().subscribe{ print(\"第二次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//修改value\nvariable.value = \"D\"\n```\n结果如下：\n```\n第一次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n第一次订阅:completed\n第二次订阅:completed\n```\n","source":"_posts/RxSwift-Observable-Observer和辅助类型.md","raw":"---\ntitle: RxSwift Observable&Observer和辅助类型\ndate: 2018-09-22 23:49:42\ntags: RxSwift\n---\n在我们日常开发中，有一些既可是`Observable`又可是`Observer`。举个🌰：\n```\nlet observable = textField.rx.text\nobservable.subscribe(onNext: { text in show(text: text) })\n```\n在这行代码中，`textField`当前文本就是一个`Observable`，当用户在`textField`中输入时，就会`show`文本内容。\n再举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet observer = textField.rx.text\nlet observable = Observable<String>.just(\"A\")\nobservable.bind(to: observer)\n        .disposed(by: disposeBag)\n```\n这个时候，屏幕上就会显示：\n![textField.png](https://upload-images.jianshu.io/upload_images/2855070-a113479a0f2d92f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时，`textField`的当前文本就是`Observer`。\n此外，框架中还有一些辅助类型，既可是`Observable`又可是`Observer`。\n#### 1. AsyncSubject\n`AsyncSubject `将在`Observable`产生完成事件后，发出最后一个元素（仅仅只有最后一个元素）。如果`Observable`没有发出任何元素，只有一个完成事件，那`AsyncSubject`也只有一个完成事件。如果`Observable`因`error`中止，那么`AsyncSubject`只会将`error`发送出来，不会发出其它元素。\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建一个AsyncSubject\nlet subject = AsyncSubject<String>()\n//订阅subject\nsubject.subscribe{ print($0) }\n    .disposed(by: disposeBag)\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\nsubject.onCompleted()\n```\n这个时候输出：\n```\nnext(D)\ncompleted\n```\n\n此时我们再改造一下：\n```\nlet subject = AsyncSubject<String>()\nsubject.subscribe{ print($0) }\n    .disposed(by: disposeBag)\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\n//SubjectError 自己定义的enum Error\nsubject.onError(SubjectError.error)\n```\n就会输出：\n```\nerror(error)\n```\n#### 2. PublishSubject\n`PublishSubject`是将对观察者发送`订阅后产生的元素`，而在订阅前发出的元素将不会发送给观察者。\n- `PublishSubject`是最普通的`Subject`，它不需要初始值就能创建\n- `PublishSubject`的订阅者从他们开始订阅的时间点起，可以收到订阅后`Subject`发出的新`Event`，而不会收到他们在订阅前已发出的`Event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n//由于当前没有订阅，所以不输出\nsubject.onNext(\"🐶\")\n//第一次订阅\nsubject.subscribe(onNext: { (element) in\n    print(\"第一次订阅:\\(element)\")\n}, onCompleted: {\n    print(\"completed\")\n}).disposed(by: disposeBag)\n//当前有一个订阅，输出\nsubject.onNext(\"🐱\")\n\n//第二次订阅\nsubject.subscribe(onNext: { (element) in\n    print(\"第二次订阅:\\(element)\")\n}, onCompleted: {\n    print(\"completed\")\n}).disposed(by: disposeBag)\n//当前有两个订阅 输出\nsubject.onNext(\"🐹\")\n\n//结束subject\nsubject.onCompleted()\n//再次发出.next事件\nsubject.onNext(\"🐯\")\n```\n显示如下：\n```\n第一次订阅:🐱\n第一次订阅:🐹\n第二次订阅:🐹\n第一次订阅:completed\n第二次订阅:completed\n第三次订阅:completed\n```\n\n####  3. ReplaySubject\n`ReplaySubject`将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的`ReplaySubject`，有的只会将最新的n个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把`ReplaySubject`当作观察者来使用，注意不要在多个线程调用`onNext`,`onError`或`onCompleted`。这样会导致无序调用，将造成意想不到的结果。\n- `ReplaySubject`在创建时候需要设置一个`bufferSize`，表示它对于它发送过的`event`的缓存个数\n- 比如一个`ReplaySubject`的`bufferSize`设置为 2，它发出了 3 个`.next`的`event`，那么它会将后两个（最近的两个）`event`给缓存起来。此时如果有一个`subscriber`订阅了这个 `ReplaySubject`，那么这个`subscriber`就会立即收到前面缓存的两个`.next`的`event`\n- 如果一个`subscriber`订阅已经结束的`ReplaySubject`，除了会收到缓存的`.next`的`event`外，还会收到那个终结的`.error`或者`.complete`的`event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建\nlet subject = ReplaySubject<String>.create(bufferSize: 0)\n//第1次订阅subject\nsubject.subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\n//第二次订阅\nsubject.subscribe{ print(\"第二次订阅:\\($0)\" )}\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\n```\n输出结果：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n```\n当`bufferSize`改成1时，结果就变成了：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第二次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n\n```\n如果是2的话，结果就变成了：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第二次订阅:next(A)\n第二次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n```\n\n#### 4. BehaviorSubject\n`BehaviorSubject `会把`Observable `最新元素发出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果`Observable `因为`error`事件而中止，则不会发出任何元素，将`error`事件发出来。\n- `BehaviorSubject`需要通过一个默认初始值来创建\n- 当一个订阅者来订阅它的时候，这个订阅者会立即收到 `BehaviorSubjects`上一个发出的`event`。之后就跟正常的情况一样，它也会接收到`BehaviorSubject`之后发出的新的`event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建一个BehaviorSubject\nlet subject = BehaviorSubject.init(value: \"🐭\")\n//第一次订阅\nsubject.subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"🐯\")\n//发送error事件\nsubject.onError(NSError(domain: \"local\", code: 0, userInfo: nil))\n//第二次订阅\nsubject.subscribe{ print(\"第二次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n```\n输出结果：\n```\n第一次订阅:next(🐭)\n第一次订阅:next(🐯)\n第一次订阅:error(Error Domain=local Code=0 \"(null)\")\n第二次订阅:error(Error Domain=local Code=0 \"(null)\")\n```\n#### 4. Variable\n在`RxSwift`中，`Variable `相当于`Swift`中的`var`。\n- `Variable`其实就是对`BehaviorSubject`的封装，所以它也必须要通过一个默认的初始值进行创建。\n- `Variable`具有`BehaviorSubject`的功能，能够向它的订阅者发出上一个`event`以及之后新创建的`event`。\n- 不同的是，`Variable`还会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送`.complete`的`event`，不需要也不能手动给`Variables`发送`completed`或者`error`事件来结束它。\n- 简单地说就是`Variable`有一个`value`属性，我们改变这个`value`属性的值就相当于调用一般`Subjects`的`onNext()`方法，而这个最新的`onNext()`的值就被保存在`value`属性里了，直到我们再次修改它。\n- `Variables`本身没有`subscribe()`方法，但是所有`Subjects`都有一个`asObservable()`方法。我们可以使用这个方法返回这个`Variable`的`Observable`类型，拿到这个`Observable`类型我们就能订阅它了。\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet variable = Variable.init(\"A\")\nvariable.value = \"B\"\n//第一次订阅\nvariable.asObservable().subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//修改value\nvariable.value = \"C\"\n//第二次订阅\nvariable.asObservable().subscribe{ print(\"第二次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//修改value\nvariable.value = \"D\"\n```\n结果如下：\n```\n第一次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n第一次订阅:completed\n第二次订阅:completed\n```\n","slug":"RxSwift-Observable-Observer和辅助类型","published":1,"updated":"2018-10-19T07:16:01.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0lub000mimcw6f8raqkq","content":"<p>在我们日常开发中，有一些既可是<code>Observable</code>又可是<code>Observer</code>。举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = textField.rx.text</span><br><span class=\"line\">observable.subscribe(onNext: &#123; text in show(text: text) &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在这行代码中，<code>textField</code>当前文本就是一个<code>Observable</code>，当用户在<code>textField</code>中输入时，就会<code>show</code>文本内容。<br>再举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let observer = textField.rx.text</span><br><span class=\"line\">let observable = Observable&lt;String&gt;.just(&quot;A&quot;)</span><br><span class=\"line\">observable.bind(to: observer)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>这个时候，屏幕上就会显示：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-a113479a0f2d92f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"textField.png\"><br>这时，<code>textField</code>的当前文本就是<code>Observer</code>。<br>此外，框架中还有一些辅助类型，既可是<code>Observable</code>又可是<code>Observer</code>。</p>\n<h4 id=\"1-AsyncSubject\"><a href=\"#1-AsyncSubject\" class=\"headerlink\" title=\"1. AsyncSubject\"></a>1. AsyncSubject</h4><p><code>AsyncSubject</code>将在<code>Observable</code>产生完成事件后，发出最后一个元素（仅仅只有最后一个元素）。如果<code>Observable</code>没有发出任何元素，只有一个完成事件，那<code>AsyncSubject</code>也只有一个完成事件。如果<code>Observable</code>因<code>error</code>中止，那么<code>AsyncSubject</code>只会将<code>error</code>发送出来，不会发出其它元素。<br>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建一个AsyncSubject</span><br><span class=\"line\">let subject = AsyncSubject&lt;String&gt;()</span><br><span class=\"line\">//订阅subject</span><br><span class=\"line\">subject.subscribe&#123; print($0) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">subject.onCompleted()</span><br></pre></td></tr></table></figure></p>\n<p>这个时候输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(D)</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<p>此时我们再改造一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let subject = AsyncSubject&lt;String&gt;()</span><br><span class=\"line\">subject.subscribe&#123; print($0) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">//SubjectError 自己定义的enum Error</span><br><span class=\"line\">subject.onError(SubjectError.error)</span><br></pre></td></tr></table></figure></p>\n<p>就会输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error(error)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-PublishSubject\"><a href=\"#2-PublishSubject\" class=\"headerlink\" title=\"2. PublishSubject\"></a>2. PublishSubject</h4><p><code>PublishSubject</code>是将对观察者发送<code>订阅后产生的元素</code>，而在订阅前发出的元素将不会发送给观察者。</p>\n<ul>\n<li><code>PublishSubject</code>是最普通的<code>Subject</code>，它不需要初始值就能创建</li>\n<li><code>PublishSubject</code>的订阅者从他们开始订阅的时间点起，可以收到订阅后<code>Subject</code>发出的新<code>Event</code>，而不会收到他们在订阅前已发出的<code>Event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">//由于当前没有订阅，所以不输出</span><br><span class=\"line\">subject.onNext(&quot;🐶&quot;)</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">subject.subscribe(onNext: &#123; (element) in</span><br><span class=\"line\">    print(&quot;第一次订阅:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;).disposed(by: disposeBag)</span><br><span class=\"line\">//当前有一个订阅，输出</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe(onNext: &#123; (element) in</span><br><span class=\"line\">    print(&quot;第二次订阅:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;).disposed(by: disposeBag)</span><br><span class=\"line\">//当前有两个订阅 输出</span><br><span class=\"line\">subject.onNext(&quot;🐹&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//结束subject</span><br><span class=\"line\">subject.onCompleted()</span><br><span class=\"line\">//再次发出.next事件</span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>显示如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:🐱</span><br><span class=\"line\">第一次订阅:🐹</span><br><span class=\"line\">第二次订阅:🐹</span><br><span class=\"line\">第一次订阅:completed</span><br><span class=\"line\">第二次订阅:completed</span><br><span class=\"line\">第三次订阅:completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-ReplaySubject\"><a href=\"#3-ReplaySubject\" class=\"headerlink\" title=\"3. ReplaySubject\"></a>3. ReplaySubject</h4><p><code>ReplaySubject</code>将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的<code>ReplaySubject</code>，有的只会将最新的n个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把<code>ReplaySubject</code>当作观察者来使用，注意不要在多个线程调用<code>onNext</code>,<code>onError</code>或<code>onCompleted</code>。这样会导致无序调用，将造成意想不到的结果。</p>\n<ul>\n<li><code>ReplaySubject</code>在创建时候需要设置一个<code>bufferSize</code>，表示它对于它发送过的<code>event</code>的缓存个数</li>\n<li>比如一个<code>ReplaySubject</code>的<code>bufferSize</code>设置为 2，它发出了 3 个<code>.next</code>的<code>event</code>，那么它会将后两个（最近的两个）<code>event</code>给缓存起来。此时如果有一个<code>subscriber</code>订阅了这个 <code>ReplaySubject</code>，那么这个<code>subscriber</code>就会立即收到前面缓存的两个<code>.next</code>的<code>event</code></li>\n<li>如果一个<code>subscriber</code>订阅已经结束的<code>ReplaySubject</code>，除了会收到缓存的<code>.next</code>的<code>event</code>外，还会收到那个终结的<code>.error</code>或者<code>.complete</code>的<code>event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建</span><br><span class=\"line\">let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 0)</span><br><span class=\"line\">//第1次订阅subject</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第二次订阅:\\($0)&quot; )&#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<p>当<code>bufferSize</code>改成1时，结果就变成了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第二次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<p>如果是2的话，结果就变成了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第二次订阅:next(A)</span><br><span class=\"line\">第二次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-BehaviorSubject\"><a href=\"#4-BehaviorSubject\" class=\"headerlink\" title=\"4. BehaviorSubject\"></a>4. BehaviorSubject</h4><p><code>BehaviorSubject</code>会把<code>Observable</code>最新元素发出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果<code>Observable</code>因为<code>error</code>事件而中止，则不会发出任何元素，将<code>error</code>事件发出来。</p>\n<ul>\n<li><code>BehaviorSubject</code>需要通过一个默认初始值来创建</li>\n<li>当一个订阅者来订阅它的时候，这个订阅者会立即收到 <code>BehaviorSubjects</code>上一个发出的<code>event</code>。之后就跟正常的情况一样，它也会接收到<code>BehaviorSubject</code>之后发出的新的<code>event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建一个BehaviorSubject</span><br><span class=\"line\">let subject = BehaviorSubject.init(value: &quot;🐭&quot;)</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">//发送error事件</span><br><span class=\"line\">subject.onError(NSError(domain: &quot;local&quot;, code: 0, userInfo: nil))</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第二次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(🐭)</span><br><span class=\"line\">第一次订阅:next(🐯)</span><br><span class=\"line\">第一次订阅:error(Error Domain=local Code=0 &quot;(null)&quot;)</span><br><span class=\"line\">第二次订阅:error(Error Domain=local Code=0 &quot;(null)&quot;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-Variable\"><a href=\"#4-Variable\" class=\"headerlink\" title=\"4. Variable\"></a>4. Variable</h4><p>在<code>RxSwift</code>中，<code>Variable</code>相当于<code>Swift</code>中的<code>var</code>。</p>\n<ul>\n<li><code>Variable</code>其实就是对<code>BehaviorSubject</code>的封装，所以它也必须要通过一个默认的初始值进行创建。</li>\n<li><code>Variable</code>具有<code>BehaviorSubject</code>的功能，能够向它的订阅者发出上一个<code>event</code>以及之后新创建的<code>event</code>。</li>\n<li>不同的是，<code>Variable</code>还会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送<code>.complete</code>的<code>event</code>，不需要也不能手动给<code>Variables</code>发送<code>completed</code>或者<code>error</code>事件来结束它。</li>\n<li>简单地说就是<code>Variable</code>有一个<code>value</code>属性，我们改变这个<code>value</code>属性的值就相当于调用一般<code>Subjects</code>的<code>onNext()</code>方法，而这个最新的<code>onNext()</code>的值就被保存在<code>value</code>属性里了，直到我们再次修改它。</li>\n<li><code>Variables</code>本身没有<code>subscribe()</code>方法，但是所有<code>Subjects</code>都有一个<code>asObservable()</code>方法。我们可以使用这个方法返回这个<code>Variable</code>的<code>Observable</code>类型，拿到这个<code>Observable</code>类型我们就能订阅它了。</li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let variable = Variable.init(&quot;A&quot;)</span><br><span class=\"line\">variable.value = &quot;B&quot;</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">variable.asObservable().subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//修改value</span><br><span class=\"line\">variable.value = &quot;C&quot;</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">variable.asObservable().subscribe&#123; print(&quot;第二次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//修改value</span><br><span class=\"line\">variable.value = &quot;D&quot;</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br><span class=\"line\">第一次订阅:completed</span><br><span class=\"line\">第二次订阅:completed</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在我们日常开发中，有一些既可是<code>Observable</code>又可是<code>Observer</code>。举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = textField.rx.text</span><br><span class=\"line\">observable.subscribe(onNext: &#123; text in show(text: text) &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在这行代码中，<code>textField</code>当前文本就是一个<code>Observable</code>，当用户在<code>textField</code>中输入时，就会<code>show</code>文本内容。<br>再举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let observer = textField.rx.text</span><br><span class=\"line\">let observable = Observable&lt;String&gt;.just(&quot;A&quot;)</span><br><span class=\"line\">observable.bind(to: observer)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>这个时候，屏幕上就会显示：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-a113479a0f2d92f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"textField.png\"><br>这时，<code>textField</code>的当前文本就是<code>Observer</code>。<br>此外，框架中还有一些辅助类型，既可是<code>Observable</code>又可是<code>Observer</code>。</p>\n<h4 id=\"1-AsyncSubject\"><a href=\"#1-AsyncSubject\" class=\"headerlink\" title=\"1. AsyncSubject\"></a>1. AsyncSubject</h4><p><code>AsyncSubject</code>将在<code>Observable</code>产生完成事件后，发出最后一个元素（仅仅只有最后一个元素）。如果<code>Observable</code>没有发出任何元素，只有一个完成事件，那<code>AsyncSubject</code>也只有一个完成事件。如果<code>Observable</code>因<code>error</code>中止，那么<code>AsyncSubject</code>只会将<code>error</code>发送出来，不会发出其它元素。<br>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建一个AsyncSubject</span><br><span class=\"line\">let subject = AsyncSubject&lt;String&gt;()</span><br><span class=\"line\">//订阅subject</span><br><span class=\"line\">subject.subscribe&#123; print($0) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">subject.onCompleted()</span><br></pre></td></tr></table></figure></p>\n<p>这个时候输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(D)</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<p>此时我们再改造一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let subject = AsyncSubject&lt;String&gt;()</span><br><span class=\"line\">subject.subscribe&#123; print($0) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">//SubjectError 自己定义的enum Error</span><br><span class=\"line\">subject.onError(SubjectError.error)</span><br></pre></td></tr></table></figure></p>\n<p>就会输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error(error)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-PublishSubject\"><a href=\"#2-PublishSubject\" class=\"headerlink\" title=\"2. PublishSubject\"></a>2. PublishSubject</h4><p><code>PublishSubject</code>是将对观察者发送<code>订阅后产生的元素</code>，而在订阅前发出的元素将不会发送给观察者。</p>\n<ul>\n<li><code>PublishSubject</code>是最普通的<code>Subject</code>，它不需要初始值就能创建</li>\n<li><code>PublishSubject</code>的订阅者从他们开始订阅的时间点起，可以收到订阅后<code>Subject</code>发出的新<code>Event</code>，而不会收到他们在订阅前已发出的<code>Event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">//由于当前没有订阅，所以不输出</span><br><span class=\"line\">subject.onNext(&quot;🐶&quot;)</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">subject.subscribe(onNext: &#123; (element) in</span><br><span class=\"line\">    print(&quot;第一次订阅:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;).disposed(by: disposeBag)</span><br><span class=\"line\">//当前有一个订阅，输出</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe(onNext: &#123; (element) in</span><br><span class=\"line\">    print(&quot;第二次订阅:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;).disposed(by: disposeBag)</span><br><span class=\"line\">//当前有两个订阅 输出</span><br><span class=\"line\">subject.onNext(&quot;🐹&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//结束subject</span><br><span class=\"line\">subject.onCompleted()</span><br><span class=\"line\">//再次发出.next事件</span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>显示如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:🐱</span><br><span class=\"line\">第一次订阅:🐹</span><br><span class=\"line\">第二次订阅:🐹</span><br><span class=\"line\">第一次订阅:completed</span><br><span class=\"line\">第二次订阅:completed</span><br><span class=\"line\">第三次订阅:completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-ReplaySubject\"><a href=\"#3-ReplaySubject\" class=\"headerlink\" title=\"3. ReplaySubject\"></a>3. ReplaySubject</h4><p><code>ReplaySubject</code>将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的<code>ReplaySubject</code>，有的只会将最新的n个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把<code>ReplaySubject</code>当作观察者来使用，注意不要在多个线程调用<code>onNext</code>,<code>onError</code>或<code>onCompleted</code>。这样会导致无序调用，将造成意想不到的结果。</p>\n<ul>\n<li><code>ReplaySubject</code>在创建时候需要设置一个<code>bufferSize</code>，表示它对于它发送过的<code>event</code>的缓存个数</li>\n<li>比如一个<code>ReplaySubject</code>的<code>bufferSize</code>设置为 2，它发出了 3 个<code>.next</code>的<code>event</code>，那么它会将后两个（最近的两个）<code>event</code>给缓存起来。此时如果有一个<code>subscriber</code>订阅了这个 <code>ReplaySubject</code>，那么这个<code>subscriber</code>就会立即收到前面缓存的两个<code>.next</code>的<code>event</code></li>\n<li>如果一个<code>subscriber</code>订阅已经结束的<code>ReplaySubject</code>，除了会收到缓存的<code>.next</code>的<code>event</code>外，还会收到那个终结的<code>.error</code>或者<code>.complete</code>的<code>event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建</span><br><span class=\"line\">let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 0)</span><br><span class=\"line\">//第1次订阅subject</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第二次订阅:\\($0)&quot; )&#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<p>当<code>bufferSize</code>改成1时，结果就变成了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第二次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<p>如果是2的话，结果就变成了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第二次订阅:next(A)</span><br><span class=\"line\">第二次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-BehaviorSubject\"><a href=\"#4-BehaviorSubject\" class=\"headerlink\" title=\"4. BehaviorSubject\"></a>4. BehaviorSubject</h4><p><code>BehaviorSubject</code>会把<code>Observable</code>最新元素发出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果<code>Observable</code>因为<code>error</code>事件而中止，则不会发出任何元素，将<code>error</code>事件发出来。</p>\n<ul>\n<li><code>BehaviorSubject</code>需要通过一个默认初始值来创建</li>\n<li>当一个订阅者来订阅它的时候，这个订阅者会立即收到 <code>BehaviorSubjects</code>上一个发出的<code>event</code>。之后就跟正常的情况一样，它也会接收到<code>BehaviorSubject</code>之后发出的新的<code>event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建一个BehaviorSubject</span><br><span class=\"line\">let subject = BehaviorSubject.init(value: &quot;🐭&quot;)</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">//发送error事件</span><br><span class=\"line\">subject.onError(NSError(domain: &quot;local&quot;, code: 0, userInfo: nil))</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第二次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(🐭)</span><br><span class=\"line\">第一次订阅:next(🐯)</span><br><span class=\"line\">第一次订阅:error(Error Domain=local Code=0 &quot;(null)&quot;)</span><br><span class=\"line\">第二次订阅:error(Error Domain=local Code=0 &quot;(null)&quot;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-Variable\"><a href=\"#4-Variable\" class=\"headerlink\" title=\"4. Variable\"></a>4. Variable</h4><p>在<code>RxSwift</code>中，<code>Variable</code>相当于<code>Swift</code>中的<code>var</code>。</p>\n<ul>\n<li><code>Variable</code>其实就是对<code>BehaviorSubject</code>的封装，所以它也必须要通过一个默认的初始值进行创建。</li>\n<li><code>Variable</code>具有<code>BehaviorSubject</code>的功能，能够向它的订阅者发出上一个<code>event</code>以及之后新创建的<code>event</code>。</li>\n<li>不同的是，<code>Variable</code>还会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送<code>.complete</code>的<code>event</code>，不需要也不能手动给<code>Variables</code>发送<code>completed</code>或者<code>error</code>事件来结束它。</li>\n<li>简单地说就是<code>Variable</code>有一个<code>value</code>属性，我们改变这个<code>value</code>属性的值就相当于调用一般<code>Subjects</code>的<code>onNext()</code>方法，而这个最新的<code>onNext()</code>的值就被保存在<code>value</code>属性里了，直到我们再次修改它。</li>\n<li><code>Variables</code>本身没有<code>subscribe()</code>方法，但是所有<code>Subjects</code>都有一个<code>asObservable()</code>方法。我们可以使用这个方法返回这个<code>Variable</code>的<code>Observable</code>类型，拿到这个<code>Observable</code>类型我们就能订阅它了。</li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let variable = Variable.init(&quot;A&quot;)</span><br><span class=\"line\">variable.value = &quot;B&quot;</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">variable.asObservable().subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//修改value</span><br><span class=\"line\">variable.value = &quot;C&quot;</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">variable.asObservable().subscribe&#123; print(&quot;第二次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//修改value</span><br><span class=\"line\">variable.value = &quot;D&quot;</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br><span class=\"line\">第一次订阅:completed</span><br><span class=\"line\">第二次订阅:completed</span><br></pre></td></tr></table></figure></p>\n"},{"title":"RxSwift Observable-可观察序列","date":"2018-09-20T14:25:46.000Z","_content":"[上一篇](https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more)已经介绍了`Observable`是什么，现在简单介绍一下它怎么创建，以及`RxSwift`里面`Observable`存在的一些特征序列。\n### 常见的创建方法\n####  just() 方法\n该方法通过传入一个默认值完成初始化，并指定了当前`Observable`所发出事件携带的数据类型\n```\nlet observable = Observable<Int>.just(1)\n```\n#### of()方法\n该方法可以接受多个参数来创建实例，但这些参数必须是同类型\n```\nlet observable = Observable.of(\"A\", \"B\", \"C\")\n```\n#### from()方法\n该方法只接收数组作为参数，并抽取出数组里的元素来作为数据流中的元素\n```\nlet observable = Observable.from([\"A\", \"B\", \"C\"])\n```\n#### never()方法\n该方法创建一个永远不会发出`Event`（也不会终止）的 `Observable`序列\n```\nlet observable = Observable<Int>.never()\n```\n#### empty()方法\n该方法创建一个空内容的`Observable`序列\n```\nlet observable = Observable<Int>.empty()\n```\n#### error() 方法\n该方法创建一个不做任何操作，而是直接发送一个错误的`Observable`序列\n```\nenum MyError: Error {\n    case A\n    case B\n}\n\nlet observable = Observable<Int>.error(MyError.A)\n```\n#### range() 方法\n该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的`Observable`序列\n```\nlet observable = Observable.range(start: 1, count: 5)\n```\n#### repeatElement() 方法\n该方法创建一个可以无限发出给定元素的`Event`的`Observable`序列\n```\nlet observable = Observable.repeatElement(1)\n```\n#### generate() 方法\n该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的`Observable`序列\n```\nlet observable = Observable.generate(\n    initialState: 0,\n    condition: { $0 <= 10 },\n    iterate: { $0 + 2 }\n)\n```\n#### interval() 方法\n这个方法创建的`Observable`序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去\n```\nlet observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\nobservable.subscribe { event in\n    print(event)\n//next(0) next(1) next(2)......\n}\n```\n#### timer() 方法\n- 创建的`Observable`序列在经过设定的一段时间后，产生唯一的一个元素\n```\n//10秒种后发出唯一的一个元素0\nlet observable = Observable<Int>.timer(10, scheduler: MainScheduler.instance)\nobservable.subscribe { event in\n    print(event)\n}\n```\n- 创建的`Observable`序列在经过设定的一段时间后，每隔一段时间产生一个元素\n```\n//延时10秒种后，每隔1秒钟发出一个元素\nlet observable = Observable<Int>.timer(10, period: 1, scheduler: MainScheduler.instance)\n    observable.subscribe { event in\n    print(event)\n}\n```\n#### create()方法\n该方法接受一个`block`形式的参数，任务是对每一个过来的订阅进行处理\n```\nlet observable = Observable<String>.create { (observer) -> Disposable in\n    observer.onNext(\"test\")\n    observer.onCompleted()\n    return Disposables.create()\n}\nobservable.subscribe { (element) in\n    print(element)\n}\n//next(test)\n//completed\n```\n#### deferred() 方法\n该个方法相当于是创建一个`Observable`工厂，通过传入一个`block`来执行延迟`Observable`序列创建的行为，而这个`block`里就是真正的实例化序列对象的地方\n```\nvar time = 0\nlet factory: Observable<Int> = Observable.deferred {\n    time += 1\n    return Observable.just(time)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\n/* \n打印结果\nnext(1)\ncompleted\nnext(2)\ncompleted\nnext(3)\ncompleted\nnext(4)\ncompleted\n*/\n```\n### 特征序列\n` Swift`是一个强类型语言，它相对弱类型语言更加严谨。我们可以通过类型来判断出，实例有哪些特征。同样的在`RxSwift` 里面`Observable`也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码，他们分别是`Single`、`Completable`、`Maybe`、`Driver`、`ControlEvent`、`ControlProperty`\n####  Single\n`Single`,在`RxSwift`中,对它的解释是*Represents a push style sequence containing 1 element*，它要么只能发出一个元素，要么产生一个`error`事件\n- 发出一个元素或一个`error`事件\n- 不会共享状态变化\n附：\n```\npublic enum SingleEvent<Element> {\ncase success(Element)\ncase error(Swift.Error)\n}\n```\n比如说，我们利用`Single`实现一个网络请求，返回成功的结果或失败:\n```\nfunc getReop(_ repo: String) -> Single<[String: Any]>{\n    return Single<[String: Any]>.create(subscribe: { (single) -> Disposable in\n        let url = URL.init(string: \"https://api.github.com/repos/\\(repo)\")!\n        let task = URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) in\n            if let error = error{\n                single(.error(error))\n                return\n            }\n            guard let data = data,\n                let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),\n                let result = json as? [String: Any] else{\n                    single(.error(DataError.cantParseJSON))\n                    return\n                }\n                single(.success(result))\n        })\n        task.resume()\n        return Disposables.create {\n            task.cancel()\n        }\n    })\n}\n//与数据相关的错误类型\nenum DataError: Error {\n    case cantParseJSON\n}\n```\n当我们想调用这个方法的时候:\n```\nlet disposeBag = DisposeBag()\ngetReop(\"ReactiveX/RxSwift\").subscribe(onSuccess: { (json) in\n    print(\"Json:\\(json)\")\n}) { (error) in\n    print(\"error:\\(error)\")\n}.disposed(by: disposeBag)\n```\n\n#### Completable\n`Completable`，在`RxSwift`中，对它的解释*Represents a push style sequence containing 0 elements.*可以理解为表示包含0个元素的推送样式序列，它要么产生`completed`事件，要么产生`error`事件。\n- 不会发出任何元素\n- 只会发出一个`completed`事件或者一个`error`事件\n- 不会共享状态变化\n附：\n```\npublic enum CompletableEvent {\n    case error(Swift.Error)  \n    case completed\n}\n```\n举个🌰:\n```\nfunc cacheLocally() -> Completable {\n    return Completable.create(subscribe: { (completable) -> Disposable in\n    //将数据缓存到本地（这里掠过具体的业务代码，随机成功或失败）\n    let success = (arc4random() % 2 == 0)\n    guard success else {\n        completable(.error(CacheError.failedCaching))\n        return Disposables.create{}\n    }\n    completable(.completed)\n    return Disposables.create()\n    })\n}\nenum CacheError: Error {\n    case failedCaching\n}\n```\n调用方法：\n```\ncacheLocally().subscribe(onCompleted: {\n    print(\"completed\")\n}) { (error) in\n    print(\"error:\\(error)\")\n}.disposed(by: disposeBag)\n```\n\n#### Maybe\n`MayBe`介于`Single`和`Completable`之间，它要么只能发出一个元素，要么产生一个`completed`事件，要么产生一个`error`事件。\n- 发出一个元素、或者一个`completed`事件、或者一个`error` 事件\n- 不会共享状态变化\n附：\n```\npublic enum MaybeEvent<Element> {\ncase success(Element)\ncase error(Swift.Error)\ncase completed\n}\n```\n举个🌰：\n```\nfunc generateString() -> Maybe<String>{\n    return Maybe<String>.create(subscribe: { (maybe) -> Disposable in\n    maybe(.success(\"success\"))\n    maybe(.completed)\n    maybe(.error(StringError.failedGenerate))\n    return Disposables.create()\n    })\n}\nenum StringError: Error {\n    case failedGenerate\n}\n```\n调用方法：\n```\ngenerateString().subscribe(onSuccess: { (element) in\n    print(\"success:\\(element)\")\n}, onError: { (error) in\n    print(\"error:\\(error)\")\n}) {\n    print(\"completed\")  \n}.disposed(by: disposeBag)\n```\n#### Driver\n`Driver`准确来说是`RxCocoa`的特征序列，目标是提供一种简便的方式在 UI 层编写响应式代码。\n##### 为什么使用Driver\n[这部分我们引用RxSwift中文文档内容](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html)\n我们举个例子来说明一下，为什么要使用`Driver`\n这是文档简介页的例子:\n```\nlet results = query.rx.text\n                    .throttle(0.3, scheduler: MainScheduler.instance)   \n                    .flatMapLatest { query in\n                        fetchAutoCompleteItems(query)\n                    }\n\nresults\n    .map { \"\\($0.count)\" }\n    .bind(to: resultCount.rx.text)\n    .disposed(by: disposeBag)\n\nresults\n    .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n    cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n这段代码的主要目的是：\n- 取出用户输入稳定后的内容\n- 向服务器请求一组结果\n- 将返回的结果绑定到两个 UI 元素上：`tableView`和 显示结果数量的`label`\n代码存在的问题：\n- 如果`fetchAutoCompleteItems`的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求\n- 如果`fetchAutoCompleteItems`在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃\n- 返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果\n一个更好的方案是这样的：\n```\nlet results = query.rx.text\n    .throttle(0.3, scheduler: MainScheduler.instance)\n    .flatMapLatest { query in\n        fetchAutoCompleteItems(query)\n    .observeOn(MainScheduler.instance)  // 结果在主线程返回\n    .catchErrorJustReturn([])           // 错误被处理了，这样至少不会终止整个序列\n    }\n    .share(replay: 1)                           // HTTP 请求是被共享的\n\nresults\n    .map { \"\\($0.count)\" }\n    .bind(to: resultCount.rx.text)\n    .disposed(by: disposeBag)\n\nresults\n    .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n        cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n在一个大型系统内，要确保每一步不被遗漏是一件不太容易的事情。所以更好的选择是合理运用编译器和特征序列来确保这些必备条件都已经满足。\n以下是使用`Driver`优化后的代码：\n```\nlet results = query.rx.text.asDriver()        // 将普通序列转换为 Driver\n    .throttle(0.3, scheduler: MainScheduler.instance)\n    .flatMapLatest { query in\n        fetchAutoCompleteItems(query)\n            .asDriver(onErrorJustReturn: [])  // 仅仅提供发生错误时的备选返回值\n    }\n\nresults\n    .map { \"\\($0.count)\" }\n    .drive(resultCount.rx.text)               // 这里改用 `drive` 而不是 `bindTo`\n    .disposed(by: disposeBag)                 // 这样可以确保必备条件都已经满足了\n\nresults\n    .drive(resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n        cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n首先第一个`asDriver`方法将`ControlProperty`转换为`Driver`\n然后第二个变化是:\n```\n.asDriver(onErrorJustReturn: [])\n```\n任何可被监听的序列都可以被转换为 Driver，只要他满足 3 个条件:\n- 不会产生 error 事件\n- 一定在 MainScheduler 监听（主线程监听）\n- 共享状态变化\n那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。asDriver(onErrorJustReturn: []) 相当于以下代码\n```\nlet safeSequence = xs\n    .observeOn(MainScheduler.instance)       // 主线程监听\n    .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误\n    .share(replay: 1, scope: .whileConnected)// 共享状态变化\nreturn Driver(raw: safeSequence)           // 封装\n```\n最后使用`drive`而不是`bindTo`。\n#### ControlEvent\n`ControlProperty`是专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（`Observable`），它也是`RxCocoa`的特征序列\n`ControlProperty`具有以下特征：\n- 不会产生`error`事件\n- 一定在`MainScheduler`订阅（主线程订阅）\n- 一定在`MainScheduler`监听（主线程监听）\n- 共享状态变化\n举个🌰：\n```\nimport UIKit\nimport RxSwift\nimport RxCocoa\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var label: UILabel!\n    //负责对象销毁\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        //将textField输入的文字绑定到label上\n        textField.rx.text\n            .bind(to: label.rx.text)\n            .disposed(by: disposeBag)\n        }\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n有人可能会纳闷，这跟`ControlProperty`有什么关系，没看到它的影子啊。我们查看`textField.rx.text`的`text`方法：\n```\nextension Reactive where Base : UITextField {\npublic var text: ControlProperty<String?> {\n        return value\n    }\n\npublic var value: ControlProperty<String?> {\n    return base.rx.controlPropertyWithDefaultEvents(\n        getter: { textField in\n        textField.text\n    },\n        setter: { textField, value in\n            if textField.text != value {\n            textField.text = value\n            }\n        }\n        )\n    }\n}\n```\n原来UITextField 的`rx.text`属性类型便是 `ControlProperty<String?>`\n同时，这段代码也给我们启示，为控件添加属性，可以采用`extension Reactive where Base : UITextField`的方法。\n#### ControlEvent\n`ControlEvent`专门用于描述 UI 控件所产生的事件，它具有跟`ControlProperty`一样的特征：\n- 不会产生`error`事件\n- 一定在`MainScheduler`订阅（主线程订阅）\n- 一定在`MainScheduler`监听（主线程监听）\n- 共享状态变化\n举个🌰：\n```\nimport UIKit\nimport RxSwift\nimport RxCocoa\n\nclass ViewController: UIViewController {\n\n    let disposeBag = DisposeBag()\n\n    @IBOutlet weak var button: UIButton!\n\n    override func viewDidLoad() {\n\n        //订阅按钮点击事件\n        button.rx.tap\n            .subscribe(onNext: {\n                print(\"blick\")\n            }).disposed(by: disposeBag)\n        }\n}\n```\n可能也有人会疑问，`ControlEvent`在哪？查看tap方法，会看到源码（`UIButton+Rx.swift`），这个时候就会发现 UIButton 的`rx.tap`方法类型便是`ControlEvent<Void>`：\n```\nimport RxSwift\nimport UIKit\n\nextension Reactive where Base: UIButton {\npublic var tap: ControlEvent<Void> {\n    return controlEvent(.touchUpInside)\n    }\n}\n```\n至此，我们就对`Observable`有了一个简单的介绍。\n","source":"_posts/RxSwift-Observable-可观察序列.md","raw":"---\ntitle: RxSwift Observable-可观察序列\ndate: 2018-09-20 22:25:46\ntags: RxSwift\n---\n[上一篇](https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more)已经介绍了`Observable`是什么，现在简单介绍一下它怎么创建，以及`RxSwift`里面`Observable`存在的一些特征序列。\n### 常见的创建方法\n####  just() 方法\n该方法通过传入一个默认值完成初始化，并指定了当前`Observable`所发出事件携带的数据类型\n```\nlet observable = Observable<Int>.just(1)\n```\n#### of()方法\n该方法可以接受多个参数来创建实例，但这些参数必须是同类型\n```\nlet observable = Observable.of(\"A\", \"B\", \"C\")\n```\n#### from()方法\n该方法只接收数组作为参数，并抽取出数组里的元素来作为数据流中的元素\n```\nlet observable = Observable.from([\"A\", \"B\", \"C\"])\n```\n#### never()方法\n该方法创建一个永远不会发出`Event`（也不会终止）的 `Observable`序列\n```\nlet observable = Observable<Int>.never()\n```\n#### empty()方法\n该方法创建一个空内容的`Observable`序列\n```\nlet observable = Observable<Int>.empty()\n```\n#### error() 方法\n该方法创建一个不做任何操作，而是直接发送一个错误的`Observable`序列\n```\nenum MyError: Error {\n    case A\n    case B\n}\n\nlet observable = Observable<Int>.error(MyError.A)\n```\n#### range() 方法\n该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的`Observable`序列\n```\nlet observable = Observable.range(start: 1, count: 5)\n```\n#### repeatElement() 方法\n该方法创建一个可以无限发出给定元素的`Event`的`Observable`序列\n```\nlet observable = Observable.repeatElement(1)\n```\n#### generate() 方法\n该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的`Observable`序列\n```\nlet observable = Observable.generate(\n    initialState: 0,\n    condition: { $0 <= 10 },\n    iterate: { $0 + 2 }\n)\n```\n#### interval() 方法\n这个方法创建的`Observable`序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去\n```\nlet observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\nobservable.subscribe { event in\n    print(event)\n//next(0) next(1) next(2)......\n}\n```\n#### timer() 方法\n- 创建的`Observable`序列在经过设定的一段时间后，产生唯一的一个元素\n```\n//10秒种后发出唯一的一个元素0\nlet observable = Observable<Int>.timer(10, scheduler: MainScheduler.instance)\nobservable.subscribe { event in\n    print(event)\n}\n```\n- 创建的`Observable`序列在经过设定的一段时间后，每隔一段时间产生一个元素\n```\n//延时10秒种后，每隔1秒钟发出一个元素\nlet observable = Observable<Int>.timer(10, period: 1, scheduler: MainScheduler.instance)\n    observable.subscribe { event in\n    print(event)\n}\n```\n#### create()方法\n该方法接受一个`block`形式的参数，任务是对每一个过来的订阅进行处理\n```\nlet observable = Observable<String>.create { (observer) -> Disposable in\n    observer.onNext(\"test\")\n    observer.onCompleted()\n    return Disposables.create()\n}\nobservable.subscribe { (element) in\n    print(element)\n}\n//next(test)\n//completed\n```\n#### deferred() 方法\n该个方法相当于是创建一个`Observable`工厂，通过传入一个`block`来执行延迟`Observable`序列创建的行为，而这个`block`里就是真正的实例化序列对象的地方\n```\nvar time = 0\nlet factory: Observable<Int> = Observable.deferred {\n    time += 1\n    return Observable.just(time)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\n/* \n打印结果\nnext(1)\ncompleted\nnext(2)\ncompleted\nnext(3)\ncompleted\nnext(4)\ncompleted\n*/\n```\n### 特征序列\n` Swift`是一个强类型语言，它相对弱类型语言更加严谨。我们可以通过类型来判断出，实例有哪些特征。同样的在`RxSwift` 里面`Observable`也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码，他们分别是`Single`、`Completable`、`Maybe`、`Driver`、`ControlEvent`、`ControlProperty`\n####  Single\n`Single`,在`RxSwift`中,对它的解释是*Represents a push style sequence containing 1 element*，它要么只能发出一个元素，要么产生一个`error`事件\n- 发出一个元素或一个`error`事件\n- 不会共享状态变化\n附：\n```\npublic enum SingleEvent<Element> {\ncase success(Element)\ncase error(Swift.Error)\n}\n```\n比如说，我们利用`Single`实现一个网络请求，返回成功的结果或失败:\n```\nfunc getReop(_ repo: String) -> Single<[String: Any]>{\n    return Single<[String: Any]>.create(subscribe: { (single) -> Disposable in\n        let url = URL.init(string: \"https://api.github.com/repos/\\(repo)\")!\n        let task = URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) in\n            if let error = error{\n                single(.error(error))\n                return\n            }\n            guard let data = data,\n                let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),\n                let result = json as? [String: Any] else{\n                    single(.error(DataError.cantParseJSON))\n                    return\n                }\n                single(.success(result))\n        })\n        task.resume()\n        return Disposables.create {\n            task.cancel()\n        }\n    })\n}\n//与数据相关的错误类型\nenum DataError: Error {\n    case cantParseJSON\n}\n```\n当我们想调用这个方法的时候:\n```\nlet disposeBag = DisposeBag()\ngetReop(\"ReactiveX/RxSwift\").subscribe(onSuccess: { (json) in\n    print(\"Json:\\(json)\")\n}) { (error) in\n    print(\"error:\\(error)\")\n}.disposed(by: disposeBag)\n```\n\n#### Completable\n`Completable`，在`RxSwift`中，对它的解释*Represents a push style sequence containing 0 elements.*可以理解为表示包含0个元素的推送样式序列，它要么产生`completed`事件，要么产生`error`事件。\n- 不会发出任何元素\n- 只会发出一个`completed`事件或者一个`error`事件\n- 不会共享状态变化\n附：\n```\npublic enum CompletableEvent {\n    case error(Swift.Error)  \n    case completed\n}\n```\n举个🌰:\n```\nfunc cacheLocally() -> Completable {\n    return Completable.create(subscribe: { (completable) -> Disposable in\n    //将数据缓存到本地（这里掠过具体的业务代码，随机成功或失败）\n    let success = (arc4random() % 2 == 0)\n    guard success else {\n        completable(.error(CacheError.failedCaching))\n        return Disposables.create{}\n    }\n    completable(.completed)\n    return Disposables.create()\n    })\n}\nenum CacheError: Error {\n    case failedCaching\n}\n```\n调用方法：\n```\ncacheLocally().subscribe(onCompleted: {\n    print(\"completed\")\n}) { (error) in\n    print(\"error:\\(error)\")\n}.disposed(by: disposeBag)\n```\n\n#### Maybe\n`MayBe`介于`Single`和`Completable`之间，它要么只能发出一个元素，要么产生一个`completed`事件，要么产生一个`error`事件。\n- 发出一个元素、或者一个`completed`事件、或者一个`error` 事件\n- 不会共享状态变化\n附：\n```\npublic enum MaybeEvent<Element> {\ncase success(Element)\ncase error(Swift.Error)\ncase completed\n}\n```\n举个🌰：\n```\nfunc generateString() -> Maybe<String>{\n    return Maybe<String>.create(subscribe: { (maybe) -> Disposable in\n    maybe(.success(\"success\"))\n    maybe(.completed)\n    maybe(.error(StringError.failedGenerate))\n    return Disposables.create()\n    })\n}\nenum StringError: Error {\n    case failedGenerate\n}\n```\n调用方法：\n```\ngenerateString().subscribe(onSuccess: { (element) in\n    print(\"success:\\(element)\")\n}, onError: { (error) in\n    print(\"error:\\(error)\")\n}) {\n    print(\"completed\")  \n}.disposed(by: disposeBag)\n```\n#### Driver\n`Driver`准确来说是`RxCocoa`的特征序列，目标是提供一种简便的方式在 UI 层编写响应式代码。\n##### 为什么使用Driver\n[这部分我们引用RxSwift中文文档内容](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html)\n我们举个例子来说明一下，为什么要使用`Driver`\n这是文档简介页的例子:\n```\nlet results = query.rx.text\n                    .throttle(0.3, scheduler: MainScheduler.instance)   \n                    .flatMapLatest { query in\n                        fetchAutoCompleteItems(query)\n                    }\n\nresults\n    .map { \"\\($0.count)\" }\n    .bind(to: resultCount.rx.text)\n    .disposed(by: disposeBag)\n\nresults\n    .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n    cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n这段代码的主要目的是：\n- 取出用户输入稳定后的内容\n- 向服务器请求一组结果\n- 将返回的结果绑定到两个 UI 元素上：`tableView`和 显示结果数量的`label`\n代码存在的问题：\n- 如果`fetchAutoCompleteItems`的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求\n- 如果`fetchAutoCompleteItems`在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃\n- 返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果\n一个更好的方案是这样的：\n```\nlet results = query.rx.text\n    .throttle(0.3, scheduler: MainScheduler.instance)\n    .flatMapLatest { query in\n        fetchAutoCompleteItems(query)\n    .observeOn(MainScheduler.instance)  // 结果在主线程返回\n    .catchErrorJustReturn([])           // 错误被处理了，这样至少不会终止整个序列\n    }\n    .share(replay: 1)                           // HTTP 请求是被共享的\n\nresults\n    .map { \"\\($0.count)\" }\n    .bind(to: resultCount.rx.text)\n    .disposed(by: disposeBag)\n\nresults\n    .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n        cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n在一个大型系统内，要确保每一步不被遗漏是一件不太容易的事情。所以更好的选择是合理运用编译器和特征序列来确保这些必备条件都已经满足。\n以下是使用`Driver`优化后的代码：\n```\nlet results = query.rx.text.asDriver()        // 将普通序列转换为 Driver\n    .throttle(0.3, scheduler: MainScheduler.instance)\n    .flatMapLatest { query in\n        fetchAutoCompleteItems(query)\n            .asDriver(onErrorJustReturn: [])  // 仅仅提供发生错误时的备选返回值\n    }\n\nresults\n    .map { \"\\($0.count)\" }\n    .drive(resultCount.rx.text)               // 这里改用 `drive` 而不是 `bindTo`\n    .disposed(by: disposeBag)                 // 这样可以确保必备条件都已经满足了\n\nresults\n    .drive(resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n        cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n首先第一个`asDriver`方法将`ControlProperty`转换为`Driver`\n然后第二个变化是:\n```\n.asDriver(onErrorJustReturn: [])\n```\n任何可被监听的序列都可以被转换为 Driver，只要他满足 3 个条件:\n- 不会产生 error 事件\n- 一定在 MainScheduler 监听（主线程监听）\n- 共享状态变化\n那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。asDriver(onErrorJustReturn: []) 相当于以下代码\n```\nlet safeSequence = xs\n    .observeOn(MainScheduler.instance)       // 主线程监听\n    .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误\n    .share(replay: 1, scope: .whileConnected)// 共享状态变化\nreturn Driver(raw: safeSequence)           // 封装\n```\n最后使用`drive`而不是`bindTo`。\n#### ControlEvent\n`ControlProperty`是专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（`Observable`），它也是`RxCocoa`的特征序列\n`ControlProperty`具有以下特征：\n- 不会产生`error`事件\n- 一定在`MainScheduler`订阅（主线程订阅）\n- 一定在`MainScheduler`监听（主线程监听）\n- 共享状态变化\n举个🌰：\n```\nimport UIKit\nimport RxSwift\nimport RxCocoa\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var label: UILabel!\n    //负责对象销毁\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        //将textField输入的文字绑定到label上\n        textField.rx.text\n            .bind(to: label.rx.text)\n            .disposed(by: disposeBag)\n        }\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n有人可能会纳闷，这跟`ControlProperty`有什么关系，没看到它的影子啊。我们查看`textField.rx.text`的`text`方法：\n```\nextension Reactive where Base : UITextField {\npublic var text: ControlProperty<String?> {\n        return value\n    }\n\npublic var value: ControlProperty<String?> {\n    return base.rx.controlPropertyWithDefaultEvents(\n        getter: { textField in\n        textField.text\n    },\n        setter: { textField, value in\n            if textField.text != value {\n            textField.text = value\n            }\n        }\n        )\n    }\n}\n```\n原来UITextField 的`rx.text`属性类型便是 `ControlProperty<String?>`\n同时，这段代码也给我们启示，为控件添加属性，可以采用`extension Reactive where Base : UITextField`的方法。\n#### ControlEvent\n`ControlEvent`专门用于描述 UI 控件所产生的事件，它具有跟`ControlProperty`一样的特征：\n- 不会产生`error`事件\n- 一定在`MainScheduler`订阅（主线程订阅）\n- 一定在`MainScheduler`监听（主线程监听）\n- 共享状态变化\n举个🌰：\n```\nimport UIKit\nimport RxSwift\nimport RxCocoa\n\nclass ViewController: UIViewController {\n\n    let disposeBag = DisposeBag()\n\n    @IBOutlet weak var button: UIButton!\n\n    override func viewDidLoad() {\n\n        //订阅按钮点击事件\n        button.rx.tap\n            .subscribe(onNext: {\n                print(\"blick\")\n            }).disposed(by: disposeBag)\n        }\n}\n```\n可能也有人会疑问，`ControlEvent`在哪？查看tap方法，会看到源码（`UIButton+Rx.swift`），这个时候就会发现 UIButton 的`rx.tap`方法类型便是`ControlEvent<Void>`：\n```\nimport RxSwift\nimport UIKit\n\nextension Reactive where Base: UIButton {\npublic var tap: ControlEvent<Void> {\n    return controlEvent(.touchUpInside)\n    }\n}\n```\n至此，我们就对`Observable`有了一个简单的介绍。\n","slug":"RxSwift-Observable-可观察序列","published":1,"updated":"2018-10-19T07:16:01.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0lue000nimcw0mshoatt","content":"<p><a href=\"https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more\" target=\"_blank\" rel=\"noopener\">上一篇</a>已经介绍了<code>Observable</code>是什么，现在简单介绍一下它怎么创建，以及<code>RxSwift</code>里面<code>Observable</code>存在的一些特征序列。</p>\n<h3 id=\"常见的创建方法\"><a href=\"#常见的创建方法\" class=\"headerlink\" title=\"常见的创建方法\"></a>常见的创建方法</h3><h4 id=\"just-方法\"><a href=\"#just-方法\" class=\"headerlink\" title=\"just() 方法\"></a>just() 方法</h4><p>该方法通过传入一个默认值完成初始化，并指定了当前<code>Observable</code>所发出事件携带的数据类型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.just(1)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"of-方法\"><a href=\"#of-方法\" class=\"headerlink\" title=\"of()方法\"></a>of()方法</h4><p>该方法可以接受多个参数来创建实例，但这些参数必须是同类型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"from-方法\"><a href=\"#from-方法\" class=\"headerlink\" title=\"from()方法\"></a>from()方法</h4><p>该方法只接收数组作为参数，并抽取出数组里的元素来作为数据流中的元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.from([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"never-方法\"><a href=\"#never-方法\" class=\"headerlink\" title=\"never()方法\"></a>never()方法</h4><p>该方法创建一个永远不会发出<code>Event</code>（也不会终止）的 <code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.never()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"empty-方法\"><a href=\"#empty-方法\" class=\"headerlink\" title=\"empty()方法\"></a>empty()方法</h4><p>该方法创建一个空内容的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.empty()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"error-方法\"><a href=\"#error-方法\" class=\"headerlink\" title=\"error() 方法\"></a>error() 方法</h4><p>该方法创建一个不做任何操作，而是直接发送一个错误的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum MyError: Error &#123;</span><br><span class=\"line\">    case A</span><br><span class=\"line\">    case B</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.error(MyError.A)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"range-方法\"><a href=\"#range-方法\" class=\"headerlink\" title=\"range() 方法\"></a>range() 方法</h4><p>该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.range(start: 1, count: 5)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"repeatElement-方法\"><a href=\"#repeatElement-方法\" class=\"headerlink\" title=\"repeatElement() 方法\"></a>repeatElement() 方法</h4><p>该方法创建一个可以无限发出给定元素的<code>Event</code>的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.repeatElement(1)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"generate-方法\"><a href=\"#generate-方法\" class=\"headerlink\" title=\"generate() 方法\"></a>generate() 方法</h4><p>该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.generate(</span><br><span class=\"line\">    initialState: 0,</span><br><span class=\"line\">    condition: &#123; $0 &lt;= 10 &#125;,</span><br><span class=\"line\">    iterate: &#123; $0 + 2 &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"interval-方法\"><a href=\"#interval-方法\" class=\"headerlink\" title=\"interval() 方法\"></a>interval() 方法</h4><p>这个方法创建的<code>Observable</code>序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">//next(0) next(1) next(2)......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"timer-方法\"><a href=\"#timer-方法\" class=\"headerlink\" title=\"timer() 方法\"></a>timer() 方法</h4><ul>\n<li><p>创建的<code>Observable</code>序列在经过设定的一段时间后，产生唯一的一个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//10秒种后发出唯一的一个元素0</span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.timer(10, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建的<code>Observable</code>序列在经过设定的一段时间后，每隔一段时间产生一个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//延时10秒种后，每隔1秒钟发出一个元素</span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.timer(10, period: 1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"create-方法\"><a href=\"#create-方法\" class=\"headerlink\" title=\"create()方法\"></a>create()方法</h4><p>该方法接受一个<code>block</code>形式的参数，任务是对每一个过来的订阅进行处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;String&gt;.create &#123; (observer) -&gt; Disposable in</span><br><span class=\"line\">    observer.onNext(&quot;test&quot;)</span><br><span class=\"line\">    observer.onCompleted()</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">observable.subscribe &#123; (element) in</span><br><span class=\"line\">    print(element)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//next(test)</span><br><span class=\"line\">//completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"deferred-方法\"><a href=\"#deferred-方法\" class=\"headerlink\" title=\"deferred() 方法\"></a>deferred() 方法</h4><p>该个方法相当于是创建一个<code>Observable</code>工厂，通过传入一个<code>block</code>来执行延迟<code>Observable</code>序列创建的行为，而这个<code>block</code>里就是真正的实例化序列对象的地方<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var time = 0</span><br><span class=\"line\">let factory: Observable&lt;Int&gt; = Observable.deferred &#123;</span><br><span class=\"line\">    time += 1</span><br><span class=\"line\">    return Observable.just(time)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* </span><br><span class=\"line\">打印结果</span><br><span class=\"line\">next(1)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(2)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(3)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(4)</span><br><span class=\"line\">completed</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"特征序列\"><a href=\"#特征序列\" class=\"headerlink\" title=\"特征序列\"></a>特征序列</h3><p><code>Swift</code>是一个强类型语言，它相对弱类型语言更加严谨。我们可以通过类型来判断出，实例有哪些特征。同样的在<code>RxSwift</code> 里面<code>Observable</code>也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码，他们分别是<code>Single</code>、<code>Completable</code>、<code>Maybe</code>、<code>Driver</code>、<code>ControlEvent</code>、<code>ControlProperty</code></p>\n<h4 id=\"Single\"><a href=\"#Single\" class=\"headerlink\" title=\"Single\"></a>Single</h4><p><code>Single</code>,在<code>RxSwift</code>中,对它的解释是<em>Represents a push style sequence containing 1 element</em>，它要么只能发出一个元素，要么产生一个<code>error</code>事件</p>\n<ul>\n<li>发出一个元素或一个<code>error</code>事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum SingleEvent&lt;Element&gt; &#123;</span><br><span class=\"line\">case success(Element)</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>比如说，我们利用<code>Single</code>实现一个网络请求，返回成功的结果或失败:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func getReop(_ repo: String) -&gt; Single&lt;[String: Any]&gt;&#123;</span><br><span class=\"line\">    return Single&lt;[String: Any]&gt;.create(subscribe: &#123; (single) -&gt; Disposable in</span><br><span class=\"line\">        let url = URL.init(string: &quot;https://api.github.com/repos/\\(repo)&quot;)!</span><br><span class=\"line\">        let task = URLSession.shared.dataTask(with: url, completionHandler: &#123; (data, response, error) in</span><br><span class=\"line\">            if let error = error&#123;</span><br><span class=\"line\">                single(.error(error))</span><br><span class=\"line\">                return</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            guard let data = data,</span><br><span class=\"line\">                let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),</span><br><span class=\"line\">                let result = json as? [String: Any] else&#123;</span><br><span class=\"line\">                    single(.error(DataError.cantParseJSON))</span><br><span class=\"line\">                    return</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                single(.success(result))</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        task.resume()</span><br><span class=\"line\">        return Disposables.create &#123;</span><br><span class=\"line\">            task.cancel()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//与数据相关的错误类型</span><br><span class=\"line\">enum DataError: Error &#123;</span><br><span class=\"line\">    case cantParseJSON</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当我们想调用这个方法的时候:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">getReop(&quot;ReactiveX/RxSwift&quot;).subscribe(onSuccess: &#123; (json) in</span><br><span class=\"line\">    print(&quot;Json:\\(json)&quot;)</span><br><span class=\"line\">&#125;) &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Completable\"><a href=\"#Completable\" class=\"headerlink\" title=\"Completable\"></a>Completable</h4><p><code>Completable</code>，在<code>RxSwift</code>中，对它的解释<em>Represents a push style sequence containing 0 elements.</em>可以理解为表示包含0个元素的推送样式序列，它要么产生<code>completed</code>事件，要么产生<code>error</code>事件。</p>\n<ul>\n<li>不会发出任何元素</li>\n<li>只会发出一个<code>completed</code>事件或者一个<code>error</code>事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum CompletableEvent &#123;</span><br><span class=\"line\">    case error(Swift.Error)  </span><br><span class=\"line\">    case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>举个🌰:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func cacheLocally() -&gt; Completable &#123;</span><br><span class=\"line\">    return Completable.create(subscribe: &#123; (completable) -&gt; Disposable in</span><br><span class=\"line\">    //将数据缓存到本地（这里掠过具体的业务代码，随机成功或失败）</span><br><span class=\"line\">    let success = (arc4random() % 2 == 0)</span><br><span class=\"line\">    guard success else &#123;</span><br><span class=\"line\">        completable(.error(CacheError.failedCaching))</span><br><span class=\"line\">        return Disposables.create&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    completable(.completed)</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum CacheError: Error &#123;</span><br><span class=\"line\">    case failedCaching</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cacheLocally().subscribe(onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;) &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Maybe\"><a href=\"#Maybe\" class=\"headerlink\" title=\"Maybe\"></a>Maybe</h4><p><code>MayBe</code>介于<code>Single</code>和<code>Completable</code>之间，它要么只能发出一个元素，要么产生一个<code>completed</code>事件，要么产生一个<code>error</code>事件。</p>\n<ul>\n<li>发出一个元素、或者一个<code>completed</code>事件、或者一个<code>error</code> 事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum MaybeEvent&lt;Element&gt; &#123;</span><br><span class=\"line\">case success(Element)</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func generateString() -&gt; Maybe&lt;String&gt;&#123;</span><br><span class=\"line\">    return Maybe&lt;String&gt;.create(subscribe: &#123; (maybe) -&gt; Disposable in</span><br><span class=\"line\">    maybe(.success(&quot;success&quot;))</span><br><span class=\"line\">    maybe(.completed)</span><br><span class=\"line\">    maybe(.error(StringError.failedGenerate))</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum StringError: Error &#123;</span><br><span class=\"line\">    case failedGenerate</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">generateString().subscribe(onSuccess: &#123; (element) in</span><br><span class=\"line\">    print(&quot;success:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onError: &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)  </span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Driver\"><a href=\"#Driver\" class=\"headerlink\" title=\"Driver\"></a>Driver</h4><p><code>Driver</code>准确来说是<code>RxCocoa</code>的特征序列，目标是提供一种简便的方式在 UI 层编写响应式代码。</p>\n<h5 id=\"为什么使用Driver\"><a href=\"#为什么使用Driver\" class=\"headerlink\" title=\"为什么使用Driver\"></a>为什么使用Driver</h5><p><a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html\" target=\"_blank\" rel=\"noopener\">这部分我们引用RxSwift中文文档内容</a><br>我们举个例子来说明一下，为什么要使用<code>Driver</code><br>这是文档简介页的例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text</span><br><span class=\"line\">                    .throttle(0.3, scheduler: MainScheduler.instance)   </span><br><span class=\"line\">                    .flatMapLatest &#123; query in</span><br><span class=\"line\">                        fetchAutoCompleteItems(query)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .bind(to: resultCount.rx.text)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">    cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>这段代码的主要目的是：</p>\n<ul>\n<li>取出用户输入稳定后的内容</li>\n<li>向服务器请求一组结果</li>\n<li>将返回的结果绑定到两个 UI 元素上：<code>tableView</code>和 显示结果数量的<code>label</code><br>代码存在的问题：</li>\n<li>如果<code>fetchAutoCompleteItems</code>的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求</li>\n<li>如果<code>fetchAutoCompleteItems</code>在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃</li>\n<li>返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果<br>一个更好的方案是这样的：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text</span><br><span class=\"line\">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .flatMapLatest &#123; query in</span><br><span class=\"line\">        fetchAutoCompleteItems(query)</span><br><span class=\"line\">    .observeOn(MainScheduler.instance)  // 结果在主线程返回</span><br><span class=\"line\">    .catchErrorJustReturn([])           // 错误被处理了，这样至少不会终止整个序列</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .share(replay: 1)                           // HTTP 请求是被共享的</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .bind(to: resultCount.rx.text)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">        cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在一个大型系统内，要确保每一步不被遗漏是一件不太容易的事情。所以更好的选择是合理运用编译器和特征序列来确保这些必备条件都已经满足。<br>以下是使用<code>Driver</code>优化后的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text.asDriver()        // 将普通序列转换为 Driver</span><br><span class=\"line\">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .flatMapLatest &#123; query in</span><br><span class=\"line\">        fetchAutoCompleteItems(query)</span><br><span class=\"line\">            .asDriver(onErrorJustReturn: [])  // 仅仅提供发生错误时的备选返回值</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .drive(resultCount.rx.text)               // 这里改用 `drive` 而不是 `bindTo`</span><br><span class=\"line\">    .disposed(by: disposeBag)                 // 这样可以确保必备条件都已经满足了</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">        cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>首先第一个<code>asDriver</code>方法将<code>ControlProperty</code>转换为<code>Driver</code><br>然后第二个变化是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.asDriver(onErrorJustReturn: [])</span><br></pre></td></tr></table></figure></p>\n<p>任何可被监听的序列都可以被转换为 Driver，只要他满足 3 个条件:</p>\n<ul>\n<li>不会产生 error 事件</li>\n<li>一定在 MainScheduler 监听（主线程监听）</li>\n<li>共享状态变化<br>那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。asDriver(onErrorJustReturn: []) 相当于以下代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let safeSequence = xs</span><br><span class=\"line\">    .observeOn(MainScheduler.instance)       // 主线程监听</span><br><span class=\"line\">    .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误</span><br><span class=\"line\">    .share(replay: 1, scope: .whileConnected)// 共享状态变化</span><br><span class=\"line\">return Driver(raw: safeSequence)           // 封装</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最后使用<code>drive</code>而不是<code>bindTo</code>。</p>\n<h4 id=\"ControlEvent\"><a href=\"#ControlEvent\" class=\"headerlink\" title=\"ControlEvent\"></a>ControlEvent</h4><p><code>ControlProperty</code>是专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（<code>Observable</code>），它也是<code>RxCocoa</code>的特征序列<br><code>ControlProperty</code>具有以下特征：</p>\n<ul>\n<li>不会产生<code>error</code>事件</li>\n<li>一定在<code>MainScheduler</code>订阅（主线程订阅）</li>\n<li>一定在<code>MainScheduler</code>监听（主线程监听）</li>\n<li>共享状态变化<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var textField: UITextField!</span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    //负责对象销毁</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        //将textField输入的文字绑定到label上</span><br><span class=\"line\">        textField.rx.text</span><br><span class=\"line\">            .bind(to: label.rx.text)</span><br><span class=\"line\">            .disposed(by: disposeBag)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>有人可能会纳闷，这跟<code>ControlProperty</code>有什么关系，没看到它的影子啊。我们查看<code>textField.rx.text</code>的<code>text</code>方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Reactive where Base : UITextField &#123;</span><br><span class=\"line\">public var text: ControlProperty&lt;String?&gt; &#123;</span><br><span class=\"line\">        return value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public var value: ControlProperty&lt;String?&gt; &#123;</span><br><span class=\"line\">    return base.rx.controlPropertyWithDefaultEvents(</span><br><span class=\"line\">        getter: &#123; textField in</span><br><span class=\"line\">        textField.text</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">        setter: &#123; textField, value in</span><br><span class=\"line\">            if textField.text != value &#123;</span><br><span class=\"line\">            textField.text = value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原来UITextField 的<code>rx.text</code>属性类型便是 <code>ControlProperty&lt;String?&gt;</code><br>同时，这段代码也给我们启示，为控件添加属性，可以采用<code>extension Reactive where Base : UITextField</code>的方法。</p>\n<h4 id=\"ControlEvent-1\"><a href=\"#ControlEvent-1\" class=\"headerlink\" title=\"ControlEvent\"></a>ControlEvent</h4><p><code>ControlEvent</code>专门用于描述 UI 控件所产生的事件，它具有跟<code>ControlProperty</code>一样的特征：</p>\n<ul>\n<li>不会产生<code>error</code>事件</li>\n<li>一定在<code>MainScheduler</code>订阅（主线程订阅）</li>\n<li>一定在<code>MainScheduler</code>监听（主线程监听）</li>\n<li>共享状态变化<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var button: UIButton!</span><br><span class=\"line\"></span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        //订阅按钮点击事件</span><br><span class=\"line\">        button.rx.tap</span><br><span class=\"line\">            .subscribe(onNext: &#123;</span><br><span class=\"line\">                print(&quot;blick&quot;)</span><br><span class=\"line\">            &#125;).disposed(by: disposeBag)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可能也有人会疑问，<code>ControlEvent</code>在哪？查看tap方法，会看到源码（<code>UIButton+Rx.swift</code>），这个时候就会发现 UIButton 的<code>rx.tap</code>方法类型便是<code>ControlEvent&lt;Void&gt;</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import RxSwift</span><br><span class=\"line\">import UIKit</span><br><span class=\"line\"></span><br><span class=\"line\">extension Reactive where Base: UIButton &#123;</span><br><span class=\"line\">public var tap: ControlEvent&lt;Void&gt; &#123;</span><br><span class=\"line\">    return controlEvent(.touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，我们就对<code>Observable</code>有了一个简单的介绍。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more\" target=\"_blank\" rel=\"noopener\">上一篇</a>已经介绍了<code>Observable</code>是什么，现在简单介绍一下它怎么创建，以及<code>RxSwift</code>里面<code>Observable</code>存在的一些特征序列。</p>\n<h3 id=\"常见的创建方法\"><a href=\"#常见的创建方法\" class=\"headerlink\" title=\"常见的创建方法\"></a>常见的创建方法</h3><h4 id=\"just-方法\"><a href=\"#just-方法\" class=\"headerlink\" title=\"just() 方法\"></a>just() 方法</h4><p>该方法通过传入一个默认值完成初始化，并指定了当前<code>Observable</code>所发出事件携带的数据类型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.just(1)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"of-方法\"><a href=\"#of-方法\" class=\"headerlink\" title=\"of()方法\"></a>of()方法</h4><p>该方法可以接受多个参数来创建实例，但这些参数必须是同类型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"from-方法\"><a href=\"#from-方法\" class=\"headerlink\" title=\"from()方法\"></a>from()方法</h4><p>该方法只接收数组作为参数，并抽取出数组里的元素来作为数据流中的元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.from([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"never-方法\"><a href=\"#never-方法\" class=\"headerlink\" title=\"never()方法\"></a>never()方法</h4><p>该方法创建一个永远不会发出<code>Event</code>（也不会终止）的 <code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.never()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"empty-方法\"><a href=\"#empty-方法\" class=\"headerlink\" title=\"empty()方法\"></a>empty()方法</h4><p>该方法创建一个空内容的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.empty()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"error-方法\"><a href=\"#error-方法\" class=\"headerlink\" title=\"error() 方法\"></a>error() 方法</h4><p>该方法创建一个不做任何操作，而是直接发送一个错误的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum MyError: Error &#123;</span><br><span class=\"line\">    case A</span><br><span class=\"line\">    case B</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.error(MyError.A)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"range-方法\"><a href=\"#range-方法\" class=\"headerlink\" title=\"range() 方法\"></a>range() 方法</h4><p>该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.range(start: 1, count: 5)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"repeatElement-方法\"><a href=\"#repeatElement-方法\" class=\"headerlink\" title=\"repeatElement() 方法\"></a>repeatElement() 方法</h4><p>该方法创建一个可以无限发出给定元素的<code>Event</code>的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.repeatElement(1)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"generate-方法\"><a href=\"#generate-方法\" class=\"headerlink\" title=\"generate() 方法\"></a>generate() 方法</h4><p>该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.generate(</span><br><span class=\"line\">    initialState: 0,</span><br><span class=\"line\">    condition: &#123; $0 &lt;= 10 &#125;,</span><br><span class=\"line\">    iterate: &#123; $0 + 2 &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"interval-方法\"><a href=\"#interval-方法\" class=\"headerlink\" title=\"interval() 方法\"></a>interval() 方法</h4><p>这个方法创建的<code>Observable</code>序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">//next(0) next(1) next(2)......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"timer-方法\"><a href=\"#timer-方法\" class=\"headerlink\" title=\"timer() 方法\"></a>timer() 方法</h4><ul>\n<li><p>创建的<code>Observable</code>序列在经过设定的一段时间后，产生唯一的一个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//10秒种后发出唯一的一个元素0</span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.timer(10, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建的<code>Observable</code>序列在经过设定的一段时间后，每隔一段时间产生一个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//延时10秒种后，每隔1秒钟发出一个元素</span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.timer(10, period: 1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"create-方法\"><a href=\"#create-方法\" class=\"headerlink\" title=\"create()方法\"></a>create()方法</h4><p>该方法接受一个<code>block</code>形式的参数，任务是对每一个过来的订阅进行处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;String&gt;.create &#123; (observer) -&gt; Disposable in</span><br><span class=\"line\">    observer.onNext(&quot;test&quot;)</span><br><span class=\"line\">    observer.onCompleted()</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">observable.subscribe &#123; (element) in</span><br><span class=\"line\">    print(element)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//next(test)</span><br><span class=\"line\">//completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"deferred-方法\"><a href=\"#deferred-方法\" class=\"headerlink\" title=\"deferred() 方法\"></a>deferred() 方法</h4><p>该个方法相当于是创建一个<code>Observable</code>工厂，通过传入一个<code>block</code>来执行延迟<code>Observable</code>序列创建的行为，而这个<code>block</code>里就是真正的实例化序列对象的地方<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var time = 0</span><br><span class=\"line\">let factory: Observable&lt;Int&gt; = Observable.deferred &#123;</span><br><span class=\"line\">    time += 1</span><br><span class=\"line\">    return Observable.just(time)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* </span><br><span class=\"line\">打印结果</span><br><span class=\"line\">next(1)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(2)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(3)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(4)</span><br><span class=\"line\">completed</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"特征序列\"><a href=\"#特征序列\" class=\"headerlink\" title=\"特征序列\"></a>特征序列</h3><p><code>Swift</code>是一个强类型语言，它相对弱类型语言更加严谨。我们可以通过类型来判断出，实例有哪些特征。同样的在<code>RxSwift</code> 里面<code>Observable</code>也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码，他们分别是<code>Single</code>、<code>Completable</code>、<code>Maybe</code>、<code>Driver</code>、<code>ControlEvent</code>、<code>ControlProperty</code></p>\n<h4 id=\"Single\"><a href=\"#Single\" class=\"headerlink\" title=\"Single\"></a>Single</h4><p><code>Single</code>,在<code>RxSwift</code>中,对它的解释是<em>Represents a push style sequence containing 1 element</em>，它要么只能发出一个元素，要么产生一个<code>error</code>事件</p>\n<ul>\n<li>发出一个元素或一个<code>error</code>事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum SingleEvent&lt;Element&gt; &#123;</span><br><span class=\"line\">case success(Element)</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>比如说，我们利用<code>Single</code>实现一个网络请求，返回成功的结果或失败:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func getReop(_ repo: String) -&gt; Single&lt;[String: Any]&gt;&#123;</span><br><span class=\"line\">    return Single&lt;[String: Any]&gt;.create(subscribe: &#123; (single) -&gt; Disposable in</span><br><span class=\"line\">        let url = URL.init(string: &quot;https://api.github.com/repos/\\(repo)&quot;)!</span><br><span class=\"line\">        let task = URLSession.shared.dataTask(with: url, completionHandler: &#123; (data, response, error) in</span><br><span class=\"line\">            if let error = error&#123;</span><br><span class=\"line\">                single(.error(error))</span><br><span class=\"line\">                return</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            guard let data = data,</span><br><span class=\"line\">                let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),</span><br><span class=\"line\">                let result = json as? [String: Any] else&#123;</span><br><span class=\"line\">                    single(.error(DataError.cantParseJSON))</span><br><span class=\"line\">                    return</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                single(.success(result))</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        task.resume()</span><br><span class=\"line\">        return Disposables.create &#123;</span><br><span class=\"line\">            task.cancel()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//与数据相关的错误类型</span><br><span class=\"line\">enum DataError: Error &#123;</span><br><span class=\"line\">    case cantParseJSON</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当我们想调用这个方法的时候:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">getReop(&quot;ReactiveX/RxSwift&quot;).subscribe(onSuccess: &#123; (json) in</span><br><span class=\"line\">    print(&quot;Json:\\(json)&quot;)</span><br><span class=\"line\">&#125;) &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Completable\"><a href=\"#Completable\" class=\"headerlink\" title=\"Completable\"></a>Completable</h4><p><code>Completable</code>，在<code>RxSwift</code>中，对它的解释<em>Represents a push style sequence containing 0 elements.</em>可以理解为表示包含0个元素的推送样式序列，它要么产生<code>completed</code>事件，要么产生<code>error</code>事件。</p>\n<ul>\n<li>不会发出任何元素</li>\n<li>只会发出一个<code>completed</code>事件或者一个<code>error</code>事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum CompletableEvent &#123;</span><br><span class=\"line\">    case error(Swift.Error)  </span><br><span class=\"line\">    case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>举个🌰:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func cacheLocally() -&gt; Completable &#123;</span><br><span class=\"line\">    return Completable.create(subscribe: &#123; (completable) -&gt; Disposable in</span><br><span class=\"line\">    //将数据缓存到本地（这里掠过具体的业务代码，随机成功或失败）</span><br><span class=\"line\">    let success = (arc4random() % 2 == 0)</span><br><span class=\"line\">    guard success else &#123;</span><br><span class=\"line\">        completable(.error(CacheError.failedCaching))</span><br><span class=\"line\">        return Disposables.create&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    completable(.completed)</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum CacheError: Error &#123;</span><br><span class=\"line\">    case failedCaching</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cacheLocally().subscribe(onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;) &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Maybe\"><a href=\"#Maybe\" class=\"headerlink\" title=\"Maybe\"></a>Maybe</h4><p><code>MayBe</code>介于<code>Single</code>和<code>Completable</code>之间，它要么只能发出一个元素，要么产生一个<code>completed</code>事件，要么产生一个<code>error</code>事件。</p>\n<ul>\n<li>发出一个元素、或者一个<code>completed</code>事件、或者一个<code>error</code> 事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum MaybeEvent&lt;Element&gt; &#123;</span><br><span class=\"line\">case success(Element)</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func generateString() -&gt; Maybe&lt;String&gt;&#123;</span><br><span class=\"line\">    return Maybe&lt;String&gt;.create(subscribe: &#123; (maybe) -&gt; Disposable in</span><br><span class=\"line\">    maybe(.success(&quot;success&quot;))</span><br><span class=\"line\">    maybe(.completed)</span><br><span class=\"line\">    maybe(.error(StringError.failedGenerate))</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum StringError: Error &#123;</span><br><span class=\"line\">    case failedGenerate</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">generateString().subscribe(onSuccess: &#123; (element) in</span><br><span class=\"line\">    print(&quot;success:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onError: &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)  </span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Driver\"><a href=\"#Driver\" class=\"headerlink\" title=\"Driver\"></a>Driver</h4><p><code>Driver</code>准确来说是<code>RxCocoa</code>的特征序列，目标是提供一种简便的方式在 UI 层编写响应式代码。</p>\n<h5 id=\"为什么使用Driver\"><a href=\"#为什么使用Driver\" class=\"headerlink\" title=\"为什么使用Driver\"></a>为什么使用Driver</h5><p><a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html\" target=\"_blank\" rel=\"noopener\">这部分我们引用RxSwift中文文档内容</a><br>我们举个例子来说明一下，为什么要使用<code>Driver</code><br>这是文档简介页的例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text</span><br><span class=\"line\">                    .throttle(0.3, scheduler: MainScheduler.instance)   </span><br><span class=\"line\">                    .flatMapLatest &#123; query in</span><br><span class=\"line\">                        fetchAutoCompleteItems(query)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .bind(to: resultCount.rx.text)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">    cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>这段代码的主要目的是：</p>\n<ul>\n<li>取出用户输入稳定后的内容</li>\n<li>向服务器请求一组结果</li>\n<li>将返回的结果绑定到两个 UI 元素上：<code>tableView</code>和 显示结果数量的<code>label</code><br>代码存在的问题：</li>\n<li>如果<code>fetchAutoCompleteItems</code>的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求</li>\n<li>如果<code>fetchAutoCompleteItems</code>在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃</li>\n<li>返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果<br>一个更好的方案是这样的：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text</span><br><span class=\"line\">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .flatMapLatest &#123; query in</span><br><span class=\"line\">        fetchAutoCompleteItems(query)</span><br><span class=\"line\">    .observeOn(MainScheduler.instance)  // 结果在主线程返回</span><br><span class=\"line\">    .catchErrorJustReturn([])           // 错误被处理了，这样至少不会终止整个序列</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .share(replay: 1)                           // HTTP 请求是被共享的</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .bind(to: resultCount.rx.text)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">        cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在一个大型系统内，要确保每一步不被遗漏是一件不太容易的事情。所以更好的选择是合理运用编译器和特征序列来确保这些必备条件都已经满足。<br>以下是使用<code>Driver</code>优化后的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text.asDriver()        // 将普通序列转换为 Driver</span><br><span class=\"line\">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .flatMapLatest &#123; query in</span><br><span class=\"line\">        fetchAutoCompleteItems(query)</span><br><span class=\"line\">            .asDriver(onErrorJustReturn: [])  // 仅仅提供发生错误时的备选返回值</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .drive(resultCount.rx.text)               // 这里改用 `drive` 而不是 `bindTo`</span><br><span class=\"line\">    .disposed(by: disposeBag)                 // 这样可以确保必备条件都已经满足了</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">        cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>首先第一个<code>asDriver</code>方法将<code>ControlProperty</code>转换为<code>Driver</code><br>然后第二个变化是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.asDriver(onErrorJustReturn: [])</span><br></pre></td></tr></table></figure></p>\n<p>任何可被监听的序列都可以被转换为 Driver，只要他满足 3 个条件:</p>\n<ul>\n<li>不会产生 error 事件</li>\n<li>一定在 MainScheduler 监听（主线程监听）</li>\n<li>共享状态变化<br>那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。asDriver(onErrorJustReturn: []) 相当于以下代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let safeSequence = xs</span><br><span class=\"line\">    .observeOn(MainScheduler.instance)       // 主线程监听</span><br><span class=\"line\">    .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误</span><br><span class=\"line\">    .share(replay: 1, scope: .whileConnected)// 共享状态变化</span><br><span class=\"line\">return Driver(raw: safeSequence)           // 封装</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最后使用<code>drive</code>而不是<code>bindTo</code>。</p>\n<h4 id=\"ControlEvent\"><a href=\"#ControlEvent\" class=\"headerlink\" title=\"ControlEvent\"></a>ControlEvent</h4><p><code>ControlProperty</code>是专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（<code>Observable</code>），它也是<code>RxCocoa</code>的特征序列<br><code>ControlProperty</code>具有以下特征：</p>\n<ul>\n<li>不会产生<code>error</code>事件</li>\n<li>一定在<code>MainScheduler</code>订阅（主线程订阅）</li>\n<li>一定在<code>MainScheduler</code>监听（主线程监听）</li>\n<li>共享状态变化<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var textField: UITextField!</span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    //负责对象销毁</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        //将textField输入的文字绑定到label上</span><br><span class=\"line\">        textField.rx.text</span><br><span class=\"line\">            .bind(to: label.rx.text)</span><br><span class=\"line\">            .disposed(by: disposeBag)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>有人可能会纳闷，这跟<code>ControlProperty</code>有什么关系，没看到它的影子啊。我们查看<code>textField.rx.text</code>的<code>text</code>方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Reactive where Base : UITextField &#123;</span><br><span class=\"line\">public var text: ControlProperty&lt;String?&gt; &#123;</span><br><span class=\"line\">        return value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public var value: ControlProperty&lt;String?&gt; &#123;</span><br><span class=\"line\">    return base.rx.controlPropertyWithDefaultEvents(</span><br><span class=\"line\">        getter: &#123; textField in</span><br><span class=\"line\">        textField.text</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">        setter: &#123; textField, value in</span><br><span class=\"line\">            if textField.text != value &#123;</span><br><span class=\"line\">            textField.text = value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原来UITextField 的<code>rx.text</code>属性类型便是 <code>ControlProperty&lt;String?&gt;</code><br>同时，这段代码也给我们启示，为控件添加属性，可以采用<code>extension Reactive where Base : UITextField</code>的方法。</p>\n<h4 id=\"ControlEvent-1\"><a href=\"#ControlEvent-1\" class=\"headerlink\" title=\"ControlEvent\"></a>ControlEvent</h4><p><code>ControlEvent</code>专门用于描述 UI 控件所产生的事件，它具有跟<code>ControlProperty</code>一样的特征：</p>\n<ul>\n<li>不会产生<code>error</code>事件</li>\n<li>一定在<code>MainScheduler</code>订阅（主线程订阅）</li>\n<li>一定在<code>MainScheduler</code>监听（主线程监听）</li>\n<li>共享状态变化<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var button: UIButton!</span><br><span class=\"line\"></span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        //订阅按钮点击事件</span><br><span class=\"line\">        button.rx.tap</span><br><span class=\"line\">            .subscribe(onNext: &#123;</span><br><span class=\"line\">                print(&quot;blick&quot;)</span><br><span class=\"line\">            &#125;).disposed(by: disposeBag)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可能也有人会疑问，<code>ControlEvent</code>在哪？查看tap方法，会看到源码（<code>UIButton+Rx.swift</code>），这个时候就会发现 UIButton 的<code>rx.tap</code>方法类型便是<code>ControlEvent&lt;Void&gt;</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import RxSwift</span><br><span class=\"line\">import UIKit</span><br><span class=\"line\"></span><br><span class=\"line\">extension Reactive where Base: UIButton &#123;</span><br><span class=\"line\">public var tap: ControlEvent&lt;Void&gt; &#123;</span><br><span class=\"line\">    return controlEvent(.touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，我们就对<code>Observable</code>有了一个简单的介绍。</p>\n"},{"title":"RxSwift 变换操作(Transforming Observables)","date":"2018-09-25T13:52:23.000Z","_content":"变换操作指的是对原始的`Observable`序列进行一些转换，类似于 Swift 中`CollectionType`的各种转换\n#### 1. buffer\n`buffer`操作符将缓存`Observable`中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。\n![buffer.png](https://upload-images.jianshu.io/upload_images/2855070-76c121cb942f7c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n🌰：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext([\"A\", \"B\", \"C\"])\nnext([\"🐯\", \"🐭\", \"🐱\"])\n```\n有一点疑问，对于`buffer`在`RxSwift`的解释是\n>Projects each element of an observable sequence into a buffer that's sent out when either it's full or a given amount of time has elapsed, using the specified scheduler to run timers\n\n`RxSwift`中，它的意思是当缓冲区满了或超过了给定的时间时，就会发出缓冲区。可是如果我们把上述代码稍微改变一下\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\n//  subject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext([\"A\", \"B\", \"C\"])\n```\n并没有后面的内容。因为我在很多文章里都看到说如果规定时间内不够要求的数量也会发出（有几个发几个，一个都没有发空数组 []）。所以，这点值得注意。\n#### 2. window\n- `window`操作符和`buffer`十分相似。不过`buffer`是周期性的将缓存的元素集合发送出来，而`window`周期性的将元素集合以`Observable`的形态发送出来。\n同时`buffer`要等到元素搜集完毕后，才会发出元素序列。而`window`可以实时发出元素序列。(这一点证明了`buffer`还是要元素搜集完毕后才会发出序列)\n![window.png](https://upload-images.jianshu.io/upload_images/2855070-4658ffd7d827e9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n首先我们先这么写：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\n......\n```\n可见他在不断打印`next(RxSwift.AddRef<Swift.String>)`\n如果把代码改成这样：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n    .subscribe(onNext: {\n        print(\"subscribe:\\($0)\")\n        $0.asObservable()\n            .subscribe{ print($0) }\n            .disposed(by: disposeBag)\n    })\n    .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nsubscribe:RxSwift.AddRef<Swift.String>\nnext(A)\nnext(B)\nnext(C)\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\nnext(🐯)\nnext(🐭)\nnext(🐱)\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\ncompleted\n```\n#### 3.map\n`map`操作符将`Observable`的每个元素应用你提供的转换方法，然后返回含有转换结果的`Observable`。\n![map.png](https://upload-images.jianshu.io/upload_images/2855070-def03bf478a9770d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1,2,3)\n        .map{ $0 * 2 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果如下：\n```\n2\n4\n6\n```\n其实，swift中也有一个高级函数`map`，可以对数组中的每一个元素做一次处理\n```\nlet array = [1, 2, 3]\nlet nums = array.map {\n    return $0 * 2\n}\nprint(nums)\n```\n结果得出：\n```\n[2, 4, 6]\n```\n#### 4. flatMap\n- `map`在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。\n- 而`flatMap`操作符会对源`Observable`的每一个元素应用一个转换方法，将他们转换成`Observables`。 然后将这些`Observables`的元素合并之后再发送出来。即又将其 \"拍扁\"（降维）成一个`Observable`序列。\n- 这个操作符是非常有用的。比如当`Observable`的元素本生拥有其他的`Observable`时，我们可以将所有子`Observables`的元素发送出来。\n\n![flatMap.png](https://upload-images.jianshu.io/upload_images/2855070-f40ff203991060c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .flatMap{ $0 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nvariable.value = second\nsecond.onNext(\"2\")\nfirst.onNext(\"3\")\n```\n打印结果如下：\n```\nA\n1\nB\n2\n3\n```\n我们依然可以在`Swift`中找到高级函数`flatMap`，它相比`map`有两点不同\n- `flatMap`返回后的数组中不存在`nil`，同时它会把`Optional`解包\n- `flatMap`还能把数组中存有数组的数组（二维数组、N维数组）一同打开变成一个新的数组\n- 也能把两个不同的数组合并成一个数组，这个合并的数组元素个数是前面两个数组元素个数的乘积\n\n只举一个🌰：\n```\nlet array = [[1, 2, 3], [4, 5, 6]]\nlet nums = array.flatMap{ $0 }\nprint(nums)\n```\n运行结果如下：\n```\n[1, 2, 3, 4, 5, 6]\n```\n#### 5. flatMapLatest\n`flatMapLatest`与`flatMap`的唯一区别是：`flatMapLatest`只会接收最新的`value`事件\n![flatMapLatest.png](https://upload-images.jianshu.io/upload_images/2855070-ac2d4f8e45ea1ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n将上述代码中`flatMap`改为`flatMapLatest`\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .flatMapLatest{ $0 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nvariable.value = second\nsecond.onNext(\"2\")\nfirst.onNext(\"3\")\n```\n运行结果如下：\n```\nA\n1\nB\n2\n```\n#### 6. concatMap\n`concatMap`操作符将源`Observable`的每一个元素应用一个转换方法，将他们转换成`Observables`。然后让这些`Observables` 按顺序的发出元素，当前一个`Observable`元素发送完毕后，后一个`Observable`才可以开始发出元素。等待前一个`Observable `产生完成事件后，才对后一个`Observable`进行订阅\n![concatMap.png](https://upload-images.jianshu.io/upload_images/2855070-5969d4c9a2013318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .concatMap{ $0 }\n        .subscribe(onNext: { print($0) })   \n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nfirst.onNext(\"2\")\n\nvariable.value = second\nsecond.onNext(\"3\")\nsecond.onNext(\"4\")\n\nfirst.onCompleted()\nsecond.onNext(\"5\")\n```\n运行结果如下：\n```\nA\n1\n2\n4\n5\n```\n#### 7. scan\n`scan`操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。\n![scan.png](https://upload-images.jianshu.io/upload_images/2855070-83cf372dd5b1cbe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 5)\n        .scan(0) { acum, elem  in\n            acum + elem\n        }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果如下：\n```\n1\n3\n6\n10\n15\n```\n#### 8. groupBy\n- `groupBy`操作符将源`Observable`分解为多个子`Observable`，然后将这些子`Observable`发送出来。\n- 也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以`Observable`的形态发送出来。\n![groupBy.png](https://upload-images.jianshu.io/upload_images/2855070-4193d29d366c8e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable<Int>.of(0, 1, 2, 3, 4, 5)\n        .groupBy { (element) -> String in\n            return element % 2 == 0 ? \"偶数\" : \"奇数\"\n        }\n        .subscribe { (event) in\n            switch event {\n            case .next(let group):\n                group.asObservable().subscribe({ (event) in\n                    print(\"key:\\(group.key)  event:\\(event)\")\n                })\n                .disposed(by: disposeBag)\n            default:\n                print(\"\")\n            }\n}.disposed(by: disposeBag)\n```\n运行结果如下：\n```\nkey:偶数  event:next(0)\nkey:奇数  event:next(1)\nkey:偶数  event:next(2)\nkey:奇数  event:next(3)\nkey:偶数  event:next(4)\nkey:奇数  event:next(5)\nkey:奇数  event:completed\nkey:偶数  event:completed\n```\n","source":"_posts/RxSwift-变换操作-Transforming-Observables.md","raw":"---\ntitle: RxSwift 变换操作(Transforming Observables)\ndate: 2018-09-25 21:52:23\ntags: RxSwift\n---\n变换操作指的是对原始的`Observable`序列进行一些转换，类似于 Swift 中`CollectionType`的各种转换\n#### 1. buffer\n`buffer`操作符将缓存`Observable`中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。\n![buffer.png](https://upload-images.jianshu.io/upload_images/2855070-76c121cb942f7c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n🌰：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext([\"A\", \"B\", \"C\"])\nnext([\"🐯\", \"🐭\", \"🐱\"])\n```\n有一点疑问，对于`buffer`在`RxSwift`的解释是\n>Projects each element of an observable sequence into a buffer that's sent out when either it's full or a given amount of time has elapsed, using the specified scheduler to run timers\n\n`RxSwift`中，它的意思是当缓冲区满了或超过了给定的时间时，就会发出缓冲区。可是如果我们把上述代码稍微改变一下\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\n//  subject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext([\"A\", \"B\", \"C\"])\n```\n并没有后面的内容。因为我在很多文章里都看到说如果规定时间内不够要求的数量也会发出（有几个发几个，一个都没有发空数组 []）。所以，这点值得注意。\n#### 2. window\n- `window`操作符和`buffer`十分相似。不过`buffer`是周期性的将缓存的元素集合发送出来，而`window`周期性的将元素集合以`Observable`的形态发送出来。\n同时`buffer`要等到元素搜集完毕后，才会发出元素序列。而`window`可以实时发出元素序列。(这一点证明了`buffer`还是要元素搜集完毕后才会发出序列)\n![window.png](https://upload-images.jianshu.io/upload_images/2855070-4658ffd7d827e9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n首先我们先这么写：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\n......\n```\n可见他在不断打印`next(RxSwift.AddRef<Swift.String>)`\n如果把代码改成这样：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n    .subscribe(onNext: {\n        print(\"subscribe:\\($0)\")\n        $0.asObservable()\n            .subscribe{ print($0) }\n            .disposed(by: disposeBag)\n    })\n    .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nsubscribe:RxSwift.AddRef<Swift.String>\nnext(A)\nnext(B)\nnext(C)\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\nnext(🐯)\nnext(🐭)\nnext(🐱)\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\ncompleted\n```\n#### 3.map\n`map`操作符将`Observable`的每个元素应用你提供的转换方法，然后返回含有转换结果的`Observable`。\n![map.png](https://upload-images.jianshu.io/upload_images/2855070-def03bf478a9770d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1,2,3)\n        .map{ $0 * 2 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果如下：\n```\n2\n4\n6\n```\n其实，swift中也有一个高级函数`map`，可以对数组中的每一个元素做一次处理\n```\nlet array = [1, 2, 3]\nlet nums = array.map {\n    return $0 * 2\n}\nprint(nums)\n```\n结果得出：\n```\n[2, 4, 6]\n```\n#### 4. flatMap\n- `map`在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。\n- 而`flatMap`操作符会对源`Observable`的每一个元素应用一个转换方法，将他们转换成`Observables`。 然后将这些`Observables`的元素合并之后再发送出来。即又将其 \"拍扁\"（降维）成一个`Observable`序列。\n- 这个操作符是非常有用的。比如当`Observable`的元素本生拥有其他的`Observable`时，我们可以将所有子`Observables`的元素发送出来。\n\n![flatMap.png](https://upload-images.jianshu.io/upload_images/2855070-f40ff203991060c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .flatMap{ $0 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nvariable.value = second\nsecond.onNext(\"2\")\nfirst.onNext(\"3\")\n```\n打印结果如下：\n```\nA\n1\nB\n2\n3\n```\n我们依然可以在`Swift`中找到高级函数`flatMap`，它相比`map`有两点不同\n- `flatMap`返回后的数组中不存在`nil`，同时它会把`Optional`解包\n- `flatMap`还能把数组中存有数组的数组（二维数组、N维数组）一同打开变成一个新的数组\n- 也能把两个不同的数组合并成一个数组，这个合并的数组元素个数是前面两个数组元素个数的乘积\n\n只举一个🌰：\n```\nlet array = [[1, 2, 3], [4, 5, 6]]\nlet nums = array.flatMap{ $0 }\nprint(nums)\n```\n运行结果如下：\n```\n[1, 2, 3, 4, 5, 6]\n```\n#### 5. flatMapLatest\n`flatMapLatest`与`flatMap`的唯一区别是：`flatMapLatest`只会接收最新的`value`事件\n![flatMapLatest.png](https://upload-images.jianshu.io/upload_images/2855070-ac2d4f8e45ea1ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n将上述代码中`flatMap`改为`flatMapLatest`\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .flatMapLatest{ $0 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nvariable.value = second\nsecond.onNext(\"2\")\nfirst.onNext(\"3\")\n```\n运行结果如下：\n```\nA\n1\nB\n2\n```\n#### 6. concatMap\n`concatMap`操作符将源`Observable`的每一个元素应用一个转换方法，将他们转换成`Observables`。然后让这些`Observables` 按顺序的发出元素，当前一个`Observable`元素发送完毕后，后一个`Observable`才可以开始发出元素。等待前一个`Observable `产生完成事件后，才对后一个`Observable`进行订阅\n![concatMap.png](https://upload-images.jianshu.io/upload_images/2855070-5969d4c9a2013318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .concatMap{ $0 }\n        .subscribe(onNext: { print($0) })   \n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nfirst.onNext(\"2\")\n\nvariable.value = second\nsecond.onNext(\"3\")\nsecond.onNext(\"4\")\n\nfirst.onCompleted()\nsecond.onNext(\"5\")\n```\n运行结果如下：\n```\nA\n1\n2\n4\n5\n```\n#### 7. scan\n`scan`操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。\n![scan.png](https://upload-images.jianshu.io/upload_images/2855070-83cf372dd5b1cbe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 5)\n        .scan(0) { acum, elem  in\n            acum + elem\n        }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果如下：\n```\n1\n3\n6\n10\n15\n```\n#### 8. groupBy\n- `groupBy`操作符将源`Observable`分解为多个子`Observable`，然后将这些子`Observable`发送出来。\n- 也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以`Observable`的形态发送出来。\n![groupBy.png](https://upload-images.jianshu.io/upload_images/2855070-4193d29d366c8e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable<Int>.of(0, 1, 2, 3, 4, 5)\n        .groupBy { (element) -> String in\n            return element % 2 == 0 ? \"偶数\" : \"奇数\"\n        }\n        .subscribe { (event) in\n            switch event {\n            case .next(let group):\n                group.asObservable().subscribe({ (event) in\n                    print(\"key:\\(group.key)  event:\\(event)\")\n                })\n                .disposed(by: disposeBag)\n            default:\n                print(\"\")\n            }\n}.disposed(by: disposeBag)\n```\n运行结果如下：\n```\nkey:偶数  event:next(0)\nkey:奇数  event:next(1)\nkey:偶数  event:next(2)\nkey:奇数  event:next(3)\nkey:偶数  event:next(4)\nkey:奇数  event:next(5)\nkey:奇数  event:completed\nkey:偶数  event:completed\n```\n","slug":"RxSwift-变换操作-Transforming-Observables","published":1,"updated":"2018-10-19T07:16:01.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0luh000pimcwdno893xu","content":"<p>变换操作指的是对原始的<code>Observable</code>序列进行一些转换，类似于 Swift 中<code>CollectionType</code>的各种转换</p>\n<h4 id=\"1-buffer\"><a href=\"#1-buffer\" class=\"headerlink\" title=\"1. buffer\"></a>1. buffer</h4><p><code>buffer</code>操作符将缓存<code>Observable</code>中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-76c121cb942f7c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"buffer.png\"><br>🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br><span class=\"line\">next([&quot;🐯&quot;, &quot;🐭&quot;, &quot;🐱&quot;])</span><br></pre></td></tr></table></figure></p>\n<p>有一点疑问，对于<code>buffer</code>在<code>RxSwift</code>的解释是</p>\n<blockquote>\n<p>Projects each element of an observable sequence into a buffer that’s sent out when either it’s full or a given amount of time has elapsed, using the specified scheduler to run timers</p>\n</blockquote>\n<p><code>RxSwift</code>中，它的意思是当缓冲区满了或超过了给定的时间时，就会发出缓冲区。可是如果我们把上述代码稍微改变一下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//  subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br></pre></td></tr></table></figure></p>\n<p>并没有后面的内容。因为我在很多文章里都看到说如果规定时间内不够要求的数量也会发出（有几个发几个，一个都没有发空数组 []）。所以，这点值得注意。</p>\n<h4 id=\"2-window\"><a href=\"#2-window\" class=\"headerlink\" title=\"2. window\"></a>2. window</h4><ul>\n<li><code>window</code>操作符和<code>buffer</code>十分相似。不过<code>buffer</code>是周期性的将缓存的元素集合发送出来，而<code>window</code>周期性的将元素集合以<code>Observable</code>的形态发送出来。<br>同时<code>buffer</code>要等到元素搜集完毕后，才会发出元素序列。而<code>window</code>可以实时发出元素序列。(这一点证明了<code>buffer</code>还是要元素搜集完毕后才会发出序列)<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4658ffd7d827e9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"window.png\"><br>首先我们先这么写：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure></p>\n<p>可见他在不断打印<code>next(RxSwift.AddRef&lt;Swift.String&gt;)</code><br>如果把代码改成这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .subscribe(onNext: &#123;</span><br><span class=\"line\">        print(&quot;subscribe:\\($0)&quot;)</span><br><span class=\"line\">        $0.asObservable()</span><br><span class=\"line\">            .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">            .disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">next(A)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">next(C)</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">next(🐯)</span><br><span class=\"line\">next(🐭)</span><br><span class=\"line\">next(🐱)</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-map\"><a href=\"#3-map\" class=\"headerlink\" title=\"3.map\"></a>3.map</h4><p><code>map</code>操作符将<code>Observable</code>的每个元素应用你提供的转换方法，然后返回含有转换结果的<code>Observable</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-def03bf478a9770d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"map.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1,2,3)</span><br><span class=\"line\">        .map&#123; $0 * 2 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure></p>\n<p>其实，swift中也有一个高级函数<code>map</code>，可以对数组中的每一个元素做一次处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let array = [1, 2, 3]</span><br><span class=\"line\">let nums = array.map &#123;</span><br><span class=\"line\">    return $0 * 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure></p>\n<p>结果得出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2, 4, 6]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-flatMap\"><a href=\"#4-flatMap\" class=\"headerlink\" title=\"4. flatMap\"></a>4. flatMap</h4><ul>\n<li><code>map</code>在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。</li>\n<li>而<code>flatMap</code>操作符会对源<code>Observable</code>的每一个元素应用一个转换方法，将他们转换成<code>Observables</code>。 然后将这些<code>Observables</code>的元素合并之后再发送出来。即又将其 “拍扁”（降维）成一个<code>Observable</code>序列。</li>\n<li>这个操作符是非常有用的。比如当<code>Observable</code>的元素本生拥有其他的<code>Observable</code>时，我们可以将所有子<code>Observables</code>的元素发送出来。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-f40ff203991060c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"flatMap.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .flatMap&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;2&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br></pre></td></tr></table></figure>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">B</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<p>我们依然可以在<code>Swift</code>中找到高级函数<code>flatMap</code>，它相比<code>map</code>有两点不同</p>\n<ul>\n<li><code>flatMap</code>返回后的数组中不存在<code>nil</code>，同时它会把<code>Optional</code>解包</li>\n<li><code>flatMap</code>还能把数组中存有数组的数组（二维数组、N维数组）一同打开变成一个新的数组</li>\n<li>也能把两个不同的数组合并成一个数组，这个合并的数组元素个数是前面两个数组元素个数的乘积</li>\n</ul>\n<p>只举一个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let array = [[1, 2, 3], [4, 5, 6]]</span><br><span class=\"line\">let nums = array.flatMap&#123; $0 &#125;</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-flatMapLatest\"><a href=\"#5-flatMapLatest\" class=\"headerlink\" title=\"5. flatMapLatest\"></a>5. flatMapLatest</h4><p><code>flatMapLatest</code>与<code>flatMap</code>的唯一区别是：<code>flatMapLatest</code>只会接收最新的<code>value</code>事件<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ac2d4f8e45ea1ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"flatMapLatest.png\"><br>将上述代码中<code>flatMap</code>改为<code>flatMapLatest</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .flatMapLatest&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;2&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">B</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-concatMap\"><a href=\"#6-concatMap\" class=\"headerlink\" title=\"6. concatMap\"></a>6. concatMap</h4><p><code>concatMap</code>操作符将源<code>Observable</code>的每一个元素应用一个转换方法，将他们转换成<code>Observables</code>。然后让这些<code>Observables</code> 按顺序的发出元素，当前一个<code>Observable</code>元素发送完毕后，后一个<code>Observable</code>才可以开始发出元素。等待前一个<code>Observable</code>产生完成事件后，才对后一个<code>Observable</code>进行订阅<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-5969d4c9a2013318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"concatMap.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .concatMap&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)   </span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;3&quot;)</span><br><span class=\"line\">second.onNext(&quot;4&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onCompleted()</span><br><span class=\"line\">second.onNext(&quot;5&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-scan\"><a href=\"#7-scan\" class=\"headerlink\" title=\"7. scan\"></a>7. scan</h4><p><code>scan</code>操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-83cf372dd5b1cbe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scan.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 5)</span><br><span class=\"line\">        .scan(0) &#123; acum, elem  in</span><br><span class=\"line\">            acum + elem</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">6</span><br><span class=\"line\">10</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-groupBy\"><a href=\"#8-groupBy\" class=\"headerlink\" title=\"8. groupBy\"></a>8. groupBy</h4><ul>\n<li><code>groupBy</code>操作符将源<code>Observable</code>分解为多个子<code>Observable</code>，然后将这些子<code>Observable</code>发送出来。</li>\n<li>也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以<code>Observable</code>的形态发送出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4193d29d366c8e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"groupBy.png\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable&lt;Int&gt;.of(0, 1, 2, 3, 4, 5)</span><br><span class=\"line\">        .groupBy &#123; (element) -&gt; String in</span><br><span class=\"line\">            return element % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .subscribe &#123; (event) in</span><br><span class=\"line\">            switch event &#123;</span><br><span class=\"line\">            case .next(let group):</span><br><span class=\"line\">                group.asObservable().subscribe(&#123; (event) in</span><br><span class=\"line\">                    print(&quot;key:\\(group.key)  event:\\(event)&quot;)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .disposed(by: disposeBag)</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                print(&quot;&quot;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key:偶数  event:next(0)</span><br><span class=\"line\">key:奇数  event:next(1)</span><br><span class=\"line\">key:偶数  event:next(2)</span><br><span class=\"line\">key:奇数  event:next(3)</span><br><span class=\"line\">key:偶数  event:next(4)</span><br><span class=\"line\">key:奇数  event:next(5)</span><br><span class=\"line\">key:奇数  event:completed</span><br><span class=\"line\">key:偶数  event:completed</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>变换操作指的是对原始的<code>Observable</code>序列进行一些转换，类似于 Swift 中<code>CollectionType</code>的各种转换</p>\n<h4 id=\"1-buffer\"><a href=\"#1-buffer\" class=\"headerlink\" title=\"1. buffer\"></a>1. buffer</h4><p><code>buffer</code>操作符将缓存<code>Observable</code>中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-76c121cb942f7c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"buffer.png\"><br>🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br><span class=\"line\">next([&quot;🐯&quot;, &quot;🐭&quot;, &quot;🐱&quot;])</span><br></pre></td></tr></table></figure></p>\n<p>有一点疑问，对于<code>buffer</code>在<code>RxSwift</code>的解释是</p>\n<blockquote>\n<p>Projects each element of an observable sequence into a buffer that’s sent out when either it’s full or a given amount of time has elapsed, using the specified scheduler to run timers</p>\n</blockquote>\n<p><code>RxSwift</code>中，它的意思是当缓冲区满了或超过了给定的时间时，就会发出缓冲区。可是如果我们把上述代码稍微改变一下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//  subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br></pre></td></tr></table></figure></p>\n<p>并没有后面的内容。因为我在很多文章里都看到说如果规定时间内不够要求的数量也会发出（有几个发几个，一个都没有发空数组 []）。所以，这点值得注意。</p>\n<h4 id=\"2-window\"><a href=\"#2-window\" class=\"headerlink\" title=\"2. window\"></a>2. window</h4><ul>\n<li><code>window</code>操作符和<code>buffer</code>十分相似。不过<code>buffer</code>是周期性的将缓存的元素集合发送出来，而<code>window</code>周期性的将元素集合以<code>Observable</code>的形态发送出来。<br>同时<code>buffer</code>要等到元素搜集完毕后，才会发出元素序列。而<code>window</code>可以实时发出元素序列。(这一点证明了<code>buffer</code>还是要元素搜集完毕后才会发出序列)<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4658ffd7d827e9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"window.png\"><br>首先我们先这么写：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure></p>\n<p>可见他在不断打印<code>next(RxSwift.AddRef&lt;Swift.String&gt;)</code><br>如果把代码改成这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .subscribe(onNext: &#123;</span><br><span class=\"line\">        print(&quot;subscribe:\\($0)&quot;)</span><br><span class=\"line\">        $0.asObservable()</span><br><span class=\"line\">            .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">            .disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">next(A)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">next(C)</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">next(🐯)</span><br><span class=\"line\">next(🐭)</span><br><span class=\"line\">next(🐱)</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-map\"><a href=\"#3-map\" class=\"headerlink\" title=\"3.map\"></a>3.map</h4><p><code>map</code>操作符将<code>Observable</code>的每个元素应用你提供的转换方法，然后返回含有转换结果的<code>Observable</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-def03bf478a9770d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"map.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1,2,3)</span><br><span class=\"line\">        .map&#123; $0 * 2 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure></p>\n<p>其实，swift中也有一个高级函数<code>map</code>，可以对数组中的每一个元素做一次处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let array = [1, 2, 3]</span><br><span class=\"line\">let nums = array.map &#123;</span><br><span class=\"line\">    return $0 * 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure></p>\n<p>结果得出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2, 4, 6]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-flatMap\"><a href=\"#4-flatMap\" class=\"headerlink\" title=\"4. flatMap\"></a>4. flatMap</h4><ul>\n<li><code>map</code>在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。</li>\n<li>而<code>flatMap</code>操作符会对源<code>Observable</code>的每一个元素应用一个转换方法，将他们转换成<code>Observables</code>。 然后将这些<code>Observables</code>的元素合并之后再发送出来。即又将其 “拍扁”（降维）成一个<code>Observable</code>序列。</li>\n<li>这个操作符是非常有用的。比如当<code>Observable</code>的元素本生拥有其他的<code>Observable</code>时，我们可以将所有子<code>Observables</code>的元素发送出来。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-f40ff203991060c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"flatMap.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .flatMap&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;2&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br></pre></td></tr></table></figure>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">B</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<p>我们依然可以在<code>Swift</code>中找到高级函数<code>flatMap</code>，它相比<code>map</code>有两点不同</p>\n<ul>\n<li><code>flatMap</code>返回后的数组中不存在<code>nil</code>，同时它会把<code>Optional</code>解包</li>\n<li><code>flatMap</code>还能把数组中存有数组的数组（二维数组、N维数组）一同打开变成一个新的数组</li>\n<li>也能把两个不同的数组合并成一个数组，这个合并的数组元素个数是前面两个数组元素个数的乘积</li>\n</ul>\n<p>只举一个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let array = [[1, 2, 3], [4, 5, 6]]</span><br><span class=\"line\">let nums = array.flatMap&#123; $0 &#125;</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-flatMapLatest\"><a href=\"#5-flatMapLatest\" class=\"headerlink\" title=\"5. flatMapLatest\"></a>5. flatMapLatest</h4><p><code>flatMapLatest</code>与<code>flatMap</code>的唯一区别是：<code>flatMapLatest</code>只会接收最新的<code>value</code>事件<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ac2d4f8e45ea1ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"flatMapLatest.png\"><br>将上述代码中<code>flatMap</code>改为<code>flatMapLatest</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .flatMapLatest&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;2&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">B</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-concatMap\"><a href=\"#6-concatMap\" class=\"headerlink\" title=\"6. concatMap\"></a>6. concatMap</h4><p><code>concatMap</code>操作符将源<code>Observable</code>的每一个元素应用一个转换方法，将他们转换成<code>Observables</code>。然后让这些<code>Observables</code> 按顺序的发出元素，当前一个<code>Observable</code>元素发送完毕后，后一个<code>Observable</code>才可以开始发出元素。等待前一个<code>Observable</code>产生完成事件后，才对后一个<code>Observable</code>进行订阅<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-5969d4c9a2013318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"concatMap.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .concatMap&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)   </span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;3&quot;)</span><br><span class=\"line\">second.onNext(&quot;4&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onCompleted()</span><br><span class=\"line\">second.onNext(&quot;5&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-scan\"><a href=\"#7-scan\" class=\"headerlink\" title=\"7. scan\"></a>7. scan</h4><p><code>scan</code>操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-83cf372dd5b1cbe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scan.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 5)</span><br><span class=\"line\">        .scan(0) &#123; acum, elem  in</span><br><span class=\"line\">            acum + elem</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">6</span><br><span class=\"line\">10</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-groupBy\"><a href=\"#8-groupBy\" class=\"headerlink\" title=\"8. groupBy\"></a>8. groupBy</h4><ul>\n<li><code>groupBy</code>操作符将源<code>Observable</code>分解为多个子<code>Observable</code>，然后将这些子<code>Observable</code>发送出来。</li>\n<li>也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以<code>Observable</code>的形态发送出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4193d29d366c8e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"groupBy.png\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable&lt;Int&gt;.of(0, 1, 2, 3, 4, 5)</span><br><span class=\"line\">        .groupBy &#123; (element) -&gt; String in</span><br><span class=\"line\">            return element % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .subscribe &#123; (event) in</span><br><span class=\"line\">            switch event &#123;</span><br><span class=\"line\">            case .next(let group):</span><br><span class=\"line\">                group.asObservable().subscribe(&#123; (event) in</span><br><span class=\"line\">                    print(&quot;key:\\(group.key)  event:\\(event)&quot;)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .disposed(by: disposeBag)</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                print(&quot;&quot;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key:偶数  event:next(0)</span><br><span class=\"line\">key:奇数  event:next(1)</span><br><span class=\"line\">key:偶数  event:next(2)</span><br><span class=\"line\">key:奇数  event:next(3)</span><br><span class=\"line\">key:偶数  event:next(4)</span><br><span class=\"line\">key:奇数  event:next(5)</span><br><span class=\"line\">key:奇数  event:completed</span><br><span class=\"line\">key:偶数  event:completed</span><br></pre></td></tr></table></figure></p>\n"},{"title":"RxSwift 操作符决策树","date":"2018-09-30T13:59:24.000Z","_content":"之前列举了很多操作符的用法，还有很多我们没有列举的。其实写了那么多操作符有时候我还是会忘记选择哪一个。这个时候，我发现在[RxSwift中文文档](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html)有一篇关于选择操作符的文章。这一篇水文纯搬运。\n### 决策树\n\n**我想要创建一个 `Observable`**\n\n*   产生特定的一个元素：[just](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/just.html)\n*   经过一段延时：[timer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html)\n*   从一个序列拉取元素：[from](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/from.html)\n*   重复的产生某一个元素：[repeatElement](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/repeatElement.html)\n*   存在自定义逻辑：[create](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/create.html)\n*   每次订阅时产生：[deferred](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/deferred.html)\n*   每隔一段时间，发出一个元素：[interval](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/interval.html)\n*   在一段延时后：[timer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html)\n*   一个空序列，只有一个完成事件：[empty](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/empty.html)\n*   一个任何事件都没有产生的序列：[never](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/never.html)\n\n**我想要创建一个 `Observable` 通过组合其他的 `Observables`**\n\n*   任意一个 `Observable` 产生了元素，就发出这个元素：[merge](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/merge.html)\n*   让这些 `Observables` 一个接一个的发出元素，当上一个 `Observable` 元素发送完毕后，下一个`Observable` 才能开始发出元素：[concat](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concat.html)\n*   组合多个 `Observables` 的元素\n*   当每一个 `Observable` 都发出一个新的元素：[zip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/zip.html)\n*   当任意一个 `Observable` 发出一个新的元素：[combineLatest](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/combineLatest.html)\n\n**我想要转换 `Observable` 的元素后，再将它们发出来**\n\n*   对每个元素直接转换：[map](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/map.html)\n*   转换到另一个 `Observable`：[flatMap](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMap.html)\n*   只接收最新的元素转换的 `Observable` 所产生的元素：[flatMapLatest](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMapLatest.html)\n*   每一个元素转换的 `Observable` 按顺序产生元素：[concatMap](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concatMap.html)\n*   基于所有遍历过的元素： [scan](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html)\n\n**我想要将产生的每一个元素，拖延一段时间后再发出：[delay](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delay.html)**\n\n**我想要将产生的事件封装成元素发送出来**\n\n*   将他们封装成 `Event<Element>`：[materialize](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/materialize.html)\n*   然后解封出来：[dematerialize](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/dematerialize.html)\n\n**我想要忽略掉所有的 `next` 事件，只接收 `completed` 和 `error` 事件：[ignoreElements](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/ignoreElements.html)**\n\n**我想创建一个新的 `Observable` 在原有的序列前面加入一些元素：[startWith](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/startWith.html)**\n\n**我想从 `Observable` 中收集元素，缓存这些元素之后在发出：[buffer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/buffer.html)**\n\n**我想将 `Observable` 拆分成多个 `Observables`：[window](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/window.html)**\n\n*   基于元素的共同特征：[groupBy](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/groupBy.html)\n\n**我想只接收 `Observable` 中特定的元素**\n\n*   发出唯一的元素：[single](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/single.html)\n\n**我想重新从 `Observable` 中发出某些元素**\n\n*   通过判定条件过滤出一些元素：[filter](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/filter.html)\n*   仅仅发出头几个元素：[take](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html)\n*   仅仅发出尾部的几个元素：[takeLast](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeLast.html)\n*   仅仅发出第 n 个元素：[elementAt](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/elementAt.html)\n*   跳过头几个元素\n*   跳过头 n 个元素：[skip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html)\n*   跳过头几个满足判定的元素：[skipWhile](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html)，[skipWhileWithIndex](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html)\n*   跳过某段时间内产生的头几个元素：[skip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html)\n*   跳过头几个元素直到另一个 `Observable` 发出一个元素：[skipUntil](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipUntil.html)\n*   只取头几个元素\n*   只取头几个满足判定的元素：[takeWhile](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html)，[takeWhileWithIndex](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html)\n*   只取某段时间内产生的头几个元素：[take](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html)\n*   只取头几个元素直到另一个 `Observable` 发出一个元素：[takeUntil](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeUntil.html)\n*   周期性的对 `Observable` 抽样：[sample](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/sample.html)\n*   发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生：[debounce](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/debounce.html)\n*   直到元素的值发生变化，才发出新的元素：[distinctUntilChanged](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html)\n*   并提供元素是否相等的判定函数：[distinctUntilChanged](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html)\n*   在开始发出元素时，延时后进行订阅：[delaySubscription](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delaySubscription.html)\n\n**我想要从一些 `Observables` 中，只取第一个产生元素的 `Observable`：[amb](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/amb.html)**\n\n**我想评估 `Observable` 的全部元素**\n\n*   并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果：[reduce](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/reduce.html)\n*   并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果：[scan](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html)\n\n**我想把 `Observable` 转换为其他的数据结构：as...**\n\n**我想在某个 [Scheduler](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html) 应用操作符：[subscribeOn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html)**\n\n*   在某个 [Scheduler](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html) 监听：[observeOn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html)\n\n**我想要 `Observable` 发生某个事件时, 采取某个行动：[do](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/do.html)**\n\n**我想要 `Observable` 发出一个 `error` 事件：[error](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/error.html)**\n\n*   如果规定时间内没有产生元素：[timeout](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html)\n\n**我想要 `Observable` 发生错误时，优雅的恢复**\n\n*   如果规定时间内没有产生元素，就切换到备选 `Observable` ：[timeout](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html)\n*   如果产生错误，将错误替换成某个元素 ：[catchErrorJustReturn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html)\n*   如果产生错误，就切换到备选 `Observable` ：[catchError](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html)\n*   如果产生错误，就重试 ：[retry](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/retry.html)\n\n**我创建一个 `Disposable` 资源，使它与 `Observable` 具有相同的寿命：[using](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/using.html)**\n\n**我创建一个 `Observable`，直到我通知它可以产生元素后，才能产生元素：[publish](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/publish.html)**\n\n*   并且，就算是在产生元素后订阅，也要发出全部元素：[replay](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/replay.html)\n*   并且，一旦所有观察者取消观察，他就被释放掉：[refCount](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/refCount.html)\n*   通知它可以产生元素了：[connect](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/connect.html)\n\n笨鸟先飞，执行合一。基本了解`RxSwift`后，就应该动手写一些BUG了。\n","source":"_posts/RxSwift-操作符决策树.md","raw":"---\ntitle: RxSwift 操作符决策树\ndate: 2018-09-30 21:59:24\ntags: RxSwift\n---\n之前列举了很多操作符的用法，还有很多我们没有列举的。其实写了那么多操作符有时候我还是会忘记选择哪一个。这个时候，我发现在[RxSwift中文文档](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html)有一篇关于选择操作符的文章。这一篇水文纯搬运。\n### 决策树\n\n**我想要创建一个 `Observable`**\n\n*   产生特定的一个元素：[just](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/just.html)\n*   经过一段延时：[timer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html)\n*   从一个序列拉取元素：[from](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/from.html)\n*   重复的产生某一个元素：[repeatElement](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/repeatElement.html)\n*   存在自定义逻辑：[create](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/create.html)\n*   每次订阅时产生：[deferred](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/deferred.html)\n*   每隔一段时间，发出一个元素：[interval](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/interval.html)\n*   在一段延时后：[timer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html)\n*   一个空序列，只有一个完成事件：[empty](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/empty.html)\n*   一个任何事件都没有产生的序列：[never](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/never.html)\n\n**我想要创建一个 `Observable` 通过组合其他的 `Observables`**\n\n*   任意一个 `Observable` 产生了元素，就发出这个元素：[merge](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/merge.html)\n*   让这些 `Observables` 一个接一个的发出元素，当上一个 `Observable` 元素发送完毕后，下一个`Observable` 才能开始发出元素：[concat](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concat.html)\n*   组合多个 `Observables` 的元素\n*   当每一个 `Observable` 都发出一个新的元素：[zip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/zip.html)\n*   当任意一个 `Observable` 发出一个新的元素：[combineLatest](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/combineLatest.html)\n\n**我想要转换 `Observable` 的元素后，再将它们发出来**\n\n*   对每个元素直接转换：[map](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/map.html)\n*   转换到另一个 `Observable`：[flatMap](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMap.html)\n*   只接收最新的元素转换的 `Observable` 所产生的元素：[flatMapLatest](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMapLatest.html)\n*   每一个元素转换的 `Observable` 按顺序产生元素：[concatMap](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concatMap.html)\n*   基于所有遍历过的元素： [scan](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html)\n\n**我想要将产生的每一个元素，拖延一段时间后再发出：[delay](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delay.html)**\n\n**我想要将产生的事件封装成元素发送出来**\n\n*   将他们封装成 `Event<Element>`：[materialize](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/materialize.html)\n*   然后解封出来：[dematerialize](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/dematerialize.html)\n\n**我想要忽略掉所有的 `next` 事件，只接收 `completed` 和 `error` 事件：[ignoreElements](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/ignoreElements.html)**\n\n**我想创建一个新的 `Observable` 在原有的序列前面加入一些元素：[startWith](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/startWith.html)**\n\n**我想从 `Observable` 中收集元素，缓存这些元素之后在发出：[buffer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/buffer.html)**\n\n**我想将 `Observable` 拆分成多个 `Observables`：[window](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/window.html)**\n\n*   基于元素的共同特征：[groupBy](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/groupBy.html)\n\n**我想只接收 `Observable` 中特定的元素**\n\n*   发出唯一的元素：[single](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/single.html)\n\n**我想重新从 `Observable` 中发出某些元素**\n\n*   通过判定条件过滤出一些元素：[filter](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/filter.html)\n*   仅仅发出头几个元素：[take](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html)\n*   仅仅发出尾部的几个元素：[takeLast](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeLast.html)\n*   仅仅发出第 n 个元素：[elementAt](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/elementAt.html)\n*   跳过头几个元素\n*   跳过头 n 个元素：[skip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html)\n*   跳过头几个满足判定的元素：[skipWhile](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html)，[skipWhileWithIndex](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html)\n*   跳过某段时间内产生的头几个元素：[skip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html)\n*   跳过头几个元素直到另一个 `Observable` 发出一个元素：[skipUntil](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipUntil.html)\n*   只取头几个元素\n*   只取头几个满足判定的元素：[takeWhile](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html)，[takeWhileWithIndex](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html)\n*   只取某段时间内产生的头几个元素：[take](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html)\n*   只取头几个元素直到另一个 `Observable` 发出一个元素：[takeUntil](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeUntil.html)\n*   周期性的对 `Observable` 抽样：[sample](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/sample.html)\n*   发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生：[debounce](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/debounce.html)\n*   直到元素的值发生变化，才发出新的元素：[distinctUntilChanged](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html)\n*   并提供元素是否相等的判定函数：[distinctUntilChanged](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html)\n*   在开始发出元素时，延时后进行订阅：[delaySubscription](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delaySubscription.html)\n\n**我想要从一些 `Observables` 中，只取第一个产生元素的 `Observable`：[amb](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/amb.html)**\n\n**我想评估 `Observable` 的全部元素**\n\n*   并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果：[reduce](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/reduce.html)\n*   并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果：[scan](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html)\n\n**我想把 `Observable` 转换为其他的数据结构：as...**\n\n**我想在某个 [Scheduler](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html) 应用操作符：[subscribeOn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html)**\n\n*   在某个 [Scheduler](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html) 监听：[observeOn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html)\n\n**我想要 `Observable` 发生某个事件时, 采取某个行动：[do](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/do.html)**\n\n**我想要 `Observable` 发出一个 `error` 事件：[error](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/error.html)**\n\n*   如果规定时间内没有产生元素：[timeout](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html)\n\n**我想要 `Observable` 发生错误时，优雅的恢复**\n\n*   如果规定时间内没有产生元素，就切换到备选 `Observable` ：[timeout](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html)\n*   如果产生错误，将错误替换成某个元素 ：[catchErrorJustReturn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html)\n*   如果产生错误，就切换到备选 `Observable` ：[catchError](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html)\n*   如果产生错误，就重试 ：[retry](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/retry.html)\n\n**我创建一个 `Disposable` 资源，使它与 `Observable` 具有相同的寿命：[using](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/using.html)**\n\n**我创建一个 `Observable`，直到我通知它可以产生元素后，才能产生元素：[publish](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/publish.html)**\n\n*   并且，就算是在产生元素后订阅，也要发出全部元素：[replay](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/replay.html)\n*   并且，一旦所有观察者取消观察，他就被释放掉：[refCount](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/refCount.html)\n*   通知它可以产生元素了：[connect](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/connect.html)\n\n笨鸟先飞，执行合一。基本了解`RxSwift`后，就应该动手写一些BUG了。\n","slug":"RxSwift-操作符决策树","published":1,"updated":"2018-10-19T07:16:01.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0luj000rimcwiom6ia9c","content":"<p>之前列举了很多操作符的用法，还有很多我们没有列举的。其实写了那么多操作符有时候我还是会忘记选择哪一个。这个时候，我发现在<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html\" target=\"_blank\" rel=\"noopener\">RxSwift中文文档</a>有一篇关于选择操作符的文章。这一篇水文纯搬运。</p>\n<h3 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h3><p><strong>我想要创建一个 <code>Observable</code></strong></p>\n<ul>\n<li>产生特定的一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/just.html\" target=\"_blank\" rel=\"noopener\">just</a></li>\n<li>经过一段延时：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html\" target=\"_blank\" rel=\"noopener\">timer</a></li>\n<li>从一个序列拉取元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/from.html\" target=\"_blank\" rel=\"noopener\">from</a></li>\n<li>重复的产生某一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/repeatElement.html\" target=\"_blank\" rel=\"noopener\">repeatElement</a></li>\n<li>存在自定义逻辑：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/create.html\" target=\"_blank\" rel=\"noopener\">create</a></li>\n<li>每次订阅时产生：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/deferred.html\" target=\"_blank\" rel=\"noopener\">deferred</a></li>\n<li>每隔一段时间，发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/interval.html\" target=\"_blank\" rel=\"noopener\">interval</a></li>\n<li>在一段延时后：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html\" target=\"_blank\" rel=\"noopener\">timer</a></li>\n<li>一个空序列，只有一个完成事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/empty.html\" target=\"_blank\" rel=\"noopener\">empty</a></li>\n<li>一个任何事件都没有产生的序列：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/never.html\" target=\"_blank\" rel=\"noopener\">never</a></li>\n</ul>\n<p><strong>我想要创建一个 <code>Observable</code> 通过组合其他的 <code>Observables</code></strong></p>\n<ul>\n<li>任意一个 <code>Observable</code> 产生了元素，就发出这个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/merge.html\" target=\"_blank\" rel=\"noopener\">merge</a></li>\n<li>让这些 <code>Observables</code> 一个接一个的发出元素，当上一个 <code>Observable</code> 元素发送完毕后，下一个<code>Observable</code> 才能开始发出元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concat.html\" target=\"_blank\" rel=\"noopener\">concat</a></li>\n<li>组合多个 <code>Observables</code> 的元素</li>\n<li>当每一个 <code>Observable</code> 都发出一个新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/zip.html\" target=\"_blank\" rel=\"noopener\">zip</a></li>\n<li>当任意一个 <code>Observable</code> 发出一个新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/combineLatest.html\" target=\"_blank\" rel=\"noopener\">combineLatest</a></li>\n</ul>\n<p><strong>我想要转换 <code>Observable</code> 的元素后，再将它们发出来</strong></p>\n<ul>\n<li>对每个元素直接转换：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/map.html\" target=\"_blank\" rel=\"noopener\">map</a></li>\n<li>转换到另一个 <code>Observable</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMap.html\" target=\"_blank\" rel=\"noopener\">flatMap</a></li>\n<li>只接收最新的元素转换的 <code>Observable</code> 所产生的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMapLatest.html\" target=\"_blank\" rel=\"noopener\">flatMapLatest</a></li>\n<li>每一个元素转换的 <code>Observable</code> 按顺序产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concatMap.html\" target=\"_blank\" rel=\"noopener\">concatMap</a></li>\n<li>基于所有遍历过的元素： <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html\" target=\"_blank\" rel=\"noopener\">scan</a></li>\n</ul>\n<p><strong>我想要将产生的每一个元素，拖延一段时间后再发出：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delay.html\" target=\"_blank\" rel=\"noopener\">delay</a></strong></p>\n<p><strong>我想要将产生的事件封装成元素发送出来</strong></p>\n<ul>\n<li>将他们封装成 <code>Event&lt;Element&gt;</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/materialize.html\" target=\"_blank\" rel=\"noopener\">materialize</a></li>\n<li>然后解封出来：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/dematerialize.html\" target=\"_blank\" rel=\"noopener\">dematerialize</a></li>\n</ul>\n<p><strong>我想要忽略掉所有的 <code>next</code> 事件，只接收 <code>completed</code> 和 <code>error</code> 事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/ignoreElements.html\" target=\"_blank\" rel=\"noopener\">ignoreElements</a></strong></p>\n<p><strong>我想创建一个新的 <code>Observable</code> 在原有的序列前面加入一些元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/startWith.html\" target=\"_blank\" rel=\"noopener\">startWith</a></strong></p>\n<p><strong>我想从 <code>Observable</code> 中收集元素，缓存这些元素之后在发出：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/buffer.html\" target=\"_blank\" rel=\"noopener\">buffer</a></strong></p>\n<p><strong>我想将 <code>Observable</code> 拆分成多个 <code>Observables</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/window.html\" target=\"_blank\" rel=\"noopener\">window</a></strong></p>\n<ul>\n<li>基于元素的共同特征：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/groupBy.html\" target=\"_blank\" rel=\"noopener\">groupBy</a></li>\n</ul>\n<p><strong>我想只接收 <code>Observable</code> 中特定的元素</strong></p>\n<ul>\n<li>发出唯一的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/single.html\" target=\"_blank\" rel=\"noopener\">single</a></li>\n</ul>\n<p><strong>我想重新从 <code>Observable</code> 中发出某些元素</strong></p>\n<ul>\n<li>通过判定条件过滤出一些元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/filter.html\" target=\"_blank\" rel=\"noopener\">filter</a></li>\n<li>仅仅发出头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html\" target=\"_blank\" rel=\"noopener\">take</a></li>\n<li>仅仅发出尾部的几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeLast.html\" target=\"_blank\" rel=\"noopener\">takeLast</a></li>\n<li>仅仅发出第 n 个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/elementAt.html\" target=\"_blank\" rel=\"noopener\">elementAt</a></li>\n<li>跳过头几个元素</li>\n<li>跳过头 n 个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html\" target=\"_blank\" rel=\"noopener\">skip</a></li>\n<li>跳过头几个满足判定的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html\" target=\"_blank\" rel=\"noopener\">skipWhile</a>，<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html\" target=\"_blank\" rel=\"noopener\">skipWhileWithIndex</a></li>\n<li>跳过某段时间内产生的头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html\" target=\"_blank\" rel=\"noopener\">skip</a></li>\n<li>跳过头几个元素直到另一个 <code>Observable</code> 发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipUntil.html\" target=\"_blank\" rel=\"noopener\">skipUntil</a></li>\n<li>只取头几个元素</li>\n<li>只取头几个满足判定的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html\" target=\"_blank\" rel=\"noopener\">takeWhile</a>，<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html\" target=\"_blank\" rel=\"noopener\">takeWhileWithIndex</a></li>\n<li>只取某段时间内产生的头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html\" target=\"_blank\" rel=\"noopener\">take</a></li>\n<li>只取头几个元素直到另一个 <code>Observable</code> 发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeUntil.html\" target=\"_blank\" rel=\"noopener\">takeUntil</a></li>\n<li>周期性的对 <code>Observable</code> 抽样：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/sample.html\" target=\"_blank\" rel=\"noopener\">sample</a></li>\n<li>发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/debounce.html\" target=\"_blank\" rel=\"noopener\">debounce</a></li>\n<li>直到元素的值发生变化，才发出新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html\" target=\"_blank\" rel=\"noopener\">distinctUntilChanged</a></li>\n<li>并提供元素是否相等的判定函数：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html\" target=\"_blank\" rel=\"noopener\">distinctUntilChanged</a></li>\n<li>在开始发出元素时，延时后进行订阅：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delaySubscription.html\" target=\"_blank\" rel=\"noopener\">delaySubscription</a></li>\n</ul>\n<p><strong>我想要从一些 <code>Observables</code> 中，只取第一个产生元素的 <code>Observable</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/amb.html\" target=\"_blank\" rel=\"noopener\">amb</a></strong></p>\n<p><strong>我想评估 <code>Observable</code> 的全部元素</strong></p>\n<ul>\n<li>并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/reduce.html\" target=\"_blank\" rel=\"noopener\">reduce</a></li>\n<li>并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html\" target=\"_blank\" rel=\"noopener\">scan</a></li>\n</ul>\n<p><strong>我想把 <code>Observable</code> 转换为其他的数据结构：as…</strong></p>\n<p><strong>我想在某个 <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html\" target=\"_blank\" rel=\"noopener\">Scheduler</a> 应用操作符：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html\" target=\"_blank\" rel=\"noopener\">subscribeOn</a></strong></p>\n<ul>\n<li>在某个 <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html\" target=\"_blank\" rel=\"noopener\">Scheduler</a> 监听：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html\" target=\"_blank\" rel=\"noopener\">observeOn</a></li>\n</ul>\n<p><strong>我想要 <code>Observable</code> 发生某个事件时, 采取某个行动：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/do.html\" target=\"_blank\" rel=\"noopener\">do</a></strong></p>\n<p><strong>我想要 <code>Observable</code> 发出一个 <code>error</code> 事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/error.html\" target=\"_blank\" rel=\"noopener\">error</a></strong></p>\n<ul>\n<li>如果规定时间内没有产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html\" target=\"_blank\" rel=\"noopener\">timeout</a></li>\n</ul>\n<p><strong>我想要 <code>Observable</code> 发生错误时，优雅的恢复</strong></p>\n<ul>\n<li>如果规定时间内没有产生元素，就切换到备选 <code>Observable</code> ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html\" target=\"_blank\" rel=\"noopener\">timeout</a></li>\n<li>如果产生错误，将错误替换成某个元素 ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html\" target=\"_blank\" rel=\"noopener\">catchErrorJustReturn</a></li>\n<li>如果产生错误，就切换到备选 <code>Observable</code> ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html\" target=\"_blank\" rel=\"noopener\">catchError</a></li>\n<li>如果产生错误，就重试 ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/retry.html\" target=\"_blank\" rel=\"noopener\">retry</a></li>\n</ul>\n<p><strong>我创建一个 <code>Disposable</code> 资源，使它与 <code>Observable</code> 具有相同的寿命：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/using.html\" target=\"_blank\" rel=\"noopener\">using</a></strong></p>\n<p><strong>我创建一个 <code>Observable</code>，直到我通知它可以产生元素后，才能产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/publish.html\" target=\"_blank\" rel=\"noopener\">publish</a></strong></p>\n<ul>\n<li>并且，就算是在产生元素后订阅，也要发出全部元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/replay.html\" target=\"_blank\" rel=\"noopener\">replay</a></li>\n<li>并且，一旦所有观察者取消观察，他就被释放掉：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/refCount.html\" target=\"_blank\" rel=\"noopener\">refCount</a></li>\n<li>通知它可以产生元素了：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/connect.html\" target=\"_blank\" rel=\"noopener\">connect</a></li>\n</ul>\n<p>笨鸟先飞，执行合一。基本了解<code>RxSwift</code>后，就应该动手写一些BUG了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前列举了很多操作符的用法，还有很多我们没有列举的。其实写了那么多操作符有时候我还是会忘记选择哪一个。这个时候，我发现在<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html\" target=\"_blank\" rel=\"noopener\">RxSwift中文文档</a>有一篇关于选择操作符的文章。这一篇水文纯搬运。</p>\n<h3 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h3><p><strong>我想要创建一个 <code>Observable</code></strong></p>\n<ul>\n<li>产生特定的一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/just.html\" target=\"_blank\" rel=\"noopener\">just</a></li>\n<li>经过一段延时：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html\" target=\"_blank\" rel=\"noopener\">timer</a></li>\n<li>从一个序列拉取元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/from.html\" target=\"_blank\" rel=\"noopener\">from</a></li>\n<li>重复的产生某一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/repeatElement.html\" target=\"_blank\" rel=\"noopener\">repeatElement</a></li>\n<li>存在自定义逻辑：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/create.html\" target=\"_blank\" rel=\"noopener\">create</a></li>\n<li>每次订阅时产生：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/deferred.html\" target=\"_blank\" rel=\"noopener\">deferred</a></li>\n<li>每隔一段时间，发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/interval.html\" target=\"_blank\" rel=\"noopener\">interval</a></li>\n<li>在一段延时后：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html\" target=\"_blank\" rel=\"noopener\">timer</a></li>\n<li>一个空序列，只有一个完成事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/empty.html\" target=\"_blank\" rel=\"noopener\">empty</a></li>\n<li>一个任何事件都没有产生的序列：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/never.html\" target=\"_blank\" rel=\"noopener\">never</a></li>\n</ul>\n<p><strong>我想要创建一个 <code>Observable</code> 通过组合其他的 <code>Observables</code></strong></p>\n<ul>\n<li>任意一个 <code>Observable</code> 产生了元素，就发出这个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/merge.html\" target=\"_blank\" rel=\"noopener\">merge</a></li>\n<li>让这些 <code>Observables</code> 一个接一个的发出元素，当上一个 <code>Observable</code> 元素发送完毕后，下一个<code>Observable</code> 才能开始发出元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concat.html\" target=\"_blank\" rel=\"noopener\">concat</a></li>\n<li>组合多个 <code>Observables</code> 的元素</li>\n<li>当每一个 <code>Observable</code> 都发出一个新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/zip.html\" target=\"_blank\" rel=\"noopener\">zip</a></li>\n<li>当任意一个 <code>Observable</code> 发出一个新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/combineLatest.html\" target=\"_blank\" rel=\"noopener\">combineLatest</a></li>\n</ul>\n<p><strong>我想要转换 <code>Observable</code> 的元素后，再将它们发出来</strong></p>\n<ul>\n<li>对每个元素直接转换：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/map.html\" target=\"_blank\" rel=\"noopener\">map</a></li>\n<li>转换到另一个 <code>Observable</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMap.html\" target=\"_blank\" rel=\"noopener\">flatMap</a></li>\n<li>只接收最新的元素转换的 <code>Observable</code> 所产生的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMapLatest.html\" target=\"_blank\" rel=\"noopener\">flatMapLatest</a></li>\n<li>每一个元素转换的 <code>Observable</code> 按顺序产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concatMap.html\" target=\"_blank\" rel=\"noopener\">concatMap</a></li>\n<li>基于所有遍历过的元素： <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html\" target=\"_blank\" rel=\"noopener\">scan</a></li>\n</ul>\n<p><strong>我想要将产生的每一个元素，拖延一段时间后再发出：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delay.html\" target=\"_blank\" rel=\"noopener\">delay</a></strong></p>\n<p><strong>我想要将产生的事件封装成元素发送出来</strong></p>\n<ul>\n<li>将他们封装成 <code>Event&lt;Element&gt;</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/materialize.html\" target=\"_blank\" rel=\"noopener\">materialize</a></li>\n<li>然后解封出来：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/dematerialize.html\" target=\"_blank\" rel=\"noopener\">dematerialize</a></li>\n</ul>\n<p><strong>我想要忽略掉所有的 <code>next</code> 事件，只接收 <code>completed</code> 和 <code>error</code> 事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/ignoreElements.html\" target=\"_blank\" rel=\"noopener\">ignoreElements</a></strong></p>\n<p><strong>我想创建一个新的 <code>Observable</code> 在原有的序列前面加入一些元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/startWith.html\" target=\"_blank\" rel=\"noopener\">startWith</a></strong></p>\n<p><strong>我想从 <code>Observable</code> 中收集元素，缓存这些元素之后在发出：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/buffer.html\" target=\"_blank\" rel=\"noopener\">buffer</a></strong></p>\n<p><strong>我想将 <code>Observable</code> 拆分成多个 <code>Observables</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/window.html\" target=\"_blank\" rel=\"noopener\">window</a></strong></p>\n<ul>\n<li>基于元素的共同特征：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/groupBy.html\" target=\"_blank\" rel=\"noopener\">groupBy</a></li>\n</ul>\n<p><strong>我想只接收 <code>Observable</code> 中特定的元素</strong></p>\n<ul>\n<li>发出唯一的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/single.html\" target=\"_blank\" rel=\"noopener\">single</a></li>\n</ul>\n<p><strong>我想重新从 <code>Observable</code> 中发出某些元素</strong></p>\n<ul>\n<li>通过判定条件过滤出一些元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/filter.html\" target=\"_blank\" rel=\"noopener\">filter</a></li>\n<li>仅仅发出头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html\" target=\"_blank\" rel=\"noopener\">take</a></li>\n<li>仅仅发出尾部的几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeLast.html\" target=\"_blank\" rel=\"noopener\">takeLast</a></li>\n<li>仅仅发出第 n 个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/elementAt.html\" target=\"_blank\" rel=\"noopener\">elementAt</a></li>\n<li>跳过头几个元素</li>\n<li>跳过头 n 个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html\" target=\"_blank\" rel=\"noopener\">skip</a></li>\n<li>跳过头几个满足判定的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html\" target=\"_blank\" rel=\"noopener\">skipWhile</a>，<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html\" target=\"_blank\" rel=\"noopener\">skipWhileWithIndex</a></li>\n<li>跳过某段时间内产生的头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html\" target=\"_blank\" rel=\"noopener\">skip</a></li>\n<li>跳过头几个元素直到另一个 <code>Observable</code> 发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipUntil.html\" target=\"_blank\" rel=\"noopener\">skipUntil</a></li>\n<li>只取头几个元素</li>\n<li>只取头几个满足判定的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html\" target=\"_blank\" rel=\"noopener\">takeWhile</a>，<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html\" target=\"_blank\" rel=\"noopener\">takeWhileWithIndex</a></li>\n<li>只取某段时间内产生的头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html\" target=\"_blank\" rel=\"noopener\">take</a></li>\n<li>只取头几个元素直到另一个 <code>Observable</code> 发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeUntil.html\" target=\"_blank\" rel=\"noopener\">takeUntil</a></li>\n<li>周期性的对 <code>Observable</code> 抽样：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/sample.html\" target=\"_blank\" rel=\"noopener\">sample</a></li>\n<li>发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/debounce.html\" target=\"_blank\" rel=\"noopener\">debounce</a></li>\n<li>直到元素的值发生变化，才发出新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html\" target=\"_blank\" rel=\"noopener\">distinctUntilChanged</a></li>\n<li>并提供元素是否相等的判定函数：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html\" target=\"_blank\" rel=\"noopener\">distinctUntilChanged</a></li>\n<li>在开始发出元素时，延时后进行订阅：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delaySubscription.html\" target=\"_blank\" rel=\"noopener\">delaySubscription</a></li>\n</ul>\n<p><strong>我想要从一些 <code>Observables</code> 中，只取第一个产生元素的 <code>Observable</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/amb.html\" target=\"_blank\" rel=\"noopener\">amb</a></strong></p>\n<p><strong>我想评估 <code>Observable</code> 的全部元素</strong></p>\n<ul>\n<li>并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/reduce.html\" target=\"_blank\" rel=\"noopener\">reduce</a></li>\n<li>并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html\" target=\"_blank\" rel=\"noopener\">scan</a></li>\n</ul>\n<p><strong>我想把 <code>Observable</code> 转换为其他的数据结构：as…</strong></p>\n<p><strong>我想在某个 <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html\" target=\"_blank\" rel=\"noopener\">Scheduler</a> 应用操作符：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html\" target=\"_blank\" rel=\"noopener\">subscribeOn</a></strong></p>\n<ul>\n<li>在某个 <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html\" target=\"_blank\" rel=\"noopener\">Scheduler</a> 监听：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html\" target=\"_blank\" rel=\"noopener\">observeOn</a></li>\n</ul>\n<p><strong>我想要 <code>Observable</code> 发生某个事件时, 采取某个行动：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/do.html\" target=\"_blank\" rel=\"noopener\">do</a></strong></p>\n<p><strong>我想要 <code>Observable</code> 发出一个 <code>error</code> 事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/error.html\" target=\"_blank\" rel=\"noopener\">error</a></strong></p>\n<ul>\n<li>如果规定时间内没有产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html\" target=\"_blank\" rel=\"noopener\">timeout</a></li>\n</ul>\n<p><strong>我想要 <code>Observable</code> 发生错误时，优雅的恢复</strong></p>\n<ul>\n<li>如果规定时间内没有产生元素，就切换到备选 <code>Observable</code> ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html\" target=\"_blank\" rel=\"noopener\">timeout</a></li>\n<li>如果产生错误，将错误替换成某个元素 ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html\" target=\"_blank\" rel=\"noopener\">catchErrorJustReturn</a></li>\n<li>如果产生错误，就切换到备选 <code>Observable</code> ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html\" target=\"_blank\" rel=\"noopener\">catchError</a></li>\n<li>如果产生错误，就重试 ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/retry.html\" target=\"_blank\" rel=\"noopener\">retry</a></li>\n</ul>\n<p><strong>我创建一个 <code>Disposable</code> 资源，使它与 <code>Observable</code> 具有相同的寿命：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/using.html\" target=\"_blank\" rel=\"noopener\">using</a></strong></p>\n<p><strong>我创建一个 <code>Observable</code>，直到我通知它可以产生元素后，才能产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/publish.html\" target=\"_blank\" rel=\"noopener\">publish</a></strong></p>\n<ul>\n<li>并且，就算是在产生元素后订阅，也要发出全部元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/replay.html\" target=\"_blank\" rel=\"noopener\">replay</a></li>\n<li>并且，一旦所有观察者取消观察，他就被释放掉：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/refCount.html\" target=\"_blank\" rel=\"noopener\">refCount</a></li>\n<li>通知它可以产生元素了：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/connect.html\" target=\"_blank\" rel=\"noopener\">connect</a></li>\n</ul>\n<p>笨鸟先飞，执行合一。基本了解<code>RxSwift</code>后，就应该动手写一些BUG了。</p>\n"},{"title":"源码阅读 Kingfisher","date":"2018-10-09T12:33:02.000Z","_content":"[Kingfisher](https://github.com/onevcat/Kingfisher)是一个用于图片下载和缓存的轻量级、纯swift库。通过[喵神](https://weibo.com/onevcat?profile_ftype=1&is_all=1#_rnd1539003449528)的介绍，可以得知`Kingfisher`有以下特点：\n\n- 实现了图片的异步下载和缓存\n- 基于`URLSession`的网络，提供基本图像处理器和过滤器。\n- 内存和磁盘的多层缓存。\n- 可取消下载和处理任务以提高性能。\n- 独立的组件，根据需要单独使用下载器或缓存系统。\n- 预览图像并在以后需要时从缓存中显示它们。\n- 对`UIImageView`,` NSImage`和`UIButton`的扩展，可以直接从`URL`设置图像。\n- 设置图像时内置过渡动画。\n- 加载图像时可自定义占位符。\n- 可扩展的图像处理和图像格式支持。\n\n## 目录结构\n在项目中，我们使用`CocoaPods `下载安装`Kingfisher `。\n我们查看`Kingfisher`的目录结构，如下\n```\nKingfisher\n    AnimatedImageView.swift    //动画控件   \n    Box.swift    //工具类\n    CacheSerializer.swift    //序列化类，读写文件时Data和Image互转\n    Filter.swift    //仅对CIImage有效\n    FormatIndicatedCacheSerializer.swift    //PNG/JPEG/GIF和Data互转\n    Image.swift    //图片格式转换\n    ImageCache.swift    //图片缓存\n    ImageDownloader.swift    //图片下载\n    ImageModifier.swift    //图片修改\n    ImagePrefetcher.swift    //图片下载管理类，对并发多个下载任务的处理\n    ImageProcessor.swift    //数据处理类，将Data转为Image\n    ImageTransition.swift    //动画效果\n    ImageView+Kingfisher.swift    //扩展ImageView添加下载图片的方法\n    Indicator.swift    //动画相关\n    Kingfisher.h    //版本号\n    Kingfisher.swift    //类，扩展ImageView添加属性kf\n    KingfisherManager.swift    //管理类，封装图片下载和缓存的逻辑\n    KingfisherOptionsInfo.swift    //枚举类\n    Placeholder.swift    //默认图片管理类\n    RequestModifier.swift    //协议，修改原始URLRequest参数\n    Resource.swift    //协议，声明下载链接和缓存key\n    String+MD5.swift    //MD5加密\n    ThreadHelper.swift    //工具类\n    UIButton+Kingfisher.swift    //扩展UIButton添加下载图片的方法\n```\n## 调用方法\n很简单的一句话：\n```\nself.imageV.kf.setImage(with: imgUrl)\n```\n如果想在图片加载的过程中添加默认图片，可以添加`placeholder`方法，监听加载的过程`progressBlock`，图片加载完成后的回调`completionHandler`。\n## 查看方法\n查看`kf.setImage`方法，我们会跳到*ImageView+Kingfisher.swift*文件里。这里我们对方法做一个简单的介绍\n```\n@discardableResult\npublic func setImage(with resource: Resource?,\n                     placeholder: Placeholder? = nil,\n                     options: KingfisherOptionsInfo? = nil,\n                     progressBlock: DownloadProgressBlock? = nil,\n                     completionHandler: CompletionHandler? = nil) -> RetrieveImageTask{...}\n```\n我们可以看到，在这个方法里面，包括了ImageView的资源、默认图片、作者封装的枚举类、加载进度的回调以及完成结果。\n`@discardableResult`方法是为了取消不使用返回值的警告。\n在这个方法里面(方法太长就不列举出来，捡主要的说)，\n- 首先判断参数合法性，当`resource `为`nil`时，展示默认图片。\n- 设置读取策略和启动动画。比如常见的一个问题：当用户头像改变但图片`URL`没有改变时，怎么去处理用户头像。一般有两种方法，一种是在缓存用户头像时保存当前时间。另一种就是设置读取策略，`KingfisherOptionsInfo`是一个枚举，设置它为`forceRefresh `时，可以强制刷新。\n- 从内存、文件或网络`URL`获取对应图片数据。\n- 获取图片完成后，在主线程刷新界面。\n\n我们查看一下这里面的参数：\n### Resource\nResource是一个协议，我们查看源码可以看到：\n```\npublic protocol Resource {\n    var cacheKey: String { get }\n    var downloadURL: URL { get }\n}\n```\n`cacheKey`是图片保存的key值，当`cacheKey`为`nil`时，取`downloadURL.absoluteString`(有兴趣的可以去了解一下`absoluteString`和`path`的区别)。`downloadURL`不言而喻，就是图片的`URL`。\n### Placeholder\n```\npublic protocol Placeholder {\n    func add(to imageView: ImageView)\n    func remove(from imageView: ImageView)\n}\n```\n`Placeholder`是一个协议，作者为它定义了`add`和`remove`方法，任何。默认实现了`Image`，如果想用`View`充当`Placeholder`，只要让`view`遵守协议即可\n```\nextension Placeholder where Self: View{}\n```\n### KingfisherOptionsInfo\n`KingfisherOptionsInfo`是一个类型别名，点击查看\n```\npublic typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]\n```\n所以我们关注的应该是`KingfisherOptionsInfoItem`是什么东西？那么它是什么呢？\n```\npublic enum KingfisherOptionsInfoItem {\n    case targetCache(ImageCache)    //系统缓存位置。可以设置的属性\n    case originalCache(ImageCache)    //系统缓存原始图像位置（只用于自己设置placeholder） \n    case downloader(ImageDownloader)    //获取更改session属性，设置请求\n    case transition(ImageTransition)    //自定义动画\n    case downloadPriority(Float)    //下载优先级（0-1）\n    case forceRefresh    //每次请求忽略缓存，直接下载\n    case fromMemoryCacheOrRefresh    //先取缓存再去文件，再去下载\n    case forceTransition    //强制移动\n    case cacheMemoryOnly     //只从缓存读取，不读取本机沙盒图片\n    case onlyFromCache    //从缓存、沙盒读取，没有也不下载网络，显示placeholder\n    case backgroundDecode    //设置后，显示前在后台线程解码\n    case callbackDispatchQueue(DispatchQueue?)    //自定义回调队列，默认主线程\n    case scaleFactor(CGFloat)    //自定义图片data -> Image缩放比例，不指定按屏幕2x\\3x缩放\n    case preloadAllAnimationData    //预先加载data成图片缓存\n    case requestModifier(ImageDownloadRequestModifier)    //改变请求\n    case processor(ImageProcessor)    //自定义Data转图片样式\n    case cacheSerializer(CacheSerializer)    //自定义缓存Data 转图像样式\n    case imageModifier(ImageModifier)    //修改图像\n    case keepCurrentImageWhileLoading     //包含这个意味着placeHolder设置无效，没有直接用默认\n    case onlyLoadFirstFrame    //如果返回结果是.gif图，只取第一帧显示\n    case cacheOriginalImage    //同时缓存原始图片和下载后的图片\n}\n```\n### DownloadProgressBlock\n```\npublic typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -> ())\n```\n`DownloadProgressBlock`里面有`receivedSize`和`totalSize`，可以根据这两个参数得知图片下载了多少和图片多大，也可以计算图片的下载进度。\n### CompletionHandler\n```\npublic typealias CompletionHandler = ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -> ())\n```\n`CompletionHandler`的回调里会有`image`、`error`、`cacheType`、`imageURL`四个参数。`image`、`error`、`imageURL`不做介绍，直接就能看出什么内容。\n主要看一下`cacheType`:\n```\npublic enum CacheType {\n    case none, memory, disk\n    public var cached: Bool {\n        switch self {\n        case .memory, .disk: return true\n        case .none: return false\n        }\n    }\n}\n```\n- `none`检索图片时，图片尚未缓存\n- `memory`图片缓存在内存中\n- `disk`图片缓存在磁盘中\n\n\n\n## 检索图片\nOK，让我们继续看这些代码。在`setImage`方法中，从内存、文件或网络`URL`获取对应图片数据是怎么实现的呢？这里，我们可以查看`KingfisherManager.shared.retrieveImage`方法。\n```\n@discardableResult\npublic func retrieveImage(with resource: Resource,\n    options: KingfisherOptionsInfo?,\n    progressBlock: DownloadProgressBlock?,\n    completionHandler: CompletionHandler?) -> RetrieveImageTask\n{\n    let task = RetrieveImageTask()\n    let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo)\n    if options.forceRefresh {\n        _ = downloadAndCacheImage(\n            with: resource.downloadURL,\n            forKey: resource.cacheKey,\n            retrieveImageTask: task,\n            progressBlock: progressBlock,\n            completionHandler: completionHandler,\n            options: options)\n    } else {    \n        tryToRetrieveImageFromCache(\n            forKey: resource.cacheKey,\n            with: resource.downloadURL, \n            retrieveImageTask: task,\n            progressBlock: progressBlock,\n            completionHandler: completionHandler,\n            options: options)\n    }\n    \n    return task\n}\n```\n可以看到，代码会通过`KingfisherOptionsInfo`进行判断是强制刷新，网络下载并执行缓存策略还是从内存或文件中获取对应的Image。\n### 图片下载\n```\n@discardableResult\nfunc downloadAndCacheImage(with url: URL,\n                         forKey key: String,\n                  retrieveImageTask: RetrieveImageTask,\n                      progressBlock: DownloadProgressBlock?,\n                  completionHandler: CompletionHandler?,\n                            options: KingfisherOptionsInfo) -> RetrieveImageDownloadTask?{...}\n```\n在`downloadAndCacheImage`方法中，会`return  downloader.downloadImage`方法，下载的主要逻辑在这里实现，对应的文件是*ImageDownloader.swift*。\n```\n@discardableResult\nopen func downloadImage(with url: URL,\n               retrieveImageTask: RetrieveImageTask? = nil,\n                         options: KingfisherOptionsInfo? = nil,\n                   progressBlock: ImageDownloaderProgressBlock? = nil,\n               completionHandler: ImageDownloaderCompletionHandler? = nil) -> RetrieveImageDownloadTask?{...}\n```\n`ImageDownloader.swift`文件中，主要参数：\n- `downloadTimeout` 超时时间，默认15秒\n- `trustedHosts ` 信任的请求地址，和自己实现请求代理设置冲突，二选一\n- `sessionConfiguration` session配置设置\n- `requestsUsePipelining` 请求是否管道类型，是否按顺序下载，默认`false`\n- `sessionHandler`单独设计出的一个`ImageDownloaderSessionHandler`，是为了解决之前出现的[内存泄漏](https://github.com/onevcat/Kingfisher/issues/235)\n- `delegate` 下载代理\n- `authenticationChallengeResponder` 信任请求代理，和trustedHosts冲突二选一\n- `fetchLoads` 下载完成每个URL可能有多个处理方式，优先取这里的\n- 此外还有三个`DispatchQueue`：`barrierQueue`、`processQueue`、`cancelQueue`\n\n下载完成后，在`completionHandler`回调中处理图片，如果下载失败：\n```\nif let error = error, error.code == KingfisherError.notModified.rawValue {\n    //从缓存中读取，不需保存，直接返回\n    targetCache.retrieveImage(forKey: key, options: options, completionHandler: { (cacheImage, cacheType) -> () in\n        completionHandler?(cacheImage, nil, cacheType, url)\n    })\n    return\n}\n```\n下载成功：\n```\nif let image = image, let originalData = originalData {\n    //存储图片\n    targetCache.store(image,\n                      original: originalData,\n                      forKey: key,\n                      processorIdentifier:options.processor.identifier,\n                      cacheSerializer: options.cacheSerializer,\n                      toDisk: !options.cacheMemoryOnly,\n                      completionHandler: nil)\n        if options.cacheOriginalImage && options.processor != DefaultImageProcessor.default {\n            let originalCache = options.originalCache\n            let defaultProcessor = DefaultImageProcessor.default\n            if let originalImage = defaultProcessor.process(item: .data(originalData), options: options) {\n                originalCache.store(originalImage,\n                        original: originalData,\n                        forKey: key,\n                        processorIdentifier: defaultProcessor.identifier,\n                        cacheSerializer: options.cacheSerializer,\n                        toDisk: !options.cacheMemoryOnly,\n                        completionHandler: nil)\n            }\n        }\n}\n```\n#### 存储图片\n我们先来看一下实现的代码：\n```\nopen func store(_ image: Image,\n                  original: Data? = nil,\n                  forKey key: String,\n                  processorIdentifier identifier: String = \"\",\n                  cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,\n                  toDisk: Bool = true,\n                  completionHandler: (() -> Void)? = nil){...}\n```\n代码中`memoryCache `是：\n```\nfileprivate let memoryCache = NSCache<NSString, AnyObject>()\n```\n可见图片存储首先是缓存在`NSCache`中，如果想存储在磁盘中(`if toDisk`)，利用串行队列异步的进行存储原图。\n#### 获取图片\n```\n@discardableResult\nopen func retrieveImage(forKey key: String,\n                           options: KingfisherOptionsInfo?,\n                 completionHandler: ((Image?, CacheType) -> ())?) -> RetrieveImageDiskTask?{...}\n```\n- 首先从内存中获取图片`if let image = self.retrieveImageInMemoryCache(forKey: key, options: options)`\n- 如果没有，在根据条件判断是否从磁盘上获取`if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options)`\n\n#### 删除图片\n```\nopen func removeImage(forKey key: String,\n                      processorIdentifier identifier: String = \"\",\n                      fromDisk: Bool = true,\n                      completionHandler: (() -> Void)? = nil){...}\n```\n\n```\n@objc public func clearMemoryCache() {...}\n```\n```\nopen func clearDiskCache(completion handler: (()->())? = nil) {...}\n```\n```\nopen func cleanExpiredDiskCache(completion handler: (()->())? = nil) {...}\n```\n```\n@objc public func backgroundCleanExpiredDiskCache() {...}\n```\n其中，一些方法是通过通知的方法来实现：\n```\n// 系统内存警告\nNotificationCenter.default.addObserver(self, selector: #selector(clearMemoryCache), name: .UIApplicationDidReceiveMemoryWarning, object: nil)    \n// 程序终止\nNotificationCenter.default.addObserver(self, selector: #selector(cleanExpiredDiskCache), name: .UIApplicationWillTerminate, object: nil)\n// 程序进入后台\nNotificationCenter.default.addObserver(self, selector: #selector(backgroundCleanExpiredDiskCache), name: .UIApplicationDidEnterBackground, object: nil)\n```\n此外，还有一些属性要注意:\n- `maxMemoryCost `最大缓存量，在收到内存警告时会被清空。\n- `pathExtension`沙盒后续拼接文件夹名称\n- `maxCachePeriodInSecond `默认清除一周前的图片\n- `maxDiskCacheSize `沙盒最大存储量，为0，默认无限制\n\n以上就是对Kingfisher的简单描述，它有很多方法值得我们去借鉴，比如`@discardableResult`、`where`、`typealias`、`if case let`、善于利用`guard`、扩展协议等等。\n\n\n\n\n\n","source":"_posts/源码阅读-Kingfisher.md","raw":"---\ntitle: 源码阅读 Kingfisher\ndate: 2018-10-09 20:33:02\ntags: 源码阅读\n---\n[Kingfisher](https://github.com/onevcat/Kingfisher)是一个用于图片下载和缓存的轻量级、纯swift库。通过[喵神](https://weibo.com/onevcat?profile_ftype=1&is_all=1#_rnd1539003449528)的介绍，可以得知`Kingfisher`有以下特点：\n\n- 实现了图片的异步下载和缓存\n- 基于`URLSession`的网络，提供基本图像处理器和过滤器。\n- 内存和磁盘的多层缓存。\n- 可取消下载和处理任务以提高性能。\n- 独立的组件，根据需要单独使用下载器或缓存系统。\n- 预览图像并在以后需要时从缓存中显示它们。\n- 对`UIImageView`,` NSImage`和`UIButton`的扩展，可以直接从`URL`设置图像。\n- 设置图像时内置过渡动画。\n- 加载图像时可自定义占位符。\n- 可扩展的图像处理和图像格式支持。\n\n## 目录结构\n在项目中，我们使用`CocoaPods `下载安装`Kingfisher `。\n我们查看`Kingfisher`的目录结构，如下\n```\nKingfisher\n    AnimatedImageView.swift    //动画控件   \n    Box.swift    //工具类\n    CacheSerializer.swift    //序列化类，读写文件时Data和Image互转\n    Filter.swift    //仅对CIImage有效\n    FormatIndicatedCacheSerializer.swift    //PNG/JPEG/GIF和Data互转\n    Image.swift    //图片格式转换\n    ImageCache.swift    //图片缓存\n    ImageDownloader.swift    //图片下载\n    ImageModifier.swift    //图片修改\n    ImagePrefetcher.swift    //图片下载管理类，对并发多个下载任务的处理\n    ImageProcessor.swift    //数据处理类，将Data转为Image\n    ImageTransition.swift    //动画效果\n    ImageView+Kingfisher.swift    //扩展ImageView添加下载图片的方法\n    Indicator.swift    //动画相关\n    Kingfisher.h    //版本号\n    Kingfisher.swift    //类，扩展ImageView添加属性kf\n    KingfisherManager.swift    //管理类，封装图片下载和缓存的逻辑\n    KingfisherOptionsInfo.swift    //枚举类\n    Placeholder.swift    //默认图片管理类\n    RequestModifier.swift    //协议，修改原始URLRequest参数\n    Resource.swift    //协议，声明下载链接和缓存key\n    String+MD5.swift    //MD5加密\n    ThreadHelper.swift    //工具类\n    UIButton+Kingfisher.swift    //扩展UIButton添加下载图片的方法\n```\n## 调用方法\n很简单的一句话：\n```\nself.imageV.kf.setImage(with: imgUrl)\n```\n如果想在图片加载的过程中添加默认图片，可以添加`placeholder`方法，监听加载的过程`progressBlock`，图片加载完成后的回调`completionHandler`。\n## 查看方法\n查看`kf.setImage`方法，我们会跳到*ImageView+Kingfisher.swift*文件里。这里我们对方法做一个简单的介绍\n```\n@discardableResult\npublic func setImage(with resource: Resource?,\n                     placeholder: Placeholder? = nil,\n                     options: KingfisherOptionsInfo? = nil,\n                     progressBlock: DownloadProgressBlock? = nil,\n                     completionHandler: CompletionHandler? = nil) -> RetrieveImageTask{...}\n```\n我们可以看到，在这个方法里面，包括了ImageView的资源、默认图片、作者封装的枚举类、加载进度的回调以及完成结果。\n`@discardableResult`方法是为了取消不使用返回值的警告。\n在这个方法里面(方法太长就不列举出来，捡主要的说)，\n- 首先判断参数合法性，当`resource `为`nil`时，展示默认图片。\n- 设置读取策略和启动动画。比如常见的一个问题：当用户头像改变但图片`URL`没有改变时，怎么去处理用户头像。一般有两种方法，一种是在缓存用户头像时保存当前时间。另一种就是设置读取策略，`KingfisherOptionsInfo`是一个枚举，设置它为`forceRefresh `时，可以强制刷新。\n- 从内存、文件或网络`URL`获取对应图片数据。\n- 获取图片完成后，在主线程刷新界面。\n\n我们查看一下这里面的参数：\n### Resource\nResource是一个协议，我们查看源码可以看到：\n```\npublic protocol Resource {\n    var cacheKey: String { get }\n    var downloadURL: URL { get }\n}\n```\n`cacheKey`是图片保存的key值，当`cacheKey`为`nil`时，取`downloadURL.absoluteString`(有兴趣的可以去了解一下`absoluteString`和`path`的区别)。`downloadURL`不言而喻，就是图片的`URL`。\n### Placeholder\n```\npublic protocol Placeholder {\n    func add(to imageView: ImageView)\n    func remove(from imageView: ImageView)\n}\n```\n`Placeholder`是一个协议，作者为它定义了`add`和`remove`方法，任何。默认实现了`Image`，如果想用`View`充当`Placeholder`，只要让`view`遵守协议即可\n```\nextension Placeholder where Self: View{}\n```\n### KingfisherOptionsInfo\n`KingfisherOptionsInfo`是一个类型别名，点击查看\n```\npublic typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]\n```\n所以我们关注的应该是`KingfisherOptionsInfoItem`是什么东西？那么它是什么呢？\n```\npublic enum KingfisherOptionsInfoItem {\n    case targetCache(ImageCache)    //系统缓存位置。可以设置的属性\n    case originalCache(ImageCache)    //系统缓存原始图像位置（只用于自己设置placeholder） \n    case downloader(ImageDownloader)    //获取更改session属性，设置请求\n    case transition(ImageTransition)    //自定义动画\n    case downloadPriority(Float)    //下载优先级（0-1）\n    case forceRefresh    //每次请求忽略缓存，直接下载\n    case fromMemoryCacheOrRefresh    //先取缓存再去文件，再去下载\n    case forceTransition    //强制移动\n    case cacheMemoryOnly     //只从缓存读取，不读取本机沙盒图片\n    case onlyFromCache    //从缓存、沙盒读取，没有也不下载网络，显示placeholder\n    case backgroundDecode    //设置后，显示前在后台线程解码\n    case callbackDispatchQueue(DispatchQueue?)    //自定义回调队列，默认主线程\n    case scaleFactor(CGFloat)    //自定义图片data -> Image缩放比例，不指定按屏幕2x\\3x缩放\n    case preloadAllAnimationData    //预先加载data成图片缓存\n    case requestModifier(ImageDownloadRequestModifier)    //改变请求\n    case processor(ImageProcessor)    //自定义Data转图片样式\n    case cacheSerializer(CacheSerializer)    //自定义缓存Data 转图像样式\n    case imageModifier(ImageModifier)    //修改图像\n    case keepCurrentImageWhileLoading     //包含这个意味着placeHolder设置无效，没有直接用默认\n    case onlyLoadFirstFrame    //如果返回结果是.gif图，只取第一帧显示\n    case cacheOriginalImage    //同时缓存原始图片和下载后的图片\n}\n```\n### DownloadProgressBlock\n```\npublic typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -> ())\n```\n`DownloadProgressBlock`里面有`receivedSize`和`totalSize`，可以根据这两个参数得知图片下载了多少和图片多大，也可以计算图片的下载进度。\n### CompletionHandler\n```\npublic typealias CompletionHandler = ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -> ())\n```\n`CompletionHandler`的回调里会有`image`、`error`、`cacheType`、`imageURL`四个参数。`image`、`error`、`imageURL`不做介绍，直接就能看出什么内容。\n主要看一下`cacheType`:\n```\npublic enum CacheType {\n    case none, memory, disk\n    public var cached: Bool {\n        switch self {\n        case .memory, .disk: return true\n        case .none: return false\n        }\n    }\n}\n```\n- `none`检索图片时，图片尚未缓存\n- `memory`图片缓存在内存中\n- `disk`图片缓存在磁盘中\n\n\n\n## 检索图片\nOK，让我们继续看这些代码。在`setImage`方法中，从内存、文件或网络`URL`获取对应图片数据是怎么实现的呢？这里，我们可以查看`KingfisherManager.shared.retrieveImage`方法。\n```\n@discardableResult\npublic func retrieveImage(with resource: Resource,\n    options: KingfisherOptionsInfo?,\n    progressBlock: DownloadProgressBlock?,\n    completionHandler: CompletionHandler?) -> RetrieveImageTask\n{\n    let task = RetrieveImageTask()\n    let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo)\n    if options.forceRefresh {\n        _ = downloadAndCacheImage(\n            with: resource.downloadURL,\n            forKey: resource.cacheKey,\n            retrieveImageTask: task,\n            progressBlock: progressBlock,\n            completionHandler: completionHandler,\n            options: options)\n    } else {    \n        tryToRetrieveImageFromCache(\n            forKey: resource.cacheKey,\n            with: resource.downloadURL, \n            retrieveImageTask: task,\n            progressBlock: progressBlock,\n            completionHandler: completionHandler,\n            options: options)\n    }\n    \n    return task\n}\n```\n可以看到，代码会通过`KingfisherOptionsInfo`进行判断是强制刷新，网络下载并执行缓存策略还是从内存或文件中获取对应的Image。\n### 图片下载\n```\n@discardableResult\nfunc downloadAndCacheImage(with url: URL,\n                         forKey key: String,\n                  retrieveImageTask: RetrieveImageTask,\n                      progressBlock: DownloadProgressBlock?,\n                  completionHandler: CompletionHandler?,\n                            options: KingfisherOptionsInfo) -> RetrieveImageDownloadTask?{...}\n```\n在`downloadAndCacheImage`方法中，会`return  downloader.downloadImage`方法，下载的主要逻辑在这里实现，对应的文件是*ImageDownloader.swift*。\n```\n@discardableResult\nopen func downloadImage(with url: URL,\n               retrieveImageTask: RetrieveImageTask? = nil,\n                         options: KingfisherOptionsInfo? = nil,\n                   progressBlock: ImageDownloaderProgressBlock? = nil,\n               completionHandler: ImageDownloaderCompletionHandler? = nil) -> RetrieveImageDownloadTask?{...}\n```\n`ImageDownloader.swift`文件中，主要参数：\n- `downloadTimeout` 超时时间，默认15秒\n- `trustedHosts ` 信任的请求地址，和自己实现请求代理设置冲突，二选一\n- `sessionConfiguration` session配置设置\n- `requestsUsePipelining` 请求是否管道类型，是否按顺序下载，默认`false`\n- `sessionHandler`单独设计出的一个`ImageDownloaderSessionHandler`，是为了解决之前出现的[内存泄漏](https://github.com/onevcat/Kingfisher/issues/235)\n- `delegate` 下载代理\n- `authenticationChallengeResponder` 信任请求代理，和trustedHosts冲突二选一\n- `fetchLoads` 下载完成每个URL可能有多个处理方式，优先取这里的\n- 此外还有三个`DispatchQueue`：`barrierQueue`、`processQueue`、`cancelQueue`\n\n下载完成后，在`completionHandler`回调中处理图片，如果下载失败：\n```\nif let error = error, error.code == KingfisherError.notModified.rawValue {\n    //从缓存中读取，不需保存，直接返回\n    targetCache.retrieveImage(forKey: key, options: options, completionHandler: { (cacheImage, cacheType) -> () in\n        completionHandler?(cacheImage, nil, cacheType, url)\n    })\n    return\n}\n```\n下载成功：\n```\nif let image = image, let originalData = originalData {\n    //存储图片\n    targetCache.store(image,\n                      original: originalData,\n                      forKey: key,\n                      processorIdentifier:options.processor.identifier,\n                      cacheSerializer: options.cacheSerializer,\n                      toDisk: !options.cacheMemoryOnly,\n                      completionHandler: nil)\n        if options.cacheOriginalImage && options.processor != DefaultImageProcessor.default {\n            let originalCache = options.originalCache\n            let defaultProcessor = DefaultImageProcessor.default\n            if let originalImage = defaultProcessor.process(item: .data(originalData), options: options) {\n                originalCache.store(originalImage,\n                        original: originalData,\n                        forKey: key,\n                        processorIdentifier: defaultProcessor.identifier,\n                        cacheSerializer: options.cacheSerializer,\n                        toDisk: !options.cacheMemoryOnly,\n                        completionHandler: nil)\n            }\n        }\n}\n```\n#### 存储图片\n我们先来看一下实现的代码：\n```\nopen func store(_ image: Image,\n                  original: Data? = nil,\n                  forKey key: String,\n                  processorIdentifier identifier: String = \"\",\n                  cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,\n                  toDisk: Bool = true,\n                  completionHandler: (() -> Void)? = nil){...}\n```\n代码中`memoryCache `是：\n```\nfileprivate let memoryCache = NSCache<NSString, AnyObject>()\n```\n可见图片存储首先是缓存在`NSCache`中，如果想存储在磁盘中(`if toDisk`)，利用串行队列异步的进行存储原图。\n#### 获取图片\n```\n@discardableResult\nopen func retrieveImage(forKey key: String,\n                           options: KingfisherOptionsInfo?,\n                 completionHandler: ((Image?, CacheType) -> ())?) -> RetrieveImageDiskTask?{...}\n```\n- 首先从内存中获取图片`if let image = self.retrieveImageInMemoryCache(forKey: key, options: options)`\n- 如果没有，在根据条件判断是否从磁盘上获取`if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options)`\n\n#### 删除图片\n```\nopen func removeImage(forKey key: String,\n                      processorIdentifier identifier: String = \"\",\n                      fromDisk: Bool = true,\n                      completionHandler: (() -> Void)? = nil){...}\n```\n\n```\n@objc public func clearMemoryCache() {...}\n```\n```\nopen func clearDiskCache(completion handler: (()->())? = nil) {...}\n```\n```\nopen func cleanExpiredDiskCache(completion handler: (()->())? = nil) {...}\n```\n```\n@objc public func backgroundCleanExpiredDiskCache() {...}\n```\n其中，一些方法是通过通知的方法来实现：\n```\n// 系统内存警告\nNotificationCenter.default.addObserver(self, selector: #selector(clearMemoryCache), name: .UIApplicationDidReceiveMemoryWarning, object: nil)    \n// 程序终止\nNotificationCenter.default.addObserver(self, selector: #selector(cleanExpiredDiskCache), name: .UIApplicationWillTerminate, object: nil)\n// 程序进入后台\nNotificationCenter.default.addObserver(self, selector: #selector(backgroundCleanExpiredDiskCache), name: .UIApplicationDidEnterBackground, object: nil)\n```\n此外，还有一些属性要注意:\n- `maxMemoryCost `最大缓存量，在收到内存警告时会被清空。\n- `pathExtension`沙盒后续拼接文件夹名称\n- `maxCachePeriodInSecond `默认清除一周前的图片\n- `maxDiskCacheSize `沙盒最大存储量，为0，默认无限制\n\n以上就是对Kingfisher的简单描述，它有很多方法值得我们去借鉴，比如`@discardableResult`、`where`、`typealias`、`if case let`、善于利用`guard`、扩展协议等等。\n\n\n\n\n\n","slug":"源码阅读-Kingfisher","published":1,"updated":"2018-10-19T07:16:01.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjnfp0luk000timcwx9qooc4z","content":"<p><a href=\"https://github.com/onevcat/Kingfisher\" target=\"_blank\" rel=\"noopener\">Kingfisher</a>是一个用于图片下载和缓存的轻量级、纯swift库。通过<a href=\"https://weibo.com/onevcat?profile_ftype=1&amp;is_all=1#_rnd1539003449528\" target=\"_blank\" rel=\"noopener\">喵神</a>的介绍，可以得知<code>Kingfisher</code>有以下特点：</p>\n<ul>\n<li>实现了图片的异步下载和缓存</li>\n<li>基于<code>URLSession</code>的网络，提供基本图像处理器和过滤器。</li>\n<li>内存和磁盘的多层缓存。</li>\n<li>可取消下载和处理任务以提高性能。</li>\n<li>独立的组件，根据需要单独使用下载器或缓存系统。</li>\n<li>预览图像并在以后需要时从缓存中显示它们。</li>\n<li>对<code>UIImageView</code>,<code>NSImage</code>和<code>UIButton</code>的扩展，可以直接从<code>URL</code>设置图像。</li>\n<li>设置图像时内置过渡动画。</li>\n<li>加载图像时可自定义占位符。</li>\n<li>可扩展的图像处理和图像格式支持。</li>\n</ul>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><p>在项目中，我们使用<code>CocoaPods</code>下载安装<code>Kingfisher</code>。<br>我们查看<code>Kingfisher</code>的目录结构，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kingfisher</span><br><span class=\"line\">    AnimatedImageView.swift    //动画控件   </span><br><span class=\"line\">    Box.swift    //工具类</span><br><span class=\"line\">    CacheSerializer.swift    //序列化类，读写文件时Data和Image互转</span><br><span class=\"line\">    Filter.swift    //仅对CIImage有效</span><br><span class=\"line\">    FormatIndicatedCacheSerializer.swift    //PNG/JPEG/GIF和Data互转</span><br><span class=\"line\">    Image.swift    //图片格式转换</span><br><span class=\"line\">    ImageCache.swift    //图片缓存</span><br><span class=\"line\">    ImageDownloader.swift    //图片下载</span><br><span class=\"line\">    ImageModifier.swift    //图片修改</span><br><span class=\"line\">    ImagePrefetcher.swift    //图片下载管理类，对并发多个下载任务的处理</span><br><span class=\"line\">    ImageProcessor.swift    //数据处理类，将Data转为Image</span><br><span class=\"line\">    ImageTransition.swift    //动画效果</span><br><span class=\"line\">    ImageView+Kingfisher.swift    //扩展ImageView添加下载图片的方法</span><br><span class=\"line\">    Indicator.swift    //动画相关</span><br><span class=\"line\">    Kingfisher.h    //版本号</span><br><span class=\"line\">    Kingfisher.swift    //类，扩展ImageView添加属性kf</span><br><span class=\"line\">    KingfisherManager.swift    //管理类，封装图片下载和缓存的逻辑</span><br><span class=\"line\">    KingfisherOptionsInfo.swift    //枚举类</span><br><span class=\"line\">    Placeholder.swift    //默认图片管理类</span><br><span class=\"line\">    RequestModifier.swift    //协议，修改原始URLRequest参数</span><br><span class=\"line\">    Resource.swift    //协议，声明下载链接和缓存key</span><br><span class=\"line\">    String+MD5.swift    //MD5加密</span><br><span class=\"line\">    ThreadHelper.swift    //工具类</span><br><span class=\"line\">    UIButton+Kingfisher.swift    //扩展UIButton添加下载图片的方法</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h2><p>很简单的一句话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.imageV.kf.setImage(with: imgUrl)</span><br></pre></td></tr></table></figure></p>\n<p>如果想在图片加载的过程中添加默认图片，可以添加<code>placeholder</code>方法，监听加载的过程<code>progressBlock</code>，图片加载完成后的回调<code>completionHandler</code>。</p>\n<h2 id=\"查看方法\"><a href=\"#查看方法\" class=\"headerlink\" title=\"查看方法\"></a>查看方法</h2><p>查看<code>kf.setImage</code>方法，我们会跳到<em>ImageView+Kingfisher.swift</em>文件里。这里我们对方法做一个简单的介绍<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">public func setImage(with resource: Resource?,</span><br><span class=\"line\">                     placeholder: Placeholder? = nil,</span><br><span class=\"line\">                     options: KingfisherOptionsInfo? = nil,</span><br><span class=\"line\">                     progressBlock: DownloadProgressBlock? = nil,</span><br><span class=\"line\">                     completionHandler: CompletionHandler? = nil) -&gt; RetrieveImageTask&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到，在这个方法里面，包括了ImageView的资源、默认图片、作者封装的枚举类、加载进度的回调以及完成结果。<br><code>@discardableResult</code>方法是为了取消不使用返回值的警告。<br>在这个方法里面(方法太长就不列举出来，捡主要的说)，</p>\n<ul>\n<li>首先判断参数合法性，当<code>resource</code>为<code>nil</code>时，展示默认图片。</li>\n<li>设置读取策略和启动动画。比如常见的一个问题：当用户头像改变但图片<code>URL</code>没有改变时，怎么去处理用户头像。一般有两种方法，一种是在缓存用户头像时保存当前时间。另一种就是设置读取策略，<code>KingfisherOptionsInfo</code>是一个枚举，设置它为<code>forceRefresh</code>时，可以强制刷新。</li>\n<li>从内存、文件或网络<code>URL</code>获取对应图片数据。</li>\n<li>获取图片完成后，在主线程刷新界面。</li>\n</ul>\n<p>我们查看一下这里面的参数：</p>\n<h3 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"Resource\"></a>Resource</h3><p>Resource是一个协议，我们查看源码可以看到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public protocol Resource &#123;</span><br><span class=\"line\">    var cacheKey: String &#123; get &#125;</span><br><span class=\"line\">    var downloadURL: URL &#123; get &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>cacheKey</code>是图片保存的key值，当<code>cacheKey</code>为<code>nil</code>时，取<code>downloadURL.absoluteString</code>(有兴趣的可以去了解一下<code>absoluteString</code>和<code>path</code>的区别)。<code>downloadURL</code>不言而喻，就是图片的<code>URL</code>。</p>\n<h3 id=\"Placeholder\"><a href=\"#Placeholder\" class=\"headerlink\" title=\"Placeholder\"></a>Placeholder</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public protocol Placeholder &#123;</span><br><span class=\"line\">    func add(to imageView: ImageView)</span><br><span class=\"line\">    func remove(from imageView: ImageView)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Placeholder</code>是一个协议，作者为它定义了<code>add</code>和<code>remove</code>方法，任何。默认实现了<code>Image</code>，如果想用<code>View</code>充当<code>Placeholder</code>，只要让<code>view</code>遵守协议即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Placeholder where Self: View&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"KingfisherOptionsInfo\"><a href=\"#KingfisherOptionsInfo\" class=\"headerlink\" title=\"KingfisherOptionsInfo\"></a>KingfisherOptionsInfo</h3><p><code>KingfisherOptionsInfo</code>是一个类型别名，点击查看<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]</span><br></pre></td></tr></table></figure></p>\n<p>所以我们关注的应该是<code>KingfisherOptionsInfoItem</code>是什么东西？那么它是什么呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum KingfisherOptionsInfoItem &#123;</span><br><span class=\"line\">    case targetCache(ImageCache)    //系统缓存位置。可以设置的属性</span><br><span class=\"line\">    case originalCache(ImageCache)    //系统缓存原始图像位置（只用于自己设置placeholder） </span><br><span class=\"line\">    case downloader(ImageDownloader)    //获取更改session属性，设置请求</span><br><span class=\"line\">    case transition(ImageTransition)    //自定义动画</span><br><span class=\"line\">    case downloadPriority(Float)    //下载优先级（0-1）</span><br><span class=\"line\">    case forceRefresh    //每次请求忽略缓存，直接下载</span><br><span class=\"line\">    case fromMemoryCacheOrRefresh    //先取缓存再去文件，再去下载</span><br><span class=\"line\">    case forceTransition    //强制移动</span><br><span class=\"line\">    case cacheMemoryOnly     //只从缓存读取，不读取本机沙盒图片</span><br><span class=\"line\">    case onlyFromCache    //从缓存、沙盒读取，没有也不下载网络，显示placeholder</span><br><span class=\"line\">    case backgroundDecode    //设置后，显示前在后台线程解码</span><br><span class=\"line\">    case callbackDispatchQueue(DispatchQueue?)    //自定义回调队列，默认主线程</span><br><span class=\"line\">    case scaleFactor(CGFloat)    //自定义图片data -&gt; Image缩放比例，不指定按屏幕2x\\3x缩放</span><br><span class=\"line\">    case preloadAllAnimationData    //预先加载data成图片缓存</span><br><span class=\"line\">    case requestModifier(ImageDownloadRequestModifier)    //改变请求</span><br><span class=\"line\">    case processor(ImageProcessor)    //自定义Data转图片样式</span><br><span class=\"line\">    case cacheSerializer(CacheSerializer)    //自定义缓存Data 转图像样式</span><br><span class=\"line\">    case imageModifier(ImageModifier)    //修改图像</span><br><span class=\"line\">    case keepCurrentImageWhileLoading     //包含这个意味着placeHolder设置无效，没有直接用默认</span><br><span class=\"line\">    case onlyLoadFirstFrame    //如果返回结果是.gif图，只取第一帧显示</span><br><span class=\"line\">    case cacheOriginalImage    //同时缓存原始图片和下载后的图片</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"DownloadProgressBlock\"><a href=\"#DownloadProgressBlock\" class=\"headerlink\" title=\"DownloadProgressBlock\"></a>DownloadProgressBlock</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -&gt; ())</span><br></pre></td></tr></table></figure>\n<p><code>DownloadProgressBlock</code>里面有<code>receivedSize</code>和<code>totalSize</code>，可以根据这两个参数得知图片下载了多少和图片多大，也可以计算图片的下载进度。</p>\n<h3 id=\"CompletionHandler\"><a href=\"#CompletionHandler\" class=\"headerlink\" title=\"CompletionHandler\"></a>CompletionHandler</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias CompletionHandler = ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -&gt; ())</span><br></pre></td></tr></table></figure>\n<p><code>CompletionHandler</code>的回调里会有<code>image</code>、<code>error</code>、<code>cacheType</code>、<code>imageURL</code>四个参数。<code>image</code>、<code>error</code>、<code>imageURL</code>不做介绍，直接就能看出什么内容。<br>主要看一下<code>cacheType</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum CacheType &#123;</span><br><span class=\"line\">    case none, memory, disk</span><br><span class=\"line\">    public var cached: Bool &#123;</span><br><span class=\"line\">        switch self &#123;</span><br><span class=\"line\">        case .memory, .disk: return true</span><br><span class=\"line\">        case .none: return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>none</code>检索图片时，图片尚未缓存</li>\n<li><code>memory</code>图片缓存在内存中</li>\n<li><code>disk</code>图片缓存在磁盘中</li>\n</ul>\n<h2 id=\"检索图片\"><a href=\"#检索图片\" class=\"headerlink\" title=\"检索图片\"></a>检索图片</h2><p>OK，让我们继续看这些代码。在<code>setImage</code>方法中，从内存、文件或网络<code>URL</code>获取对应图片数据是怎么实现的呢？这里，我们可以查看<code>KingfisherManager.shared.retrieveImage</code>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">public func retrieveImage(with resource: Resource,</span><br><span class=\"line\">    options: KingfisherOptionsInfo?,</span><br><span class=\"line\">    progressBlock: DownloadProgressBlock?,</span><br><span class=\"line\">    completionHandler: CompletionHandler?) -&gt; RetrieveImageTask</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let task = RetrieveImageTask()</span><br><span class=\"line\">    let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo)</span><br><span class=\"line\">    if options.forceRefresh &#123;</span><br><span class=\"line\">        _ = downloadAndCacheImage(</span><br><span class=\"line\">            with: resource.downloadURL,</span><br><span class=\"line\">            forKey: resource.cacheKey,</span><br><span class=\"line\">            retrieveImageTask: task,</span><br><span class=\"line\">            progressBlock: progressBlock,</span><br><span class=\"line\">            completionHandler: completionHandler,</span><br><span class=\"line\">            options: options)</span><br><span class=\"line\">    &#125; else &#123;    </span><br><span class=\"line\">        tryToRetrieveImageFromCache(</span><br><span class=\"line\">            forKey: resource.cacheKey,</span><br><span class=\"line\">            with: resource.downloadURL, </span><br><span class=\"line\">            retrieveImageTask: task,</span><br><span class=\"line\">            progressBlock: progressBlock,</span><br><span class=\"line\">            completionHandler: completionHandler,</span><br><span class=\"line\">            options: options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return task</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，代码会通过<code>KingfisherOptionsInfo</code>进行判断是强制刷新，网络下载并执行缓存策略还是从内存或文件中获取对应的Image。</p>\n<h3 id=\"图片下载\"><a href=\"#图片下载\" class=\"headerlink\" title=\"图片下载\"></a>图片下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">func downloadAndCacheImage(with url: URL,</span><br><span class=\"line\">                         forKey key: String,</span><br><span class=\"line\">                  retrieveImageTask: RetrieveImageTask,</span><br><span class=\"line\">                      progressBlock: DownloadProgressBlock?,</span><br><span class=\"line\">                  completionHandler: CompletionHandler?,</span><br><span class=\"line\">                            options: KingfisherOptionsInfo) -&gt; RetrieveImageDownloadTask?&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>downloadAndCacheImage</code>方法中，会<code>return  downloader.downloadImage</code>方法，下载的主要逻辑在这里实现，对应的文件是<em>ImageDownloader.swift</em>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">open func downloadImage(with url: URL,</span><br><span class=\"line\">               retrieveImageTask: RetrieveImageTask? = nil,</span><br><span class=\"line\">                         options: KingfisherOptionsInfo? = nil,</span><br><span class=\"line\">                   progressBlock: ImageDownloaderProgressBlock? = nil,</span><br><span class=\"line\">               completionHandler: ImageDownloaderCompletionHandler? = nil) -&gt; RetrieveImageDownloadTask?&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>ImageDownloader.swift</code>文件中，主要参数：</p>\n<ul>\n<li><code>downloadTimeout</code> 超时时间，默认15秒</li>\n<li><code>trustedHosts</code> 信任的请求地址，和自己实现请求代理设置冲突，二选一</li>\n<li><code>sessionConfiguration</code> session配置设置</li>\n<li><code>requestsUsePipelining</code> 请求是否管道类型，是否按顺序下载，默认<code>false</code></li>\n<li><code>sessionHandler</code>单独设计出的一个<code>ImageDownloaderSessionHandler</code>，是为了解决之前出现的<a href=\"https://github.com/onevcat/Kingfisher/issues/235\" target=\"_blank\" rel=\"noopener\">内存泄漏</a></li>\n<li><code>delegate</code> 下载代理</li>\n<li><code>authenticationChallengeResponder</code> 信任请求代理，和trustedHosts冲突二选一</li>\n<li><code>fetchLoads</code> 下载完成每个URL可能有多个处理方式，优先取这里的</li>\n<li>此外还有三个<code>DispatchQueue</code>：<code>barrierQueue</code>、<code>processQueue</code>、<code>cancelQueue</code></li>\n</ul>\n<p>下载完成后，在<code>completionHandler</code>回调中处理图片，如果下载失败：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if let error = error, error.code == KingfisherError.notModified.rawValue &#123;</span><br><span class=\"line\">    //从缓存中读取，不需保存，直接返回</span><br><span class=\"line\">    targetCache.retrieveImage(forKey: key, options: options, completionHandler: &#123; (cacheImage, cacheType) -&gt; () in</span><br><span class=\"line\">        completionHandler?(cacheImage, nil, cacheType, url)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下载成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if let image = image, let originalData = originalData &#123;</span><br><span class=\"line\">    //存储图片</span><br><span class=\"line\">    targetCache.store(image,</span><br><span class=\"line\">                      original: originalData,</span><br><span class=\"line\">                      forKey: key,</span><br><span class=\"line\">                      processorIdentifier:options.processor.identifier,</span><br><span class=\"line\">                      cacheSerializer: options.cacheSerializer,</span><br><span class=\"line\">                      toDisk: !options.cacheMemoryOnly,</span><br><span class=\"line\">                      completionHandler: nil)</span><br><span class=\"line\">        if options.cacheOriginalImage &amp;&amp; options.processor != DefaultImageProcessor.default &#123;</span><br><span class=\"line\">            let originalCache = options.originalCache</span><br><span class=\"line\">            let defaultProcessor = DefaultImageProcessor.default</span><br><span class=\"line\">            if let originalImage = defaultProcessor.process(item: .data(originalData), options: options) &#123;</span><br><span class=\"line\">                originalCache.store(originalImage,</span><br><span class=\"line\">                        original: originalData,</span><br><span class=\"line\">                        forKey: key,</span><br><span class=\"line\">                        processorIdentifier: defaultProcessor.identifier,</span><br><span class=\"line\">                        cacheSerializer: options.cacheSerializer,</span><br><span class=\"line\">                        toDisk: !options.cacheMemoryOnly,</span><br><span class=\"line\">                        completionHandler: nil)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"存储图片\"><a href=\"#存储图片\" class=\"headerlink\" title=\"存储图片\"></a>存储图片</h4><p>我们先来看一下实现的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func store(_ image: Image,</span><br><span class=\"line\">                  original: Data? = nil,</span><br><span class=\"line\">                  forKey key: String,</span><br><span class=\"line\">                  processorIdentifier identifier: String = &quot;&quot;,</span><br><span class=\"line\">                  cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,</span><br><span class=\"line\">                  toDisk: Bool = true,</span><br><span class=\"line\">                  completionHandler: (() -&gt; Void)? = nil)&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码中<code>memoryCache</code>是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fileprivate let memoryCache = NSCache&lt;NSString, AnyObject&gt;()</span><br></pre></td></tr></table></figure></p>\n<p>可见图片存储首先是缓存在<code>NSCache</code>中，如果想存储在磁盘中(<code>if toDisk</code>)，利用串行队列异步的进行存储原图。</p>\n<h4 id=\"获取图片\"><a href=\"#获取图片\" class=\"headerlink\" title=\"获取图片\"></a>获取图片</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">open func retrieveImage(forKey key: String,</span><br><span class=\"line\">                           options: KingfisherOptionsInfo?,</span><br><span class=\"line\">                 completionHandler: ((Image?, CacheType) -&gt; ())?) -&gt; RetrieveImageDiskTask?&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先从内存中获取图片<code>if let image = self.retrieveImageInMemoryCache(forKey: key, options: options)</code></li>\n<li>如果没有，在根据条件判断是否从磁盘上获取<code>if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options)</code></li>\n</ul>\n<h4 id=\"删除图片\"><a href=\"#删除图片\" class=\"headerlink\" title=\"删除图片\"></a>删除图片</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func removeImage(forKey key: String,</span><br><span class=\"line\">                      processorIdentifier identifier: String = &quot;&quot;,</span><br><span class=\"line\">                      fromDisk: Bool = true,</span><br><span class=\"line\">                      completionHandler: (() -&gt; Void)? = nil)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc public func clearMemoryCache() &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func clearDiskCache(completion handler: (()-&gt;())? = nil) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func cleanExpiredDiskCache(completion handler: (()-&gt;())? = nil) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc public func backgroundCleanExpiredDiskCache() &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，一些方法是通过通知的方法来实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 系统内存警告</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(clearMemoryCache), name: .UIApplicationDidReceiveMemoryWarning, object: nil)    </span><br><span class=\"line\">// 程序终止</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(cleanExpiredDiskCache), name: .UIApplicationWillTerminate, object: nil)</span><br><span class=\"line\">// 程序进入后台</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(backgroundCleanExpiredDiskCache), name: .UIApplicationDidEnterBackground, object: nil)</span><br></pre></td></tr></table></figure></p>\n<p>此外，还有一些属性要注意:</p>\n<ul>\n<li><code>maxMemoryCost</code>最大缓存量，在收到内存警告时会被清空。</li>\n<li><code>pathExtension</code>沙盒后续拼接文件夹名称</li>\n<li><code>maxCachePeriodInSecond</code>默认清除一周前的图片</li>\n<li><code>maxDiskCacheSize</code>沙盒最大存储量，为0，默认无限制</li>\n</ul>\n<p>以上就是对Kingfisher的简单描述，它有很多方法值得我们去借鉴，比如<code>@discardableResult</code>、<code>where</code>、<code>typealias</code>、<code>if case let</code>、善于利用<code>guard</code>、扩展协议等等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/onevcat/Kingfisher\" target=\"_blank\" rel=\"noopener\">Kingfisher</a>是一个用于图片下载和缓存的轻量级、纯swift库。通过<a href=\"https://weibo.com/onevcat?profile_ftype=1&amp;is_all=1#_rnd1539003449528\" target=\"_blank\" rel=\"noopener\">喵神</a>的介绍，可以得知<code>Kingfisher</code>有以下特点：</p>\n<ul>\n<li>实现了图片的异步下载和缓存</li>\n<li>基于<code>URLSession</code>的网络，提供基本图像处理器和过滤器。</li>\n<li>内存和磁盘的多层缓存。</li>\n<li>可取消下载和处理任务以提高性能。</li>\n<li>独立的组件，根据需要单独使用下载器或缓存系统。</li>\n<li>预览图像并在以后需要时从缓存中显示它们。</li>\n<li>对<code>UIImageView</code>,<code>NSImage</code>和<code>UIButton</code>的扩展，可以直接从<code>URL</code>设置图像。</li>\n<li>设置图像时内置过渡动画。</li>\n<li>加载图像时可自定义占位符。</li>\n<li>可扩展的图像处理和图像格式支持。</li>\n</ul>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><p>在项目中，我们使用<code>CocoaPods</code>下载安装<code>Kingfisher</code>。<br>我们查看<code>Kingfisher</code>的目录结构，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kingfisher</span><br><span class=\"line\">    AnimatedImageView.swift    //动画控件   </span><br><span class=\"line\">    Box.swift    //工具类</span><br><span class=\"line\">    CacheSerializer.swift    //序列化类，读写文件时Data和Image互转</span><br><span class=\"line\">    Filter.swift    //仅对CIImage有效</span><br><span class=\"line\">    FormatIndicatedCacheSerializer.swift    //PNG/JPEG/GIF和Data互转</span><br><span class=\"line\">    Image.swift    //图片格式转换</span><br><span class=\"line\">    ImageCache.swift    //图片缓存</span><br><span class=\"line\">    ImageDownloader.swift    //图片下载</span><br><span class=\"line\">    ImageModifier.swift    //图片修改</span><br><span class=\"line\">    ImagePrefetcher.swift    //图片下载管理类，对并发多个下载任务的处理</span><br><span class=\"line\">    ImageProcessor.swift    //数据处理类，将Data转为Image</span><br><span class=\"line\">    ImageTransition.swift    //动画效果</span><br><span class=\"line\">    ImageView+Kingfisher.swift    //扩展ImageView添加下载图片的方法</span><br><span class=\"line\">    Indicator.swift    //动画相关</span><br><span class=\"line\">    Kingfisher.h    //版本号</span><br><span class=\"line\">    Kingfisher.swift    //类，扩展ImageView添加属性kf</span><br><span class=\"line\">    KingfisherManager.swift    //管理类，封装图片下载和缓存的逻辑</span><br><span class=\"line\">    KingfisherOptionsInfo.swift    //枚举类</span><br><span class=\"line\">    Placeholder.swift    //默认图片管理类</span><br><span class=\"line\">    RequestModifier.swift    //协议，修改原始URLRequest参数</span><br><span class=\"line\">    Resource.swift    //协议，声明下载链接和缓存key</span><br><span class=\"line\">    String+MD5.swift    //MD5加密</span><br><span class=\"line\">    ThreadHelper.swift    //工具类</span><br><span class=\"line\">    UIButton+Kingfisher.swift    //扩展UIButton添加下载图片的方法</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h2><p>很简单的一句话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.imageV.kf.setImage(with: imgUrl)</span><br></pre></td></tr></table></figure></p>\n<p>如果想在图片加载的过程中添加默认图片，可以添加<code>placeholder</code>方法，监听加载的过程<code>progressBlock</code>，图片加载完成后的回调<code>completionHandler</code>。</p>\n<h2 id=\"查看方法\"><a href=\"#查看方法\" class=\"headerlink\" title=\"查看方法\"></a>查看方法</h2><p>查看<code>kf.setImage</code>方法，我们会跳到<em>ImageView+Kingfisher.swift</em>文件里。这里我们对方法做一个简单的介绍<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">public func setImage(with resource: Resource?,</span><br><span class=\"line\">                     placeholder: Placeholder? = nil,</span><br><span class=\"line\">                     options: KingfisherOptionsInfo? = nil,</span><br><span class=\"line\">                     progressBlock: DownloadProgressBlock? = nil,</span><br><span class=\"line\">                     completionHandler: CompletionHandler? = nil) -&gt; RetrieveImageTask&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到，在这个方法里面，包括了ImageView的资源、默认图片、作者封装的枚举类、加载进度的回调以及完成结果。<br><code>@discardableResult</code>方法是为了取消不使用返回值的警告。<br>在这个方法里面(方法太长就不列举出来，捡主要的说)，</p>\n<ul>\n<li>首先判断参数合法性，当<code>resource</code>为<code>nil</code>时，展示默认图片。</li>\n<li>设置读取策略和启动动画。比如常见的一个问题：当用户头像改变但图片<code>URL</code>没有改变时，怎么去处理用户头像。一般有两种方法，一种是在缓存用户头像时保存当前时间。另一种就是设置读取策略，<code>KingfisherOptionsInfo</code>是一个枚举，设置它为<code>forceRefresh</code>时，可以强制刷新。</li>\n<li>从内存、文件或网络<code>URL</code>获取对应图片数据。</li>\n<li>获取图片完成后，在主线程刷新界面。</li>\n</ul>\n<p>我们查看一下这里面的参数：</p>\n<h3 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"Resource\"></a>Resource</h3><p>Resource是一个协议，我们查看源码可以看到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public protocol Resource &#123;</span><br><span class=\"line\">    var cacheKey: String &#123; get &#125;</span><br><span class=\"line\">    var downloadURL: URL &#123; get &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>cacheKey</code>是图片保存的key值，当<code>cacheKey</code>为<code>nil</code>时，取<code>downloadURL.absoluteString</code>(有兴趣的可以去了解一下<code>absoluteString</code>和<code>path</code>的区别)。<code>downloadURL</code>不言而喻，就是图片的<code>URL</code>。</p>\n<h3 id=\"Placeholder\"><a href=\"#Placeholder\" class=\"headerlink\" title=\"Placeholder\"></a>Placeholder</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public protocol Placeholder &#123;</span><br><span class=\"line\">    func add(to imageView: ImageView)</span><br><span class=\"line\">    func remove(from imageView: ImageView)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Placeholder</code>是一个协议，作者为它定义了<code>add</code>和<code>remove</code>方法，任何。默认实现了<code>Image</code>，如果想用<code>View</code>充当<code>Placeholder</code>，只要让<code>view</code>遵守协议即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Placeholder where Self: View&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"KingfisherOptionsInfo\"><a href=\"#KingfisherOptionsInfo\" class=\"headerlink\" title=\"KingfisherOptionsInfo\"></a>KingfisherOptionsInfo</h3><p><code>KingfisherOptionsInfo</code>是一个类型别名，点击查看<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]</span><br></pre></td></tr></table></figure></p>\n<p>所以我们关注的应该是<code>KingfisherOptionsInfoItem</code>是什么东西？那么它是什么呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum KingfisherOptionsInfoItem &#123;</span><br><span class=\"line\">    case targetCache(ImageCache)    //系统缓存位置。可以设置的属性</span><br><span class=\"line\">    case originalCache(ImageCache)    //系统缓存原始图像位置（只用于自己设置placeholder） </span><br><span class=\"line\">    case downloader(ImageDownloader)    //获取更改session属性，设置请求</span><br><span class=\"line\">    case transition(ImageTransition)    //自定义动画</span><br><span class=\"line\">    case downloadPriority(Float)    //下载优先级（0-1）</span><br><span class=\"line\">    case forceRefresh    //每次请求忽略缓存，直接下载</span><br><span class=\"line\">    case fromMemoryCacheOrRefresh    //先取缓存再去文件，再去下载</span><br><span class=\"line\">    case forceTransition    //强制移动</span><br><span class=\"line\">    case cacheMemoryOnly     //只从缓存读取，不读取本机沙盒图片</span><br><span class=\"line\">    case onlyFromCache    //从缓存、沙盒读取，没有也不下载网络，显示placeholder</span><br><span class=\"line\">    case backgroundDecode    //设置后，显示前在后台线程解码</span><br><span class=\"line\">    case callbackDispatchQueue(DispatchQueue?)    //自定义回调队列，默认主线程</span><br><span class=\"line\">    case scaleFactor(CGFloat)    //自定义图片data -&gt; Image缩放比例，不指定按屏幕2x\\3x缩放</span><br><span class=\"line\">    case preloadAllAnimationData    //预先加载data成图片缓存</span><br><span class=\"line\">    case requestModifier(ImageDownloadRequestModifier)    //改变请求</span><br><span class=\"line\">    case processor(ImageProcessor)    //自定义Data转图片样式</span><br><span class=\"line\">    case cacheSerializer(CacheSerializer)    //自定义缓存Data 转图像样式</span><br><span class=\"line\">    case imageModifier(ImageModifier)    //修改图像</span><br><span class=\"line\">    case keepCurrentImageWhileLoading     //包含这个意味着placeHolder设置无效，没有直接用默认</span><br><span class=\"line\">    case onlyLoadFirstFrame    //如果返回结果是.gif图，只取第一帧显示</span><br><span class=\"line\">    case cacheOriginalImage    //同时缓存原始图片和下载后的图片</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"DownloadProgressBlock\"><a href=\"#DownloadProgressBlock\" class=\"headerlink\" title=\"DownloadProgressBlock\"></a>DownloadProgressBlock</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -&gt; ())</span><br></pre></td></tr></table></figure>\n<p><code>DownloadProgressBlock</code>里面有<code>receivedSize</code>和<code>totalSize</code>，可以根据这两个参数得知图片下载了多少和图片多大，也可以计算图片的下载进度。</p>\n<h3 id=\"CompletionHandler\"><a href=\"#CompletionHandler\" class=\"headerlink\" title=\"CompletionHandler\"></a>CompletionHandler</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias CompletionHandler = ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -&gt; ())</span><br></pre></td></tr></table></figure>\n<p><code>CompletionHandler</code>的回调里会有<code>image</code>、<code>error</code>、<code>cacheType</code>、<code>imageURL</code>四个参数。<code>image</code>、<code>error</code>、<code>imageURL</code>不做介绍，直接就能看出什么内容。<br>主要看一下<code>cacheType</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum CacheType &#123;</span><br><span class=\"line\">    case none, memory, disk</span><br><span class=\"line\">    public var cached: Bool &#123;</span><br><span class=\"line\">        switch self &#123;</span><br><span class=\"line\">        case .memory, .disk: return true</span><br><span class=\"line\">        case .none: return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>none</code>检索图片时，图片尚未缓存</li>\n<li><code>memory</code>图片缓存在内存中</li>\n<li><code>disk</code>图片缓存在磁盘中</li>\n</ul>\n<h2 id=\"检索图片\"><a href=\"#检索图片\" class=\"headerlink\" title=\"检索图片\"></a>检索图片</h2><p>OK，让我们继续看这些代码。在<code>setImage</code>方法中，从内存、文件或网络<code>URL</code>获取对应图片数据是怎么实现的呢？这里，我们可以查看<code>KingfisherManager.shared.retrieveImage</code>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">public func retrieveImage(with resource: Resource,</span><br><span class=\"line\">    options: KingfisherOptionsInfo?,</span><br><span class=\"line\">    progressBlock: DownloadProgressBlock?,</span><br><span class=\"line\">    completionHandler: CompletionHandler?) -&gt; RetrieveImageTask</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let task = RetrieveImageTask()</span><br><span class=\"line\">    let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo)</span><br><span class=\"line\">    if options.forceRefresh &#123;</span><br><span class=\"line\">        _ = downloadAndCacheImage(</span><br><span class=\"line\">            with: resource.downloadURL,</span><br><span class=\"line\">            forKey: resource.cacheKey,</span><br><span class=\"line\">            retrieveImageTask: task,</span><br><span class=\"line\">            progressBlock: progressBlock,</span><br><span class=\"line\">            completionHandler: completionHandler,</span><br><span class=\"line\">            options: options)</span><br><span class=\"line\">    &#125; else &#123;    </span><br><span class=\"line\">        tryToRetrieveImageFromCache(</span><br><span class=\"line\">            forKey: resource.cacheKey,</span><br><span class=\"line\">            with: resource.downloadURL, </span><br><span class=\"line\">            retrieveImageTask: task,</span><br><span class=\"line\">            progressBlock: progressBlock,</span><br><span class=\"line\">            completionHandler: completionHandler,</span><br><span class=\"line\">            options: options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return task</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，代码会通过<code>KingfisherOptionsInfo</code>进行判断是强制刷新，网络下载并执行缓存策略还是从内存或文件中获取对应的Image。</p>\n<h3 id=\"图片下载\"><a href=\"#图片下载\" class=\"headerlink\" title=\"图片下载\"></a>图片下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">func downloadAndCacheImage(with url: URL,</span><br><span class=\"line\">                         forKey key: String,</span><br><span class=\"line\">                  retrieveImageTask: RetrieveImageTask,</span><br><span class=\"line\">                      progressBlock: DownloadProgressBlock?,</span><br><span class=\"line\">                  completionHandler: CompletionHandler?,</span><br><span class=\"line\">                            options: KingfisherOptionsInfo) -&gt; RetrieveImageDownloadTask?&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>downloadAndCacheImage</code>方法中，会<code>return  downloader.downloadImage</code>方法，下载的主要逻辑在这里实现，对应的文件是<em>ImageDownloader.swift</em>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">open func downloadImage(with url: URL,</span><br><span class=\"line\">               retrieveImageTask: RetrieveImageTask? = nil,</span><br><span class=\"line\">                         options: KingfisherOptionsInfo? = nil,</span><br><span class=\"line\">                   progressBlock: ImageDownloaderProgressBlock? = nil,</span><br><span class=\"line\">               completionHandler: ImageDownloaderCompletionHandler? = nil) -&gt; RetrieveImageDownloadTask?&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>ImageDownloader.swift</code>文件中，主要参数：</p>\n<ul>\n<li><code>downloadTimeout</code> 超时时间，默认15秒</li>\n<li><code>trustedHosts</code> 信任的请求地址，和自己实现请求代理设置冲突，二选一</li>\n<li><code>sessionConfiguration</code> session配置设置</li>\n<li><code>requestsUsePipelining</code> 请求是否管道类型，是否按顺序下载，默认<code>false</code></li>\n<li><code>sessionHandler</code>单独设计出的一个<code>ImageDownloaderSessionHandler</code>，是为了解决之前出现的<a href=\"https://github.com/onevcat/Kingfisher/issues/235\" target=\"_blank\" rel=\"noopener\">内存泄漏</a></li>\n<li><code>delegate</code> 下载代理</li>\n<li><code>authenticationChallengeResponder</code> 信任请求代理，和trustedHosts冲突二选一</li>\n<li><code>fetchLoads</code> 下载完成每个URL可能有多个处理方式，优先取这里的</li>\n<li>此外还有三个<code>DispatchQueue</code>：<code>barrierQueue</code>、<code>processQueue</code>、<code>cancelQueue</code></li>\n</ul>\n<p>下载完成后，在<code>completionHandler</code>回调中处理图片，如果下载失败：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if let error = error, error.code == KingfisherError.notModified.rawValue &#123;</span><br><span class=\"line\">    //从缓存中读取，不需保存，直接返回</span><br><span class=\"line\">    targetCache.retrieveImage(forKey: key, options: options, completionHandler: &#123; (cacheImage, cacheType) -&gt; () in</span><br><span class=\"line\">        completionHandler?(cacheImage, nil, cacheType, url)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下载成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if let image = image, let originalData = originalData &#123;</span><br><span class=\"line\">    //存储图片</span><br><span class=\"line\">    targetCache.store(image,</span><br><span class=\"line\">                      original: originalData,</span><br><span class=\"line\">                      forKey: key,</span><br><span class=\"line\">                      processorIdentifier:options.processor.identifier,</span><br><span class=\"line\">                      cacheSerializer: options.cacheSerializer,</span><br><span class=\"line\">                      toDisk: !options.cacheMemoryOnly,</span><br><span class=\"line\">                      completionHandler: nil)</span><br><span class=\"line\">        if options.cacheOriginalImage &amp;&amp; options.processor != DefaultImageProcessor.default &#123;</span><br><span class=\"line\">            let originalCache = options.originalCache</span><br><span class=\"line\">            let defaultProcessor = DefaultImageProcessor.default</span><br><span class=\"line\">            if let originalImage = defaultProcessor.process(item: .data(originalData), options: options) &#123;</span><br><span class=\"line\">                originalCache.store(originalImage,</span><br><span class=\"line\">                        original: originalData,</span><br><span class=\"line\">                        forKey: key,</span><br><span class=\"line\">                        processorIdentifier: defaultProcessor.identifier,</span><br><span class=\"line\">                        cacheSerializer: options.cacheSerializer,</span><br><span class=\"line\">                        toDisk: !options.cacheMemoryOnly,</span><br><span class=\"line\">                        completionHandler: nil)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"存储图片\"><a href=\"#存储图片\" class=\"headerlink\" title=\"存储图片\"></a>存储图片</h4><p>我们先来看一下实现的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func store(_ image: Image,</span><br><span class=\"line\">                  original: Data? = nil,</span><br><span class=\"line\">                  forKey key: String,</span><br><span class=\"line\">                  processorIdentifier identifier: String = &quot;&quot;,</span><br><span class=\"line\">                  cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,</span><br><span class=\"line\">                  toDisk: Bool = true,</span><br><span class=\"line\">                  completionHandler: (() -&gt; Void)? = nil)&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码中<code>memoryCache</code>是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fileprivate let memoryCache = NSCache&lt;NSString, AnyObject&gt;()</span><br></pre></td></tr></table></figure></p>\n<p>可见图片存储首先是缓存在<code>NSCache</code>中，如果想存储在磁盘中(<code>if toDisk</code>)，利用串行队列异步的进行存储原图。</p>\n<h4 id=\"获取图片\"><a href=\"#获取图片\" class=\"headerlink\" title=\"获取图片\"></a>获取图片</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">open func retrieveImage(forKey key: String,</span><br><span class=\"line\">                           options: KingfisherOptionsInfo?,</span><br><span class=\"line\">                 completionHandler: ((Image?, CacheType) -&gt; ())?) -&gt; RetrieveImageDiskTask?&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先从内存中获取图片<code>if let image = self.retrieveImageInMemoryCache(forKey: key, options: options)</code></li>\n<li>如果没有，在根据条件判断是否从磁盘上获取<code>if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options)</code></li>\n</ul>\n<h4 id=\"删除图片\"><a href=\"#删除图片\" class=\"headerlink\" title=\"删除图片\"></a>删除图片</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func removeImage(forKey key: String,</span><br><span class=\"line\">                      processorIdentifier identifier: String = &quot;&quot;,</span><br><span class=\"line\">                      fromDisk: Bool = true,</span><br><span class=\"line\">                      completionHandler: (() -&gt; Void)? = nil)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc public func clearMemoryCache() &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func clearDiskCache(completion handler: (()-&gt;())? = nil) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func cleanExpiredDiskCache(completion handler: (()-&gt;())? = nil) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc public func backgroundCleanExpiredDiskCache() &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，一些方法是通过通知的方法来实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 系统内存警告</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(clearMemoryCache), name: .UIApplicationDidReceiveMemoryWarning, object: nil)    </span><br><span class=\"line\">// 程序终止</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(cleanExpiredDiskCache), name: .UIApplicationWillTerminate, object: nil)</span><br><span class=\"line\">// 程序进入后台</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(backgroundCleanExpiredDiskCache), name: .UIApplicationDidEnterBackground, object: nil)</span><br></pre></td></tr></table></figure></p>\n<p>此外，还有一些属性要注意:</p>\n<ul>\n<li><code>maxMemoryCost</code>最大缓存量，在收到内存警告时会被清空。</li>\n<li><code>pathExtension</code>沙盒后续拼接文件夹名称</li>\n<li><code>maxCachePeriodInSecond</code>默认清除一周前的图片</li>\n<li><code>maxDiskCacheSize</code>沙盒最大存储量，为0，默认无限制</li>\n</ul>\n<p>以上就是对Kingfisher的简单描述，它有很多方法值得我们去借鉴，比如<code>@discardableResult</code>、<code>where</code>、<code>typealias</code>、<code>if case let</code>、善于利用<code>guard</code>、扩展协议等等。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjnfp0loj0005imcwp650b507","tag_id":"cjnfp0lof0003imcw9zp3q2tb","_id":"cjnfp0lon0008imcwq0ybzz22"},{"post_id":"cjnfp0lo80000imcwah70l8p5","tag_id":"cjnfp0lof0003imcw9zp3q2tb","_id":"cjnfp0lop000aimcw1ektogy3"},{"post_id":"cjnfp0lok0006imcwg10lko2z","tag_id":"cjnfp0lof0003imcw9zp3q2tb","_id":"cjnfp0lor000dimcwigw4u9cw"},{"post_id":"cjnfp0lon0009imcw0sccdjdl","tag_id":"cjnfp0lof0003imcw9zp3q2tb","_id":"cjnfp0lou000fimcwy6o1cgqo"},{"post_id":"cjnfp0lod0002imcwnn6w5pj0","tag_id":"cjnfp0lof0003imcw9zp3q2tb","_id":"cjnfp0lov000himcw5mrfubcf"},{"post_id":"cjnfp0loh0004imcwz9xc4l16","tag_id":"cjnfp0lof0003imcw9zp3q2tb","_id":"cjnfp0lov000iimcw17ylalim"},{"post_id":"cjnfp0lop000bimcweon6ioy8","tag_id":"cjnfp0lou000gimcwz8rmk6ek","_id":"cjnfp0lox000kimcw2ita7uqs"},{"post_id":"cjnfp0los000eimcwtcudkmy9","tag_id":"cjnfp0low000jimcwp4u7h7nt","_id":"cjnfp0loy000limcwgr9k7ajf"},{"post_id":"cjnfp0lub000mimcw6f8raqkq","tag_id":"cjnfp0lof0003imcw9zp3q2tb","_id":"cjnfp0lug000oimcwn4rvamgy"},{"post_id":"cjnfp0lue000nimcw0mshoatt","tag_id":"cjnfp0lof0003imcw9zp3q2tb","_id":"cjnfp0luj000qimcw9pfrzniv"},{"post_id":"cjnfp0luh000pimcwdno893xu","tag_id":"cjnfp0lof0003imcw9zp3q2tb","_id":"cjnfp0luk000simcweud0s0ji"},{"post_id":"cjnfp0luj000rimcwiom6ia9c","tag_id":"cjnfp0lof0003imcw9zp3q2tb","_id":"cjnfp0lul000uimcw74mzmtjd"},{"post_id":"cjnfp0luk000timcwx9qooc4z","tag_id":"cjnfp0lum000vimcwgyzpwd3m","_id":"cjnfp0lum000wimcwbbqnyzoa"}],"Tag":[{"name":"RxSwift","_id":"cjnfp0lof0003imcw9zp3q2tb"},{"name":"swift 冷门方法","_id":"cjnfp0lou000gimcwz8rmk6ek"},{"name":"其它","_id":"cjnfp0low000jimcwp4u7h7nt"},{"name":"源码阅读","_id":"cjnfp0lum000vimcwgyzpwd3m"}]}}