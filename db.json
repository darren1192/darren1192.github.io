{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"f779efe3b5317844b34039cc0d534341a2b8b73f","modified":1541401394617},{"_id":"themes/next/.DS_Store","hash":"c04ab2ef349f6c4989f84f79f3e67c6f2fb92da7","modified":1539933624934},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1539932867495},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1539932867496},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1539932867498},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1539932867495},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1539932867498},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1539932867498},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1539932867499},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1539932867499},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1539932867498},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1539932867500},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1539932867500},{"_id":"themes/next/_config.yml","hash":"d09ab274ac81db9615d1ba914c7ec6c34b292db9","modified":1539933548510},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1539932867501},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1539932867501},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1539932867499},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1539932867531},{"_id":"source/_posts/.DS_Store","hash":"a5210b8ae50ee89ffa33446728a040111e44856f","modified":1541401386394},{"_id":"source/_posts/RxSwift-Observable-Observer和辅助类型.md","hash":"58e3a5d1d6f6a8f9dc01c328c0043f8bbdb6d167","modified":1539933361840},{"_id":"source/_posts/RxSwift-Observer-观察者.md","hash":"f7931cbc05e31a14ca680eee86c89402746e6595","modified":1539933361841},{"_id":"source/_posts/RxSwift-开门第一篇.md","hash":"d9427abc71e061c1ab1f46fba42f9ad6212a2983","modified":1539933361842},{"_id":"source/_posts/RxSwift-Observable-可观察序列.md","hash":"a679ebe655fb4a861649d39d931d31f8fda5380f","modified":1539933361841},{"_id":"source/_posts/RxSwift-变换操作-Transforming-Observables.md","hash":"995d31dedbc922a7a793ddaae6e3882ae35e4ae1","modified":1539933361841},{"_id":"source/_posts/RxSwift-条件和布尔操作符-Conditional-and-Boolean-Operators.md","hash":"2a64e37d66323ed10665e996d6b1df4f2a8354e4","modified":1539933361842},{"_id":"source/_posts/RxSwift-操作符决策树.md","hash":"a2a88bd7e9a2678573080210187aa6754dc95766","modified":1539933361842},{"_id":"source/_posts/swift-Sequence.md","hash":"972a200d62bedcd5061e02a77b8f79cce1dcdb50","modified":1539933361844},{"_id":"source/_posts/RxSwift-核心.md","hash":"aa08e859be89a6f6f0e9836505099420a07397a6","modified":1539933361843},{"_id":"source/_posts/RxSwift-结合操作符.md","hash":"1a56a4450841889d83d298c1b3253459e1e5be3e","modified":1539933361843},{"_id":"source/_posts/RxSwift-过滤操作符-Filtering-Observables.md","hash":"71365a620bafd87ced6a461f54f0dc25e79ca9cf","modified":1539933361843},{"_id":"source/_posts/源码阅读-Kingfisher.md","hash":"9d9a63433d2f35092ce22ca9807ee4c5acff2183","modified":1539933361845},{"_id":"source/_posts/swift-获取应用相关信息.md","hash":"ee13465ff8f513140d7e78e84352b06b42948c33","modified":1544420007208},{"_id":"source/_posts/一张图片引发的思考.md","hash":"47a67d3bc054c2e90c40e78818aaada28aeba089","modified":1540606443570},{"_id":"source/_posts/网络编程-TCP-IP协议.md","hash":"4fcae3e25f2ecdce30ae5c797c37bf86e444c5a5","modified":1541400725228},{"_id":"source/_posts/网络编程-概述.md","hash":"83f460b2b4e66d7eadf90510446c52354c2db1ab","modified":1541400791269},{"_id":"source/_posts/网络编程-HTTP协议.md","hash":"853ebe71dba06a62ebfa7618a955791202e25d08","modified":1541401276229},{"_id":"source/tags/index.md","hash":"47022c4e01fdf2b3afa3e1c307d1ce27e6916ec4","modified":1539933361845},{"_id":"source/tags/.DS_Store","hash":"45673a8ec47535550c1655fb6f129816c4bf94f9","modified":1539933361845},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1539932867488},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1539932867490},{"_id":"themes/next/.git/index","hash":"c68c6adf69424f2fc92155f4eaca1b80ee7a525c","modified":1539932964301},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1539932843901},{"_id":"themes/next/.git/packed-refs","hash":"8e36811256ee380c2c65692f1b8f8e77c5bc33c9","modified":1539932867486},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1539932867496},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1539932867496},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1539932867497},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1539932867497},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1539932867502},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1539932867503},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1539932867502},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1539932867503},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1539932867503},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1539932867504},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1539932867504},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1539932867504},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1539932867504},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1539932867505},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1539932867505},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1539932867505},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1539932867505},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1539932867505},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1539932867506},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1539932867506},{"_id":"themes/next/layout/.DS_Store","hash":"adad15655ef7ba7e3b39a89602157c5e89d99202","modified":1539933624938},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1539932867507},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1539932867529},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1539932867530},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1539932867531},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1539932867530},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1539932867531},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1539932867529},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1539932867529},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1539932867532},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1539932867532},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1539932867644},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1539932867645},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1539932867645},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867570},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1539932843901},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1539932843902},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1539932843902},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1539932843903},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1539932843902},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1539932843903},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1539932843904},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1539932843902},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1539932843903},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1539932843903},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1539932843904},{"_id":"themes/next/.git/logs/HEAD","hash":"fec6037e001909c10a6b33b3405348f08bb4f68c","modified":1539932867489},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1539932867507},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1539932867507},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1539932867508},{"_id":"themes/next/layout/_macro/post.swig","hash":"4aa7eda227587e8a33d477c77e7d3ae463c0de18","modified":1539933716204},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1539932867508},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1539932867507},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1539932867506},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1539932867509},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1539932867515},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1539932867517},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1539932867518},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1539932867509},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1539932867510},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1539932867510},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1539932867512},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1539932867511},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1539932867512},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1539932867512},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1539932867525},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1539932867525},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1539932867525},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1539932867526},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1539932867526},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1539932867526},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1539932867526},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1539932867533},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1539932867533},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1539932867534},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1539932867534},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1539932867534},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1539932867535},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1539932867535},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1539932867535},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1539932867536},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1539932867570},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1539932867571},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1539932867571},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1539932867572},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1539932867572},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1539932867571},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1539932867573},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1539932867574},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1539932867575},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1539932867573},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1539932867574},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1539932867575},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1539932867574},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1539932867576},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1539932867576},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1539932867575},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1539932867576},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1539932867577},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1539932867577},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867518},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867518},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867560},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867560},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867561},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867569},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1539932867570},{"_id":"themes/next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1539932867488},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1539932867517},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1539932867518},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1539932867517},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1539932867511},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1539932867511},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1539932867513},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1539932867513},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1539932867513},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1539932867514},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1539932867514},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1539932867514},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1539932867514},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1539932867523},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1539932867523},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1539932867523},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1539932867523},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1539932867524},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1539932867524},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1539932867524},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1539932867524},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1539932867525},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1539932867519},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1539932867519},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1539932867520},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1539932867519},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1539932867520},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1539932867521},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1539932867520},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1539932867521},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1539932867521},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1539932867521},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1539932867522},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1539932867522},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1539932867522},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1539932867527},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1539932867528},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1539932867528},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1539932867528},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1539932867559},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1539932867560},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1539932867561},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1539932867560},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1539932867569},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1539932867569},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1539932867569},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1539932867570},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1539932867578},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1539932867579},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1539932867579},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1539932867580},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1539932867578},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1539932867578},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1539932867580},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1539932867580},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1539932867581},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1539932867582},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1539932867581},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1539932867588},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1539932867593},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1539932867593},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1539932867594},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1539932867594},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1539932867604},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1539932867603},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1539932867604},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1539932867603},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1539932867604},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1539932867601},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1539932867601},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1539932867602},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1539932867602},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1539932867622},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1539932867622},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1539932867623},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1539932867623},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1539932867623},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1539932867623},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1539932867631},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1539932867631},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1539932867624},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1539932867632},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1539932867625},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1539932867626},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1539932867626},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1539932867625},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1539932867626},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1539932867627},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1539932867627},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1539932867627},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1539932867628},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1539932867628},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1539932867628},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1539932867629},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1539932867629},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1539932867629},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1539932867630},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1539932867630},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1539932867639},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1539932867639},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1539932867642},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1539932867644},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1539932867643},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1539932867620},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1539932867621},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"fec6037e001909c10a6b33b3405348f08bb4f68c","modified":1539932867489},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1539932867487},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1539932867527},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1539932867527},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1539932867557},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1539932867558},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1539932867558},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1539932867558},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1539932867558},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1539932867559},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1539932867559},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1539932867536},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1539932867537},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1539932867537},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1539932867537},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1539932867537},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1539932867542},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1539932867550},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1539932867561},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1539932867562},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1539932867562},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1539932867562},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1539932867563},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1539932867563},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1539932867563},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1539932867564},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1539932867565},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1539932867565},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1539932867565},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1539932867566},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1539932867566},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1539932867567},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1539932867567},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1539932867567},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1539932867568},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1539932867568},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1539932867568},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1539932867581},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1539932867585},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1539932867587},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1539932867588},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1539932867594},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1539932867595},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1539932867595},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1539932867596},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1539932867596},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1539932867596},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1539932867599},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1539932867600},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1539932867599},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1539932867606},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1539932867605},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1539932867605},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1539932867603},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1539932867602},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1539932867638},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1539932867638},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1539932867587},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1539932867619},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1539932867619},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1539932867641},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"fec6037e001909c10a6b33b3405348f08bb4f68c","modified":1539932867487},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1539932867539},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1539932867538},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1539932867539},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1539932867539},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1539932867541},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1539932867541},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1539932867539},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1539932867541},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1539932867542},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1539932867542},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1539932867547},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1539932867547},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1539932867548},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1539932867549},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1539932867548},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1539932867549},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1539932867549},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1539932867550},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1539932867550},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1539932867550},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1539932867540},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1539932867541},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1539932867540},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1539932867543},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1539932867543},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1539932867544},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1539932867543},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1539932867544},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1539932867545},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1539932867544},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1539932867544},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1539932867545},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1539932867545},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1539932867546},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1539932867546},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1539932867546},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1539932867551},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1539932867546},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1539932867547},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1539932867551},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1539932867552},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1539932867552},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1539932867552},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1539932867553},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1539932867553},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1539932867554},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1539932867554},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1539932867554},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1539932867553},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1539932867555},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1539932867555},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1539932867555},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1539932867556},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1539932867556},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1539932867556},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1539932867556},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1539932867538},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1539932867557},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1539932867564},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1539932867564},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1539932867566},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1539932867583},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1539932867583},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1539932867584},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1539932867584},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1539932867585},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1539932867597},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1539932867597},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1539932867598},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1539932867597},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1539932867598},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1539932867598},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1539932867608},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1539932867618},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1539932867611},{"_id":"themes/next/.git/objects/pack/pack-bef4d2add504242e74ed1374f132b443073d8f8a.idx","hash":"b70c62326a6b37fa37000c4c22c5056990d5955b","modified":1539932867467},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1539932867592},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1539932867636},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1539932867615},{"_id":"themes/next/.git/objects/pack/pack-bef4d2add504242e74ed1374f132b443073d8f8a.pack","hash":"dc578b9d9f8779e98d2a93a35f021ce52be5b1e4","modified":1539932867461}],"Category":[],"Data":[],"Page":[{"title":"All Tags","date":"2018-09-13T13:48:18.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: All Tags\ndate: 2018-09-13 21:48:18\ntype: \"tags\"\n---\n","updated":"2018-10-19T07:16:01.845Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjphvsxy2000n2ycwoyxmjoa0","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"RxSwift Observer-观察者","date":"2018-09-21T15:18:04.000Z","_content":"我们在[之前](https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more)已经了解了什么是`Observer`观察者，这篇我们了解一下怎么创建观察者以及特征观察者(`AnyObserver`、`Binder`)。\n#### 在 subscribe 方法中创建\n创建观察者最直接的方法就是在`Observable`的`subscribe`方法后面描述当事件发生时，需要如何做出响应。举个🌰：\n```\nlet observable = Observable.of(1,2,3,4,5)\nobservable.subscribe(onNext: { element in\n    print(element)\n}, onError: { error in\n    print(error)\n}, onCompleted: {\n    print(\"completed\")\n})\n```\n运行结果如下：\n![运行结果.png](https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 在bind方法中创建\n我们创建一个定时生成索引数的`Observable`序列，并将索引数不断显示在`label`标签上\n举个🌰：\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{ \"当前索引数:\\($0)\" }\n                .bind { [weak self](text) in\n                    self?.label.text = text\n                }.disposed(by: disposeBag)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n运行结果：\n![bind结果.png](https://upload-images.jianshu.io/upload_images/2855070-c9f8b9f5593b1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n除了以上创建方法外，我们还可以使用其他的方式，比如`AnyObserver`和`Binder `\n#### 使用AnyObserver创建观察者\n`AnyObserver`可以用来描叙任意一种观察者\n##### 配合`subscribe `方法使用\n```\nlet observer: AnyObserver<Int> = AnyObserver { event in\n    switch event{\n    case .next(let data):\n        print(data)\n    case .error(let error):\n        print(error)\n    case .completed:\n        print(\"completed\")\n    }\n}\nlet observable = Observable.of(1,2,3,4,5)\nobservable.subscribe(observer)\n```\n运行结果如下：\n![运行结果.png](https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n##### 配合bindTo方法使用\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observer: AnyObserver<String> = AnyObserver{\n            [weak self] event in\n            switch event{\n            case .next(let text):\n                self?.label.text = text\n            default:\n            break\n            }\n        }\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{\"当前索引数:\\($0)\"}\n                .bind(to: observer)\n                .disposed(by: disposeBag )\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n}\n```\n#### Binder\nBinder 主要有以下两个特征：\n- 不会处理错误事件\n- 确保绑定都是在给定`Schedule`上执行（默认`MainScheduler`）\n\n一旦产生错误事件，在调试环境下将执行`fatalError`，在发布环境下将打印错误信息\n在上面更新`label`文字的例子中，更好的方式就是使用`Binder`。理由有二：\n- UI的更新在主线程完成\n- 只处理`next`事件\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observer: Binder<String> = Binder(label){\n            (view,text) in\n            view.text = text\n        }\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{ \"当前索引数:\\($0)\"}\n                .bind(to: observer)\n                .disposed(by: disposeBag)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n下面，我们再去实现另外一段代码：\n```\nlet observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\nobservable.map{ $0 % 2 == 0}\n        .bind(to: label.rx.isHidden)\n        .disposed(by: disposeBag)\n```\n此时label会不断的消失、出现。这段代码里我们又操作了什么？查看`label.rx.isHidden`中`isHidden`可以发现\n```\nextension Reactive where Base: UIView {\n    public var isHidden: Binder<Bool> {\n        return Binder(self.base) { view, hidden in\n            view.isHidden = hidden\n        }\n    }\n}\n```\n其实`RxCocoa`在对许多 UI 控件进行扩展时，就利用`Binder`将控件属性变成观查者，我们也可以用这种方式来创建自定义的 UI 观察者。\n\n\n\n\n\n","source":"_posts/RxSwift-Observer-观察者.md","raw":"---\ntitle: RxSwift Observer-观察者\ndate: 2018-09-21 23:18:04\ntags: RxSwift\n---\n我们在[之前](https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more)已经了解了什么是`Observer`观察者，这篇我们了解一下怎么创建观察者以及特征观察者(`AnyObserver`、`Binder`)。\n#### 在 subscribe 方法中创建\n创建观察者最直接的方法就是在`Observable`的`subscribe`方法后面描述当事件发生时，需要如何做出响应。举个🌰：\n```\nlet observable = Observable.of(1,2,3,4,5)\nobservable.subscribe(onNext: { element in\n    print(element)\n}, onError: { error in\n    print(error)\n}, onCompleted: {\n    print(\"completed\")\n})\n```\n运行结果如下：\n![运行结果.png](https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 在bind方法中创建\n我们创建一个定时生成索引数的`Observable`序列，并将索引数不断显示在`label`标签上\n举个🌰：\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{ \"当前索引数:\\($0)\" }\n                .bind { [weak self](text) in\n                    self?.label.text = text\n                }.disposed(by: disposeBag)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n运行结果：\n![bind结果.png](https://upload-images.jianshu.io/upload_images/2855070-c9f8b9f5593b1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n除了以上创建方法外，我们还可以使用其他的方式，比如`AnyObserver`和`Binder `\n#### 使用AnyObserver创建观察者\n`AnyObserver`可以用来描叙任意一种观察者\n##### 配合`subscribe `方法使用\n```\nlet observer: AnyObserver<Int> = AnyObserver { event in\n    switch event{\n    case .next(let data):\n        print(data)\n    case .error(let error):\n        print(error)\n    case .completed:\n        print(\"completed\")\n    }\n}\nlet observable = Observable.of(1,2,3,4,5)\nobservable.subscribe(observer)\n```\n运行结果如下：\n![运行结果.png](https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n##### 配合bindTo方法使用\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observer: AnyObserver<String> = AnyObserver{\n            [weak self] event in\n            switch event{\n            case .next(let text):\n                self?.label.text = text\n            default:\n            break\n            }\n        }\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{\"当前索引数:\\($0)\"}\n                .bind(to: observer)\n                .disposed(by: disposeBag )\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n        // Dispose of any resources that can be recreated.\n    }\n}\n```\n#### Binder\nBinder 主要有以下两个特征：\n- 不会处理错误事件\n- 确保绑定都是在给定`Schedule`上执行（默认`MainScheduler`）\n\n一旦产生错误事件，在调试环境下将执行`fatalError`，在发布环境下将打印错误信息\n在上面更新`label`文字的例子中，更好的方式就是使用`Binder`。理由有二：\n- UI的更新在主线程完成\n- 只处理`next`事件\n```\nimport UIKit\nimport RxCocoa\nimport RxSwift\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var label: UILabel!\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n        let observer: Binder<String> = Binder(label){\n            (view,text) in\n            view.text = text\n        }\n        let observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\n        observable.map{ \"当前索引数:\\($0)\"}\n                .bind(to: observer)\n                .disposed(by: disposeBag)\n    }\n\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n下面，我们再去实现另外一段代码：\n```\nlet observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\nobservable.map{ $0 % 2 == 0}\n        .bind(to: label.rx.isHidden)\n        .disposed(by: disposeBag)\n```\n此时label会不断的消失、出现。这段代码里我们又操作了什么？查看`label.rx.isHidden`中`isHidden`可以发现\n```\nextension Reactive where Base: UIView {\n    public var isHidden: Binder<Bool> {\n        return Binder(self.base) { view, hidden in\n            view.isHidden = hidden\n        }\n    }\n}\n```\n其实`RxCocoa`在对许多 UI 控件进行扩展时，就利用`Binder`将控件属性变成观查者，我们也可以用这种方式来创建自定义的 UI 观察者。\n\n\n\n\n\n","slug":"RxSwift-Observer-观察者","published":1,"updated":"2018-10-19T07:16:01.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxrj00002ycwdrdjrqry","content":"<p>我们在<a href=\"https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more\" target=\"_blank\" rel=\"noopener\">之前</a>已经了解了什么是<code>Observer</code>观察者，这篇我们了解一下怎么创建观察者以及特征观察者(<code>AnyObserver</code>、<code>Binder</code>)。</p>\n<h4 id=\"在-subscribe-方法中创建\"><a href=\"#在-subscribe-方法中创建\" class=\"headerlink\" title=\"在 subscribe 方法中创建\"></a>在 subscribe 方法中创建</h4><p>创建观察者最直接的方法就是在<code>Observable</code>的<code>subscribe</code>方法后面描述当事件发生时，需要如何做出响应。举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(1,2,3,4,5)</span><br><span class=\"line\">observable.subscribe(onNext: &#123; element in</span><br><span class=\"line\">    print(element)</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">    print(error)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"运行结果.png\"></p>\n<h4 id=\"在bind方法中创建\"><a href=\"#在bind方法中创建\" class=\"headerlink\" title=\"在bind方法中创建\"></a>在bind方法中创建</h4><p>我们创建一个定时生成索引数的<code>Observable</code>序列，并将索引数不断显示在<code>label</code>标签上<br>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123; &quot;当前索引数:\\($0)&quot; &#125;</span><br><span class=\"line\">                .bind &#123; [weak self](text) in</span><br><span class=\"line\">                    self?.label.text = text</span><br><span class=\"line\">                &#125;.disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-c9f8b9f5593b1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"bind结果.png\"><br>除了以上创建方法外，我们还可以使用其他的方式，比如<code>AnyObserver</code>和<code>Binder</code></p>\n<h4 id=\"使用AnyObserver创建观察者\"><a href=\"#使用AnyObserver创建观察者\" class=\"headerlink\" title=\"使用AnyObserver创建观察者\"></a>使用AnyObserver创建观察者</h4><p><code>AnyObserver</code>可以用来描叙任意一种观察者</p>\n<h5 id=\"配合subscribe方法使用\"><a href=\"#配合subscribe方法使用\" class=\"headerlink\" title=\"配合subscribe方法使用\"></a>配合<code>subscribe</code>方法使用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observer: AnyObserver&lt;Int&gt; = AnyObserver &#123; event in</span><br><span class=\"line\">    switch event&#123;</span><br><span class=\"line\">    case .next(let data):</span><br><span class=\"line\">        print(data)</span><br><span class=\"line\">    case .error(let error):</span><br><span class=\"line\">        print(error)</span><br><span class=\"line\">    case .completed:</span><br><span class=\"line\">        print(&quot;completed&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let observable = Observable.of(1,2,3,4,5)</span><br><span class=\"line\">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"运行结果.png\"></p>\n<h5 id=\"配合bindTo方法使用\"><a href=\"#配合bindTo方法使用\" class=\"headerlink\" title=\"配合bindTo方法使用\"></a>配合bindTo方法使用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observer: AnyObserver&lt;String&gt; = AnyObserver&#123;</span><br><span class=\"line\">            [weak self] event in</span><br><span class=\"line\">            switch event&#123;</span><br><span class=\"line\">            case .next(let text):</span><br><span class=\"line\">                self?.label.text = text</span><br><span class=\"line\">            default:</span><br><span class=\"line\">            break</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123;&quot;当前索引数:\\($0)&quot;&#125;</span><br><span class=\"line\">                .bind(to: observer)</span><br><span class=\"line\">                .disposed(by: disposeBag )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">        // Dispose of any resources that can be recreated.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h4><p>Binder 主要有以下两个特征：</p>\n<ul>\n<li>不会处理错误事件</li>\n<li>确保绑定都是在给定<code>Schedule</code>上执行（默认<code>MainScheduler</code>）</li>\n</ul>\n<p>一旦产生错误事件，在调试环境下将执行<code>fatalError</code>，在发布环境下将打印错误信息<br>在上面更新<code>label</code>文字的例子中，更好的方式就是使用<code>Binder</code>。理由有二：</p>\n<ul>\n<li>UI的更新在主线程完成</li>\n<li>只处理<code>next</code>事件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observer: Binder&lt;String&gt; = Binder(label)&#123;</span><br><span class=\"line\">            (view,text) in</span><br><span class=\"line\">            view.text = text</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123; &quot;当前索引数:\\($0)&quot;&#125;</span><br><span class=\"line\">                .bind(to: observer)</span><br><span class=\"line\">                .disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>下面，我们再去实现另外一段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.map&#123; $0 % 2 == 0&#125;</span><br><span class=\"line\">        .bind(to: label.rx.isHidden)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>此时label会不断的消失、出现。这段代码里我们又操作了什么？查看<code>label.rx.isHidden</code>中<code>isHidden</code>可以发现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Reactive where Base: UIView &#123;</span><br><span class=\"line\">    public var isHidden: Binder&lt;Bool&gt; &#123;</span><br><span class=\"line\">        return Binder(self.base) &#123; view, hidden in</span><br><span class=\"line\">            view.isHidden = hidden</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实<code>RxCocoa</code>在对许多 UI 控件进行扩展时，就利用<code>Binder</code>将控件属性变成观查者，我们也可以用这种方式来创建自定义的 UI 观察者。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们在<a href=\"https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more\" target=\"_blank\" rel=\"noopener\">之前</a>已经了解了什么是<code>Observer</code>观察者，这篇我们了解一下怎么创建观察者以及特征观察者(<code>AnyObserver</code>、<code>Binder</code>)。</p>\n<h4 id=\"在-subscribe-方法中创建\"><a href=\"#在-subscribe-方法中创建\" class=\"headerlink\" title=\"在 subscribe 方法中创建\"></a>在 subscribe 方法中创建</h4><p>创建观察者最直接的方法就是在<code>Observable</code>的<code>subscribe</code>方法后面描述当事件发生时，需要如何做出响应。举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(1,2,3,4,5)</span><br><span class=\"line\">observable.subscribe(onNext: &#123; element in</span><br><span class=\"line\">    print(element)</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">    print(error)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"运行结果.png\"></p>\n<h4 id=\"在bind方法中创建\"><a href=\"#在bind方法中创建\" class=\"headerlink\" title=\"在bind方法中创建\"></a>在bind方法中创建</h4><p>我们创建一个定时生成索引数的<code>Observable</code>序列，并将索引数不断显示在<code>label</code>标签上<br>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123; &quot;当前索引数:\\($0)&quot; &#125;</span><br><span class=\"line\">                .bind &#123; [weak self](text) in</span><br><span class=\"line\">                    self?.label.text = text</span><br><span class=\"line\">                &#125;.disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-c9f8b9f5593b1ffd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"bind结果.png\"><br>除了以上创建方法外，我们还可以使用其他的方式，比如<code>AnyObserver</code>和<code>Binder</code></p>\n<h4 id=\"使用AnyObserver创建观察者\"><a href=\"#使用AnyObserver创建观察者\" class=\"headerlink\" title=\"使用AnyObserver创建观察者\"></a>使用AnyObserver创建观察者</h4><p><code>AnyObserver</code>可以用来描叙任意一种观察者</p>\n<h5 id=\"配合subscribe方法使用\"><a href=\"#配合subscribe方法使用\" class=\"headerlink\" title=\"配合subscribe方法使用\"></a>配合<code>subscribe</code>方法使用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observer: AnyObserver&lt;Int&gt; = AnyObserver &#123; event in</span><br><span class=\"line\">    switch event&#123;</span><br><span class=\"line\">    case .next(let data):</span><br><span class=\"line\">        print(data)</span><br><span class=\"line\">    case .error(let error):</span><br><span class=\"line\">        print(error)</span><br><span class=\"line\">    case .completed:</span><br><span class=\"line\">        print(&quot;completed&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let observable = Observable.of(1,2,3,4,5)</span><br><span class=\"line\">observable.subscribe(observer)</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b7c14b064cc5ab89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"运行结果.png\"></p>\n<h5 id=\"配合bindTo方法使用\"><a href=\"#配合bindTo方法使用\" class=\"headerlink\" title=\"配合bindTo方法使用\"></a>配合bindTo方法使用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observer: AnyObserver&lt;String&gt; = AnyObserver&#123;</span><br><span class=\"line\">            [weak self] event in</span><br><span class=\"line\">            switch event&#123;</span><br><span class=\"line\">            case .next(let text):</span><br><span class=\"line\">                self?.label.text = text</span><br><span class=\"line\">            default:</span><br><span class=\"line\">            break</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123;&quot;当前索引数:\\($0)&quot;&#125;</span><br><span class=\"line\">                .bind(to: observer)</span><br><span class=\"line\">                .disposed(by: disposeBag )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">        // Dispose of any resources that can be recreated.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Binder\"><a href=\"#Binder\" class=\"headerlink\" title=\"Binder\"></a>Binder</h4><p>Binder 主要有以下两个特征：</p>\n<ul>\n<li>不会处理错误事件</li>\n<li>确保绑定都是在给定<code>Schedule</code>上执行（默认<code>MainScheduler</code>）</li>\n</ul>\n<p>一旦产生错误事件，在调试环境下将执行<code>fatalError</code>，在发布环境下将打印错误信息<br>在上面更新<code>label</code>文字的例子中，更好的方式就是使用<code>Binder</code>。理由有二：</p>\n<ul>\n<li>UI的更新在主线程完成</li>\n<li>只处理<code>next</code>事件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        // Do any additional setup after loading the view, typically from a nib.</span><br><span class=\"line\">        let observer: Binder&lt;String&gt; = Binder(label)&#123;</span><br><span class=\"line\">            (view,text) in</span><br><span class=\"line\">            view.text = text</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        observable.map&#123; &quot;当前索引数:\\($0)&quot;&#125;</span><br><span class=\"line\">                .bind(to: observer)</span><br><span class=\"line\">                .disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>下面，我们再去实现另外一段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.map&#123; $0 % 2 == 0&#125;</span><br><span class=\"line\">        .bind(to: label.rx.isHidden)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>此时label会不断的消失、出现。这段代码里我们又操作了什么？查看<code>label.rx.isHidden</code>中<code>isHidden</code>可以发现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Reactive where Base: UIView &#123;</span><br><span class=\"line\">    public var isHidden: Binder&lt;Bool&gt; &#123;</span><br><span class=\"line\">        return Binder(self.base) &#123; view, hidden in</span><br><span class=\"line\">            view.isHidden = hidden</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实<code>RxCocoa</code>在对许多 UI 控件进行扩展时，就利用<code>Binder</code>将控件属性变成观查者，我们也可以用这种方式来创建自定义的 UI 观察者。</p>\n"},{"title":"RxSwift-开门第一篇","date":"2018-09-18T15:07:11.000Z","_content":"## 开篇扯淡：\n&emsp;&emsp;为什么入RxSwift这个坑？因为我作为一个iOSer，主要语言是swift，日常开发已经很少使用OC。随着产品代码量日益增加，准备从MVC转成MVVM，而MVVM最搭配的就是RxSwift。所以，作为我个人来说，入RxSwift这个坑，还是比较合情合理的。\n## 正经内容：\n### ReactiveX是什么\n[ReactiveX](http://reactivex.io/)（简写: Rx）是一个可以帮助我们简化异步编程的框架.\n它拓展了[观察者模式](https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F)。使你能够自由组合多个异步事件，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。\n### 什么是RxSwift\n[RxSwift](https://github.com/ReactiveX/RxSwift) 是 [Rx](https://github.com/Reactive-Extensions/Rx.NET) 的 **Swift** 版本，它尝试将原有的一些概念移植到 iOS/macOS 平台。\n### 为什么要使用RxSwift\n>复合 - Rx 就是复合的代名词\n复用 - 因为它易复合\n清晰 - 因为声明都是不可变更的\n易用 - 因为它抽象的了异步编程，使我们统一了代码风格\n稳定 - 因为 Rx 是完全通过单元测试的  \n\n当然了，上面都是假大空，具体来说\n在编写代码时我们经常会需要检测某些值的变化，然后进行相应的处理。比如说按钮的点击事件、textFiled值的变化、tableView中cell的点击事件等等。在日常搬砖中，我们针对不同的情况，需要采用不同的事件传递方法去处理，比如**delegate**、**notifinotion**、**target-action**、**KVO**等等。\n而在RxSwift中，让程序里的事件传递响应方法做到统一，全部采用Rx的“信号链”方式。举个🌰：\n__Target Action__\n```\nbutton.addTarget(self, action: #selector(buttonEvent), for: .touchUpInside)\n```\n```\n@objc func buttonEvent(){\n    print(\"button Event\")\n}\n```\n用Rx实现\n```\nbutton.rx.tap.subscribe(onNext: { () in\n    print(\"button event\")\n}, onError: nil, onCompleted: nil, onDispo\nsed: nil)\n```\n这样一来，代码逻辑清晰可见。\n当然了，为了MVVM，还是很有学习RxSwift的必要的。\n#### RxSwift地址与安装\n传送门：[GitHub](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FReactiveX%2FRxSwift)\n这里面啥都有，无需多言。\n#### RxSwift 与 RxCocoa\nRxSwift在日常使用中，需要import\n```\nimport RxCocoa\nimport RxSwift\n```\n这个两个库的作用分别是：\n- RxSwift：它只是基于 Swift 语言的 Rx 标准实现接口库，所以 RxSwift 里不包含任何 Cocoa 或者 UI方面的类。\n- RxCocoa：是基于 RxSwift针对于 iOS开发的一个库，它通过 Extension 的方法给原生的比如 UI 控件添加了 Rx 的特性，使得我们更容易订阅和响应这些控件的事件。\n\n既然已经有了这个RxSwift开篇，希望自己坚持下去。虽然不太喜欢写文章，但这也不失为监督自己的一个方法。__笨鸟先飞，知行合一。__\n最后，感谢那些“巨人”，对于RxSwift的学习，完全是站在巨人的肩膀上，感谢他们的文章，指引了我的方向。尤其感谢[RxSwift中文文档](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/)和[航哥swift](http://www.hangge.com/)，他们的文章，对我的帮助很大，感谢。\n","source":"_posts/RxSwift-开门第一篇.md","raw":"---\ntitle: RxSwift-开门第一篇\ndate: 2018-09-18 23:07:11\ntags: RxSwift\n---\n## 开篇扯淡：\n&emsp;&emsp;为什么入RxSwift这个坑？因为我作为一个iOSer，主要语言是swift，日常开发已经很少使用OC。随着产品代码量日益增加，准备从MVC转成MVVM，而MVVM最搭配的就是RxSwift。所以，作为我个人来说，入RxSwift这个坑，还是比较合情合理的。\n## 正经内容：\n### ReactiveX是什么\n[ReactiveX](http://reactivex.io/)（简写: Rx）是一个可以帮助我们简化异步编程的框架.\n它拓展了[观察者模式](https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F)。使你能够自由组合多个异步事件，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。\n### 什么是RxSwift\n[RxSwift](https://github.com/ReactiveX/RxSwift) 是 [Rx](https://github.com/Reactive-Extensions/Rx.NET) 的 **Swift** 版本，它尝试将原有的一些概念移植到 iOS/macOS 平台。\n### 为什么要使用RxSwift\n>复合 - Rx 就是复合的代名词\n复用 - 因为它易复合\n清晰 - 因为声明都是不可变更的\n易用 - 因为它抽象的了异步编程，使我们统一了代码风格\n稳定 - 因为 Rx 是完全通过单元测试的  \n\n当然了，上面都是假大空，具体来说\n在编写代码时我们经常会需要检测某些值的变化，然后进行相应的处理。比如说按钮的点击事件、textFiled值的变化、tableView中cell的点击事件等等。在日常搬砖中，我们针对不同的情况，需要采用不同的事件传递方法去处理，比如**delegate**、**notifinotion**、**target-action**、**KVO**等等。\n而在RxSwift中，让程序里的事件传递响应方法做到统一，全部采用Rx的“信号链”方式。举个🌰：\n__Target Action__\n```\nbutton.addTarget(self, action: #selector(buttonEvent), for: .touchUpInside)\n```\n```\n@objc func buttonEvent(){\n    print(\"button Event\")\n}\n```\n用Rx实现\n```\nbutton.rx.tap.subscribe(onNext: { () in\n    print(\"button event\")\n}, onError: nil, onCompleted: nil, onDispo\nsed: nil)\n```\n这样一来，代码逻辑清晰可见。\n当然了，为了MVVM，还是很有学习RxSwift的必要的。\n#### RxSwift地址与安装\n传送门：[GitHub](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FReactiveX%2FRxSwift)\n这里面啥都有，无需多言。\n#### RxSwift 与 RxCocoa\nRxSwift在日常使用中，需要import\n```\nimport RxCocoa\nimport RxSwift\n```\n这个两个库的作用分别是：\n- RxSwift：它只是基于 Swift 语言的 Rx 标准实现接口库，所以 RxSwift 里不包含任何 Cocoa 或者 UI方面的类。\n- RxCocoa：是基于 RxSwift针对于 iOS开发的一个库，它通过 Extension 的方法给原生的比如 UI 控件添加了 Rx 的特性，使得我们更容易订阅和响应这些控件的事件。\n\n既然已经有了这个RxSwift开篇，希望自己坚持下去。虽然不太喜欢写文章，但这也不失为监督自己的一个方法。__笨鸟先飞，知行合一。__\n最后，感谢那些“巨人”，对于RxSwift的学习，完全是站在巨人的肩膀上，感谢他们的文章，指引了我的方向。尤其感谢[RxSwift中文文档](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/)和[航哥swift](http://www.hangge.com/)，他们的文章，对我的帮助很大，感谢。\n","slug":"RxSwift-开门第一篇","published":1,"updated":"2018-10-19T07:16:01.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxrr00012ycwe5n2xe39","content":"<h2 id=\"开篇扯淡：\"><a href=\"#开篇扯淡：\" class=\"headerlink\" title=\"开篇扯淡：\"></a>开篇扯淡：</h2><p>&emsp;&emsp;为什么入RxSwift这个坑？因为我作为一个iOSer，主要语言是swift，日常开发已经很少使用OC。随着产品代码量日益增加，准备从MVC转成MVVM，而MVVM最搭配的就是RxSwift。所以，作为我个人来说，入RxSwift这个坑，还是比较合情合理的。</p>\n<h2 id=\"正经内容：\"><a href=\"#正经内容：\" class=\"headerlink\" title=\"正经内容：\"></a>正经内容：</h2><h3 id=\"ReactiveX是什么\"><a href=\"#ReactiveX是什么\" class=\"headerlink\" title=\"ReactiveX是什么\"></a>ReactiveX是什么</h3><p><a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"noopener\">ReactiveX</a>（简写: Rx）是一个可以帮助我们简化异步编程的框架.<br>它拓展了<a href=\"https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">观察者模式</a>。使你能够自由组合多个异步事件，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。</p>\n<h3 id=\"什么是RxSwift\"><a href=\"#什么是RxSwift\" class=\"headerlink\" title=\"什么是RxSwift\"></a>什么是RxSwift</h3><p><a href=\"https://github.com/ReactiveX/RxSwift\" target=\"_blank\" rel=\"noopener\">RxSwift</a> 是 <a href=\"https://github.com/Reactive-Extensions/Rx.NET\" target=\"_blank\" rel=\"noopener\">Rx</a> 的 <strong>Swift</strong> 版本，它尝试将原有的一些概念移植到 iOS/macOS 平台。</p>\n<h3 id=\"为什么要使用RxSwift\"><a href=\"#为什么要使用RxSwift\" class=\"headerlink\" title=\"为什么要使用RxSwift\"></a>为什么要使用RxSwift</h3><blockquote>\n<p>复合 - Rx 就是复合的代名词<br>复用 - 因为它易复合<br>清晰 - 因为声明都是不可变更的<br>易用 - 因为它抽象的了异步编程，使我们统一了代码风格<br>稳定 - 因为 Rx 是完全通过单元测试的  </p>\n</blockquote>\n<p>当然了，上面都是假大空，具体来说<br>在编写代码时我们经常会需要检测某些值的变化，然后进行相应的处理。比如说按钮的点击事件、textFiled值的变化、tableView中cell的点击事件等等。在日常搬砖中，我们针对不同的情况，需要采用不同的事件传递方法去处理，比如<strong>delegate</strong>、<strong>notifinotion</strong>、<strong>target-action</strong>、<strong>KVO</strong>等等。<br>而在RxSwift中，让程序里的事件传递响应方法做到统一，全部采用Rx的“信号链”方式。举个🌰：<br><strong>Target Action</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.addTarget(self, action: #selector(buttonEvent), for: .touchUpInside)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc func buttonEvent()&#123;</span><br><span class=\"line\">    print(&quot;button Event&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用Rx实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.rx.tap.subscribe(onNext: &#123; () in</span><br><span class=\"line\">    print(&quot;button event&quot;)</span><br><span class=\"line\">&#125;, onError: nil, onCompleted: nil, onDispo</span><br><span class=\"line\">sed: nil)</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，代码逻辑清晰可见。<br>当然了，为了MVVM，还是很有学习RxSwift的必要的。</p>\n<h4 id=\"RxSwift地址与安装\"><a href=\"#RxSwift地址与安装\" class=\"headerlink\" title=\"RxSwift地址与安装\"></a>RxSwift地址与安装</h4><p>传送门：<a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FReactiveX%2FRxSwift\" target=\"_blank\" rel=\"noopener\">GitHub</a><br>这里面啥都有，无需多言。</p>\n<h4 id=\"RxSwift-与-RxCocoa\"><a href=\"#RxSwift-与-RxCocoa\" class=\"headerlink\" title=\"RxSwift 与 RxCocoa\"></a>RxSwift 与 RxCocoa</h4><p>RxSwift在日常使用中，需要import<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br></pre></td></tr></table></figure></p>\n<p>这个两个库的作用分别是：</p>\n<ul>\n<li>RxSwift：它只是基于 Swift 语言的 Rx 标准实现接口库，所以 RxSwift 里不包含任何 Cocoa 或者 UI方面的类。</li>\n<li>RxCocoa：是基于 RxSwift针对于 iOS开发的一个库，它通过 Extension 的方法给原生的比如 UI 控件添加了 Rx 的特性，使得我们更容易订阅和响应这些控件的事件。</li>\n</ul>\n<p>既然已经有了这个RxSwift开篇，希望自己坚持下去。虽然不太喜欢写文章，但这也不失为监督自己的一个方法。<strong>笨鸟先飞，知行合一。</strong><br>最后，感谢那些“巨人”，对于RxSwift的学习，完全是站在巨人的肩膀上，感谢他们的文章，指引了我的方向。尤其感谢<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/\" target=\"_blank\" rel=\"noopener\">RxSwift中文文档</a>和<a href=\"http://www.hangge.com/\" target=\"_blank\" rel=\"noopener\">航哥swift</a>，他们的文章，对我的帮助很大，感谢。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"开篇扯淡：\"><a href=\"#开篇扯淡：\" class=\"headerlink\" title=\"开篇扯淡：\"></a>开篇扯淡：</h2><p>&emsp;&emsp;为什么入RxSwift这个坑？因为我作为一个iOSer，主要语言是swift，日常开发已经很少使用OC。随着产品代码量日益增加，准备从MVC转成MVVM，而MVVM最搭配的就是RxSwift。所以，作为我个人来说，入RxSwift这个坑，还是比较合情合理的。</p>\n<h2 id=\"正经内容：\"><a href=\"#正经内容：\" class=\"headerlink\" title=\"正经内容：\"></a>正经内容：</h2><h3 id=\"ReactiveX是什么\"><a href=\"#ReactiveX是什么\" class=\"headerlink\" title=\"ReactiveX是什么\"></a>ReactiveX是什么</h3><p><a href=\"http://reactivex.io/\" target=\"_blank\" rel=\"noopener\">ReactiveX</a>（简写: Rx）是一个可以帮助我们简化异步编程的框架.<br>它拓展了<a href=\"https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">观察者模式</a>。使你能够自由组合多个异步事件，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。</p>\n<h3 id=\"什么是RxSwift\"><a href=\"#什么是RxSwift\" class=\"headerlink\" title=\"什么是RxSwift\"></a>什么是RxSwift</h3><p><a href=\"https://github.com/ReactiveX/RxSwift\" target=\"_blank\" rel=\"noopener\">RxSwift</a> 是 <a href=\"https://github.com/Reactive-Extensions/Rx.NET\" target=\"_blank\" rel=\"noopener\">Rx</a> 的 <strong>Swift</strong> 版本，它尝试将原有的一些概念移植到 iOS/macOS 平台。</p>\n<h3 id=\"为什么要使用RxSwift\"><a href=\"#为什么要使用RxSwift\" class=\"headerlink\" title=\"为什么要使用RxSwift\"></a>为什么要使用RxSwift</h3><blockquote>\n<p>复合 - Rx 就是复合的代名词<br>复用 - 因为它易复合<br>清晰 - 因为声明都是不可变更的<br>易用 - 因为它抽象的了异步编程，使我们统一了代码风格<br>稳定 - 因为 Rx 是完全通过单元测试的  </p>\n</blockquote>\n<p>当然了，上面都是假大空，具体来说<br>在编写代码时我们经常会需要检测某些值的变化，然后进行相应的处理。比如说按钮的点击事件、textFiled值的变化、tableView中cell的点击事件等等。在日常搬砖中，我们针对不同的情况，需要采用不同的事件传递方法去处理，比如<strong>delegate</strong>、<strong>notifinotion</strong>、<strong>target-action</strong>、<strong>KVO</strong>等等。<br>而在RxSwift中，让程序里的事件传递响应方法做到统一，全部采用Rx的“信号链”方式。举个🌰：<br><strong>Target Action</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.addTarget(self, action: #selector(buttonEvent), for: .touchUpInside)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc func buttonEvent()&#123;</span><br><span class=\"line\">    print(&quot;button Event&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用Rx实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.rx.tap.subscribe(onNext: &#123; () in</span><br><span class=\"line\">    print(&quot;button event&quot;)</span><br><span class=\"line\">&#125;, onError: nil, onCompleted: nil, onDispo</span><br><span class=\"line\">sed: nil)</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，代码逻辑清晰可见。<br>当然了，为了MVVM，还是很有学习RxSwift的必要的。</p>\n<h4 id=\"RxSwift地址与安装\"><a href=\"#RxSwift地址与安装\" class=\"headerlink\" title=\"RxSwift地址与安装\"></a>RxSwift地址与安装</h4><p>传送门：<a href=\"https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FReactiveX%2FRxSwift\" target=\"_blank\" rel=\"noopener\">GitHub</a><br>这里面啥都有，无需多言。</p>\n<h4 id=\"RxSwift-与-RxCocoa\"><a href=\"#RxSwift-与-RxCocoa\" class=\"headerlink\" title=\"RxSwift 与 RxCocoa\"></a>RxSwift 与 RxCocoa</h4><p>RxSwift在日常使用中，需要import<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import RxCocoa</span><br><span class=\"line\">import RxSwift</span><br></pre></td></tr></table></figure></p>\n<p>这个两个库的作用分别是：</p>\n<ul>\n<li>RxSwift：它只是基于 Swift 语言的 Rx 标准实现接口库，所以 RxSwift 里不包含任何 Cocoa 或者 UI方面的类。</li>\n<li>RxCocoa：是基于 RxSwift针对于 iOS开发的一个库，它通过 Extension 的方法给原生的比如 UI 控件添加了 Rx 的特性，使得我们更容易订阅和响应这些控件的事件。</li>\n</ul>\n<p>既然已经有了这个RxSwift开篇，希望自己坚持下去。虽然不太喜欢写文章，但这也不失为监督自己的一个方法。<strong>笨鸟先飞，知行合一。</strong><br>最后，感谢那些“巨人”，对于RxSwift的学习，完全是站在巨人的肩膀上，感谢他们的文章，指引了我的方向。尤其感谢<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/\" target=\"_blank\" rel=\"noopener\">RxSwift中文文档</a>和<a href=\"http://www.hangge.com/\" target=\"_blank\" rel=\"noopener\">航哥swift</a>，他们的文章，对我的帮助很大，感谢。</p>\n"},{"title":"RxSwift 条件和布尔操作符(Conditional and Boolean Operators)","date":"2018-09-27T13:31:24.000Z","_content":"条件和布尔操作会根据条件发射或变换`Observables`，或者对他们做布尔运算。\n#### 1.amb\n当你传入多个`Observables`到`amb`操作符时，它将取其中一个`Observable`：第一个产生事件的那个`Observable`，可以是一个`next`，`error`或者`completed`事件。`amb`将忽略掉其他的`Observables`。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-84522567d0c59097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<Int>()\nlet subject2 = PublishSubject<Int>()\nlet subject3 = PublishSubject<Int>()\n\nsubject1.amb(subject2)\n        .amb(subject3)\n        .subscribe{ print($0.element!) }\n        .disposed(by: disposeBag)\n\nsubject2.onNext(1)\nsubject1.onNext(20)\nsubject2.onNext(2)\nsubject1.onNext(40)\nsubject3.onNext(0)\nsubject2.onNext(3)\nsubject1.onNext(60)\nsubject3.onNext(0)\nsubject3.onNext(0)\n```\n运行结果：\n```\n1\n2\n3\n```\n#### 2. takeWhile\n该方法依次判断`Observable`序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-df28e3c3f9466030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 2, 3, 4, 3, 2, 1)\n        .takeWhile { $0 < 4 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果：\n```\n1\n2\n3\n```\n#### 3. takeUntil\n`takeUntil`操作符将镜像源`Observable`，它同时观测第二个`Observable`。一旦第二个`Observable`发出一个元素或者产生一个终止事件，那个镜像的`Observable`将立即终止。\n\n![takeUntil.png](https://upload-images.jianshu.io/upload_images/2855070-0445e18465f29f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<String>()\nlet subject2 = PublishSubject<String>()\n\nsubject1.takeUntil(subject2)\n        .subscribe { print($0) }\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"A\")\nsubject1.onNext(\"B\")\nsubject2.onNext(\"我可以让它中止\")\nsubject1.onNext(\"C\")\n```\n结果如下：\n```\nnext(A)\nnext(B)\ncompleted\n```\n#### 4. skipUntil\n- 同上面的`takeUntil`一样，`skipUntil`除了订阅源`Observable`外，通过`skipUntil`方法我们还可以监视另外一个`Observable`， 即`notifier` 。\n- 与`takeUntil`相反的是。源`Observable`序列事件默认会一直跳过，直到`notifier`发出值或 complete 通知\n\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-5063471ccc8c9bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject = PublishSubject<String>()\nlet notifier = PublishSubject<String>()\n\nsubject.skipUntil(notifier)\n        .subscribe (onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nnotifier.onNext(\"接收消息\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\nsubject.onNext(\"E\")\nnotifier.onNext(\"接收消息\")\nsubject.onNext(\"F\")\n```\n结果如下：\n```\nC\nD\nE\nF\n```\n#### 5. skipWhile\n`skipWhile`操作符可以让你忽略源`Observable`中头几个元素，直到元素的判定为否。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-cf1e93804e5b79e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 3, 6, 4, 7, 2)\n        .skipWhile{ $0 < 5 }\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n6\n4\n7\n2\n```\n","source":"_posts/RxSwift-条件和布尔操作符-Conditional-and-Boolean-Operators.md","raw":"---\ntitle: RxSwift 条件和布尔操作符(Conditional and Boolean Operators)\ndate: 2018-09-27 21:31:24\ntags: RxSwift\n---\n条件和布尔操作会根据条件发射或变换`Observables`，或者对他们做布尔运算。\n#### 1.amb\n当你传入多个`Observables`到`amb`操作符时，它将取其中一个`Observable`：第一个产生事件的那个`Observable`，可以是一个`next`，`error`或者`completed`事件。`amb`将忽略掉其他的`Observables`。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-84522567d0c59097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<Int>()\nlet subject2 = PublishSubject<Int>()\nlet subject3 = PublishSubject<Int>()\n\nsubject1.amb(subject2)\n        .amb(subject3)\n        .subscribe{ print($0.element!) }\n        .disposed(by: disposeBag)\n\nsubject2.onNext(1)\nsubject1.onNext(20)\nsubject2.onNext(2)\nsubject1.onNext(40)\nsubject3.onNext(0)\nsubject2.onNext(3)\nsubject1.onNext(60)\nsubject3.onNext(0)\nsubject3.onNext(0)\n```\n运行结果：\n```\n1\n2\n3\n```\n#### 2. takeWhile\n该方法依次判断`Observable`序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-df28e3c3f9466030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 2, 3, 4, 3, 2, 1)\n        .takeWhile { $0 < 4 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果：\n```\n1\n2\n3\n```\n#### 3. takeUntil\n`takeUntil`操作符将镜像源`Observable`，它同时观测第二个`Observable`。一旦第二个`Observable`发出一个元素或者产生一个终止事件，那个镜像的`Observable`将立即终止。\n\n![takeUntil.png](https://upload-images.jianshu.io/upload_images/2855070-0445e18465f29f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<String>()\nlet subject2 = PublishSubject<String>()\n\nsubject1.takeUntil(subject2)\n        .subscribe { print($0) }\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"A\")\nsubject1.onNext(\"B\")\nsubject2.onNext(\"我可以让它中止\")\nsubject1.onNext(\"C\")\n```\n结果如下：\n```\nnext(A)\nnext(B)\ncompleted\n```\n#### 4. skipUntil\n- 同上面的`takeUntil`一样，`skipUntil`除了订阅源`Observable`外，通过`skipUntil`方法我们还可以监视另外一个`Observable`， 即`notifier` 。\n- 与`takeUntil`相反的是。源`Observable`序列事件默认会一直跳过，直到`notifier`发出值或 complete 通知\n\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-5063471ccc8c9bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject = PublishSubject<String>()\nlet notifier = PublishSubject<String>()\n\nsubject.skipUntil(notifier)\n        .subscribe (onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nnotifier.onNext(\"接收消息\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\nsubject.onNext(\"E\")\nnotifier.onNext(\"接收消息\")\nsubject.onNext(\"F\")\n```\n结果如下：\n```\nC\nD\nE\nF\n```\n#### 5. skipWhile\n`skipWhile`操作符可以让你忽略源`Observable`中头几个元素，直到元素的判定为否。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-cf1e93804e5b79e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(1, 3, 6, 4, 7, 2)\n        .skipWhile{ $0 < 5 }\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n6\n4\n7\n2\n```\n","slug":"RxSwift-条件和布尔操作符-Conditional-and-Boolean-Operators","published":1,"updated":"2018-10-19T07:16:01.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxrw00032ycw5tbvc747","content":"<p>条件和布尔操作会根据条件发射或变换<code>Observables</code>，或者对他们做布尔运算。</p>\n<h4 id=\"1-amb\"><a href=\"#1-amb\" class=\"headerlink\" title=\"1.amb\"></a>1.amb</h4><p>当你传入多个<code>Observables</code>到<code>amb</code>操作符时，它将取其中一个<code>Observable</code>：第一个产生事件的那个<code>Observable</code>，可以是一个<code>next</code>，<code>error</code>或者<code>completed</code>事件。<code>amb</code>将忽略掉其他的<code>Observables</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-84522567d0c59097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject3 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.amb(subject2)</span><br><span class=\"line\">        .amb(subject3)</span><br><span class=\"line\">        .subscribe&#123; print($0.element!) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject2.onNext(1)</span><br><span class=\"line\">subject1.onNext(20)</span><br><span class=\"line\">subject2.onNext(2)</span><br><span class=\"line\">subject1.onNext(40)</span><br><span class=\"line\">subject3.onNext(0)</span><br><span class=\"line\">subject2.onNext(3)</span><br><span class=\"line\">subject1.onNext(60)</span><br><span class=\"line\">subject3.onNext(0)</span><br><span class=\"line\">subject3.onNext(0)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-takeWhile\"><a href=\"#2-takeWhile\" class=\"headerlink\" title=\"2. takeWhile\"></a>2. takeWhile</h4><p>该方法依次判断<code>Observable</code>序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-df28e3c3f9466030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 3, 2, 1)</span><br><span class=\"line\">        .takeWhile &#123; $0 &lt; 4 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-takeUntil\"><a href=\"#3-takeUntil\" class=\"headerlink\" title=\"3. takeUntil\"></a>3. takeUntil</h4><p><code>takeUntil</code>操作符将镜像源<code>Observable</code>，它同时观测第二个<code>Observable</code>。一旦第二个<code>Observable</code>发出一个元素或者产生一个终止事件，那个镜像的<code>Observable</code>将立即终止。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-0445e18465f29f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"takeUntil.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.takeUntil(subject2)</span><br><span class=\"line\">        .subscribe &#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;我可以让它中止&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(A)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-skipUntil\"><a href=\"#4-skipUntil\" class=\"headerlink\" title=\"4. skipUntil\"></a>4. skipUntil</h4><ul>\n<li>同上面的<code>takeUntil</code>一样，<code>skipUntil</code>除了订阅源<code>Observable</code>外，通过<code>skipUntil</code>方法我们还可以监视另外一个<code>Observable</code>， 即<code>notifier</code> 。</li>\n<li>与<code>takeUntil</code>相反的是。源<code>Observable</code>序列事件默认会一直跳过，直到<code>notifier</code>发出值或 complete 通知</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-5063471ccc8c9bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let notifier = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.skipUntil(notifier)</span><br><span class=\"line\">        .subscribe (onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;接收消息&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">subject.onNext(&quot;E&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;接收消息&quot;)</span><br><span class=\"line\">subject.onNext(&quot;F&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">E</span><br><span class=\"line\">F</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-skipWhile\"><a href=\"#5-skipWhile\" class=\"headerlink\" title=\"5. skipWhile\"></a>5. skipWhile</h4><p><code>skipWhile</code>操作符可以让你忽略源<code>Observable</code>中头几个元素，直到元素的判定为否。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-cf1e93804e5b79e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(1, 3, 6, 4, 7, 2)</span><br><span class=\"line\">        .skipWhile&#123; $0 &lt; 5 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">4</span><br><span class=\"line\">7</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>条件和布尔操作会根据条件发射或变换<code>Observables</code>，或者对他们做布尔运算。</p>\n<h4 id=\"1-amb\"><a href=\"#1-amb\" class=\"headerlink\" title=\"1.amb\"></a>1.amb</h4><p>当你传入多个<code>Observables</code>到<code>amb</code>操作符时，它将取其中一个<code>Observable</code>：第一个产生事件的那个<code>Observable</code>，可以是一个<code>next</code>，<code>error</code>或者<code>completed</code>事件。<code>amb</code>将忽略掉其他的<code>Observables</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-84522567d0c59097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject3 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.amb(subject2)</span><br><span class=\"line\">        .amb(subject3)</span><br><span class=\"line\">        .subscribe&#123; print($0.element!) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject2.onNext(1)</span><br><span class=\"line\">subject1.onNext(20)</span><br><span class=\"line\">subject2.onNext(2)</span><br><span class=\"line\">subject1.onNext(40)</span><br><span class=\"line\">subject3.onNext(0)</span><br><span class=\"line\">subject2.onNext(3)</span><br><span class=\"line\">subject1.onNext(60)</span><br><span class=\"line\">subject3.onNext(0)</span><br><span class=\"line\">subject3.onNext(0)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-takeWhile\"><a href=\"#2-takeWhile\" class=\"headerlink\" title=\"2. takeWhile\"></a>2. takeWhile</h4><p>该方法依次判断<code>Observable</code>序列的每一个值是否满足给定的条件。 当第一个不满足条件的值出现时，它便自动完成。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-df28e3c3f9466030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 3, 2, 1)</span><br><span class=\"line\">        .takeWhile &#123; $0 &lt; 4 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-takeUntil\"><a href=\"#3-takeUntil\" class=\"headerlink\" title=\"3. takeUntil\"></a>3. takeUntil</h4><p><code>takeUntil</code>操作符将镜像源<code>Observable</code>，它同时观测第二个<code>Observable</code>。一旦第二个<code>Observable</code>发出一个元素或者产生一个终止事件，那个镜像的<code>Observable</code>将立即终止。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-0445e18465f29f93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"takeUntil.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.takeUntil(subject2)</span><br><span class=\"line\">        .subscribe &#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;我可以让它中止&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(A)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-skipUntil\"><a href=\"#4-skipUntil\" class=\"headerlink\" title=\"4. skipUntil\"></a>4. skipUntil</h4><ul>\n<li>同上面的<code>takeUntil</code>一样，<code>skipUntil</code>除了订阅源<code>Observable</code>外，通过<code>skipUntil</code>方法我们还可以监视另外一个<code>Observable</code>， 即<code>notifier</code> 。</li>\n<li>与<code>takeUntil</code>相反的是。源<code>Observable</code>序列事件默认会一直跳过，直到<code>notifier</code>发出值或 complete 通知</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-5063471ccc8c9bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let notifier = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.skipUntil(notifier)</span><br><span class=\"line\">        .subscribe (onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;接收消息&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">subject.onNext(&quot;E&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;接收消息&quot;)</span><br><span class=\"line\">subject.onNext(&quot;F&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C</span><br><span class=\"line\">D</span><br><span class=\"line\">E</span><br><span class=\"line\">F</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-skipWhile\"><a href=\"#5-skipWhile\" class=\"headerlink\" title=\"5. skipWhile\"></a>5. skipWhile</h4><p><code>skipWhile</code>操作符可以让你忽略源<code>Observable</code>中头几个元素，直到元素的判定为否。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-cf1e93804e5b79e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(1, 3, 6, 4, 7, 2)</span><br><span class=\"line\">        .skipWhile&#123; $0 &lt; 5 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br><span class=\"line\">4</span><br><span class=\"line\">7</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n"},{"title":"swift 内联序列函数sequence","date":"2018-09-13T12:24:08.000Z","_content":"在看RxSwift文章的时候，有人说到了Sequence。恕小弟才疏学浅，在日常搬砖中没有使用到它，所以在此记录一下。 \nsequence是在swift3就出现的。使用它们可以返回一个无限序列。我们可以给他们一个初始值，或者初始状态，然后他们便会以懒加载的方式应用到一个闭包。方法如下：\n```\n1.public func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)>\n2.public func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State>\n```\n### 方法1：\n```\npublic func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)>\n```\nfirst:从序列返回的第一个元素\nnext:一个闭包，它接受前一个sequence元素并返回下一个元素\n举个🌰，我们想打印从1-100范围内所有的偶数\n```\nfor i in sequence(first: 1, next: { $0 * 2}){\n    if i > 100{\n        break\n    }\n    print(i)\n}\n```\n或者，我们也可以把处理逻辑，状态判断放在next闭包里面，🌰：\n```\nfor _ in sequence(first: 1, next: {\n    print($0)\n    let value = $0 * 2\n    return value <= 100 ? value : nil\n}){}\n```\n在文档中还有一个🌰，从某一个树节点一直向上遍历到根节点\n```\nfor node in sequence(first: leaf, next: { $0.parent }) {\n    // node is leaf, then leaf.parent, then leaf.parent.parent, etc.\n}\n```\n### 方法2：\n```\npublic func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State>\n```\n这个方法是设置个初始状态（可变的），后面将其传 入next 闭包改变状态，并获取下一个序列，依次类推。举个🌰：我们制定X轴Y轴最大值，列出内部所有的整点：\n```\n// 实现方法\nfunc cartesianSequence(xCount: Int, yCount: Int) -> UnfoldSequence<PointType, Int>{\n    // assert断言\n    assert(xCount > 0 && yCount > 0, \"必须使用正整数创建序列\")\n    return sequence(state: 0, next: { (index: inout Int) -> PointType? in\n    guard index < xCount * yCount else {\n        return nil\n        }\n    defer{\n        index += 1\n    }\n    return (x: index % xCount, y :index / xCount)\n    })\n}\n// 调用方法\nfor point in cartesianSequence(xCount: 3, yCount: 3){\n    print(\"x:\\(point.x), y:\\(point.y)\")\n    /*\n    x:0, y:0 x:1, y:0 x:2, y:0\n    x:0, y:1 x:1, y:1 x:2, y:1 \n    x:0, y:2 x:1, y:2 x:2, y:2\n    */\n}\n```\n","source":"_posts/swift-Sequence.md","raw":"---\ntitle: swift 内联序列函数sequence\ndate: 2018-09-13 20:24:08\ntags: swift 冷门方法\n---\n在看RxSwift文章的时候，有人说到了Sequence。恕小弟才疏学浅，在日常搬砖中没有使用到它，所以在此记录一下。 \nsequence是在swift3就出现的。使用它们可以返回一个无限序列。我们可以给他们一个初始值，或者初始状态，然后他们便会以懒加载的方式应用到一个闭包。方法如下：\n```\n1.public func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)>\n2.public func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State>\n```\n### 方法1：\n```\npublic func sequence<T>(first: T, next: @escaping (T) -> T?) -> UnfoldSequence<T, (T?, Bool)>\n```\nfirst:从序列返回的第一个元素\nnext:一个闭包，它接受前一个sequence元素并返回下一个元素\n举个🌰，我们想打印从1-100范围内所有的偶数\n```\nfor i in sequence(first: 1, next: { $0 * 2}){\n    if i > 100{\n        break\n    }\n    print(i)\n}\n```\n或者，我们也可以把处理逻辑，状态判断放在next闭包里面，🌰：\n```\nfor _ in sequence(first: 1, next: {\n    print($0)\n    let value = $0 * 2\n    return value <= 100 ? value : nil\n}){}\n```\n在文档中还有一个🌰，从某一个树节点一直向上遍历到根节点\n```\nfor node in sequence(first: leaf, next: { $0.parent }) {\n    // node is leaf, then leaf.parent, then leaf.parent.parent, etc.\n}\n```\n### 方法2：\n```\npublic func sequence<T, State>(state: State, next: @escaping (inout State) -> T?) -> UnfoldSequence<T, State>\n```\n这个方法是设置个初始状态（可变的），后面将其传 入next 闭包改变状态，并获取下一个序列，依次类推。举个🌰：我们制定X轴Y轴最大值，列出内部所有的整点：\n```\n// 实现方法\nfunc cartesianSequence(xCount: Int, yCount: Int) -> UnfoldSequence<PointType, Int>{\n    // assert断言\n    assert(xCount > 0 && yCount > 0, \"必须使用正整数创建序列\")\n    return sequence(state: 0, next: { (index: inout Int) -> PointType? in\n    guard index < xCount * yCount else {\n        return nil\n        }\n    defer{\n        index += 1\n    }\n    return (x: index % xCount, y :index / xCount)\n    })\n}\n// 调用方法\nfor point in cartesianSequence(xCount: 3, yCount: 3){\n    print(\"x:\\(point.x), y:\\(point.y)\")\n    /*\n    x:0, y:0 x:1, y:0 x:2, y:0\n    x:0, y:1 x:1, y:1 x:2, y:1 \n    x:0, y:2 x:1, y:2 x:2, y:2\n    */\n}\n```\n","slug":"swift-Sequence","published":1,"updated":"2018-10-19T07:16:01.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxrx00042ycwlw02mm8p","content":"<p>在看RxSwift文章的时候，有人说到了Sequence。恕小弟才疏学浅，在日常搬砖中没有使用到它，所以在此记录一下。<br>sequence是在swift3就出现的。使用它们可以返回一个无限序列。我们可以给他们一个初始值，或者初始状态，然后他们便会以懒加载的方式应用到一个闭包。方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.public func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt;</span><br><span class=\"line\">2.public func sequence&lt;T, State&gt;(state: State, next: @escaping (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法1：\"><a href=\"#方法1：\" class=\"headerlink\" title=\"方法1：\"></a>方法1：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt;</span><br></pre></td></tr></table></figure>\n<p>first:从序列返回的第一个元素<br>next:一个闭包，它接受前一个sequence元素并返回下一个元素<br>举个🌰，我们想打印从1-100范围内所有的偶数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in sequence(first: 1, next: &#123; $0 * 2&#125;)&#123;</span><br><span class=\"line\">    if i &gt; 100&#123;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者，我们也可以把处理逻辑，状态判断放在next闭包里面，🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for _ in sequence(first: 1, next: &#123;</span><br><span class=\"line\">    print($0)</span><br><span class=\"line\">    let value = $0 * 2</span><br><span class=\"line\">    return value &lt;= 100 ? value : nil</span><br><span class=\"line\">&#125;)&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在文档中还有一个🌰，从某一个树节点一直向上遍历到根节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for node in sequence(first: leaf, next: &#123; $0.parent &#125;) &#123;</span><br><span class=\"line\">    // node is leaf, then leaf.parent, then leaf.parent.parent, etc.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法2：\"><a href=\"#方法2：\" class=\"headerlink\" title=\"方法2：\"></a>方法2：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public func sequence&lt;T, State&gt;(state: State, next: @escaping (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt;</span><br></pre></td></tr></table></figure>\n<p>这个方法是设置个初始状态（可变的），后面将其传 入next 闭包改变状态，并获取下一个序列，依次类推。举个🌰：我们制定X轴Y轴最大值，列出内部所有的整点：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 实现方法</span><br><span class=\"line\">func cartesianSequence(xCount: Int, yCount: Int) -&gt; UnfoldSequence&lt;PointType, Int&gt;&#123;</span><br><span class=\"line\">    // assert断言</span><br><span class=\"line\">    assert(xCount &gt; 0 &amp;&amp; yCount &gt; 0, &quot;必须使用正整数创建序列&quot;)</span><br><span class=\"line\">    return sequence(state: 0, next: &#123; (index: inout Int) -&gt; PointType? in</span><br><span class=\"line\">    guard index &lt; xCount * yCount else &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    defer&#123;</span><br><span class=\"line\">        index += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (x: index % xCount, y :index / xCount)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 调用方法</span><br><span class=\"line\">for point in cartesianSequence(xCount: 3, yCount: 3)&#123;</span><br><span class=\"line\">    print(&quot;x:\\(point.x), y:\\(point.y)&quot;)</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    x:0, y:0 x:1, y:0 x:2, y:0</span><br><span class=\"line\">    x:0, y:1 x:1, y:1 x:2, y:1 </span><br><span class=\"line\">    x:0, y:2 x:1, y:2 x:2, y:2</span><br><span class=\"line\">    */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在看RxSwift文章的时候，有人说到了Sequence。恕小弟才疏学浅，在日常搬砖中没有使用到它，所以在此记录一下。<br>sequence是在swift3就出现的。使用它们可以返回一个无限序列。我们可以给他们一个初始值，或者初始状态，然后他们便会以懒加载的方式应用到一个闭包。方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.public func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt;</span><br><span class=\"line\">2.public func sequence&lt;T, State&gt;(state: State, next: @escaping (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法1：\"><a href=\"#方法1：\" class=\"headerlink\" title=\"方法1：\"></a>方法1：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public func sequence&lt;T&gt;(first: T, next: @escaping (T) -&gt; T?) -&gt; UnfoldSequence&lt;T, (T?, Bool)&gt;</span><br></pre></td></tr></table></figure>\n<p>first:从序列返回的第一个元素<br>next:一个闭包，它接受前一个sequence元素并返回下一个元素<br>举个🌰，我们想打印从1-100范围内所有的偶数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in sequence(first: 1, next: &#123; $0 * 2&#125;)&#123;</span><br><span class=\"line\">    if i &gt; 100&#123;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>或者，我们也可以把处理逻辑，状态判断放在next闭包里面，🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for _ in sequence(first: 1, next: &#123;</span><br><span class=\"line\">    print($0)</span><br><span class=\"line\">    let value = $0 * 2</span><br><span class=\"line\">    return value &lt;= 100 ? value : nil</span><br><span class=\"line\">&#125;)&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在文档中还有一个🌰，从某一个树节点一直向上遍历到根节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for node in sequence(first: leaf, next: &#123; $0.parent &#125;) &#123;</span><br><span class=\"line\">    // node is leaf, then leaf.parent, then leaf.parent.parent, etc.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"方法2：\"><a href=\"#方法2：\" class=\"headerlink\" title=\"方法2：\"></a>方法2：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public func sequence&lt;T, State&gt;(state: State, next: @escaping (inout State) -&gt; T?) -&gt; UnfoldSequence&lt;T, State&gt;</span><br></pre></td></tr></table></figure>\n<p>这个方法是设置个初始状态（可变的），后面将其传 入next 闭包改变状态，并获取下一个序列，依次类推。举个🌰：我们制定X轴Y轴最大值，列出内部所有的整点：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 实现方法</span><br><span class=\"line\">func cartesianSequence(xCount: Int, yCount: Int) -&gt; UnfoldSequence&lt;PointType, Int&gt;&#123;</span><br><span class=\"line\">    // assert断言</span><br><span class=\"line\">    assert(xCount &gt; 0 &amp;&amp; yCount &gt; 0, &quot;必须使用正整数创建序列&quot;)</span><br><span class=\"line\">    return sequence(state: 0, next: &#123; (index: inout Int) -&gt; PointType? in</span><br><span class=\"line\">    guard index &lt; xCount * yCount else &#123;</span><br><span class=\"line\">        return nil</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    defer&#123;</span><br><span class=\"line\">        index += 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (x: index % xCount, y :index / xCount)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 调用方法</span><br><span class=\"line\">for point in cartesianSequence(xCount: 3, yCount: 3)&#123;</span><br><span class=\"line\">    print(&quot;x:\\(point.x), y:\\(point.y)&quot;)</span><br><span class=\"line\">    /*</span><br><span class=\"line\">    x:0, y:0 x:1, y:0 x:2, y:0</span><br><span class=\"line\">    x:0, y:1 x:1, y:1 x:2, y:1 </span><br><span class=\"line\">    x:0, y:2 x:1, y:2 x:2, y:2</span><br><span class=\"line\">    */</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"RxSwift 核心","date":"2018-09-19T12:49:45.000Z","_content":"在这篇中，简单介绍一下RxSwift的核心内容，首先献祭上一张图：\n![RxSwiftCore.png](https://upload-images.jianshu.io/upload_images/2855070-90edfb06fc5c1b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- Observable:产生事件\n- Observer: 响应事件\n- Operator:创建变化组合事件\n- Disposable:管理绑定（订阅）的生命周期\n- Schedulers:线程队列调配\n## Observable 可被监听的序列\nObservable实质上就是一个Sequence。序列分为有穷序列和无穷序列，主要就是用来形成一条数据流。比如说：我们通过nickname和password向服务器请求用户信息，它就是一个有穷数列，当数据传输完毕，这个序列就闭合了。当我们去监测某个按钮的点击，我们不知道会点击多少次，这就是无穷序列。而我们所有的操作产生的数据都会通过Observable传输。\nObservable<T> 这个类就是Rx 框架的基础，我们称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable<T> 对象会随着时间推移不定期地发出 event(element : T) 。\n举个🌰：\n```\nlet observable = Observable.of(\"A\", \"B\", \"C\")\nobservable.subscribe(onNext: { element in\nprint(element)\n}, onError: { error in\nprint(error)\n}, onCompleted: {\nprint(\"completed\")\n}, onDisposed: {\nprint(\"disposed\")\n})\n```\n这里subscribe后面的onNext,onError, onCompleted 分别响应我们创建 json 时，构建函数里面的onNext,onError, onCompleted 事件。我们称这些事件为 Event。\nEvent的定义如下：\n```\npublic enum Event<Element> {\n/// Next element is produced.\ncase next(Element)\n/// Sequence terminated with an error.\ncase error(Swift.Error)\n/// Sequence completed successfully.\ncase completed\n}\n```\n可以看出Event就是一个枚举，也就是说一个 Observable 是可以发出 3 种不同类型的 Event 事件。\n- next:序列产生了一个新的元素\n- error:创建序列时产生了一个错误，导致序列终止\n- completed:序列的所有元素都已经成功产生，整个序列已经完成\n我们通过这些Event实现业务逻辑。\n##  Observer 观察者\n观察者（Observer）的作用就是监听事件，然后对这个事件做出响应，或者说任何响应事件的行为都是观察者。比如：\n- 当前视频播放到30分钟时，弹出视频小剧场(广告)，后者就是观察者。\n- 当前温度高于30度，打开空调降温，后者就是观察者。\n- 当你点击视频拍摄时，系统弹出弹框问你是否同意使用摄像头，后者就是观察者。\n- ······\n举个🌰：\n```\ntap.subscribe(onNext: { [weak self] in\nself?.showAlert()\n}, onError: { error in\nprint(\"发生错误： \\(error.localizedDescription)\")\n}, onCompleted: {\nprint(\"任务完成\")\n})\n```\n在这里，弹出提示框就是观察者。\n创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述，事件发生时，需要如何做出响应。而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的。此外，我们还有AnyObserver、Binder方式创建观察者。\n## Operator  操作符\n操作符可以帮助大家创建新的序列，或者变化组合原有的序列，从而生成一个新的序列。可以对比一下Swift中的高阶函数。具体使用方法暂不做介绍，只举个🌰：\n```\nlet obserable = Observable<Int>.of(1,2,3,4,5,6,7,8,9,10)\nobserable.filter{ $0 > 5}\n.subscribe(onNext: { print($0) })\n//6 7 8 9 10\n```\n\n## Disposable  可被清除的资源\n一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。激活之后要一直等到它发出了.error或者 .completed的 event 后，它才被终结。而如果我们想提前释放这些资源或者取消订阅的话，可以对返回的可被清除的资源（Disposable） 调用 dispose 方法：\n```\nvar disposable: Disposable?\n\noverride func viewWillAppear(_ animated: Bool) {\nsuper.viewWillAppear(animated)\n\nself.disposable = textField.rx.text.orEmpty\n.subscribe(onNext: { text in print(text) })\n}\n\noverride func viewWillDisappear(_ animated: Bool) {\nsuper.viewWillDisappear(animated)\n\nself.disposable?.dispose()\n}\n```\n当然了，这个方法并不建议。因为Swift是使用ARC管理内存，所有推荐使用清除包（DisposeBag） 来实现这种订阅管理机制。我们可以把一个 DisposeBag对象看成一个垃圾袋，把用过的订阅行为都放进去，这个DisposeBag 就会在自己快要dealloc 的时候，对它里面的所有订阅行为都调用 dispose()方法\n```\nlet disposeBag = DisposeBag()\n\n//第1个Observable，及其订阅\nlet observable1 = Observable.of(\"A\", \"B\", \"C\")\nobservable1.subscribe { event in\nprint(event)\n}.disposed(by: disposeBag)\n\n//第2个Observable，及其订阅\nlet observable2 = Observable.of(1, 2, 3)\nobservable2.subscribe { event in\nprint(event)\n}.disposed(by: disposeBag)\n\n```\n此外，还有一种takeUntil，这里就不做过多描述了。\n## Schedulers 调度器\nSchedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。\n在Swift中，我们写一个GCD这么写：\n```\n// 后台取得数据，主线程处理结果\nDispatchQueue.global(qos: .userInitiated).async {\nlet data = try? Data(contentsOf: url)\nDispatchQueue.main.async {\nself.data = data\n}\n}\n```\n如果用RxSwift去实现，就这么写:\n```\nlet rxData: Observable<Data> = ...\n\nrxData\n.subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))\n.observeOn(MainScheduler.instance)\n.subscribe(onNext: { [weak self] data in\nself?.data = data\n})\n.disposed(by: disposeBag)\n```\n在这里，我们用subscribeOn来决定数据序列的构建函数在哪个 Scheduler 上运行，用observeOn来决定在哪个 Scheduler 监听这个数据序列。比如说：在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn切到后台去发送请求并解析数据，最后用 observeOn切换到主线程更新页面。此外，我们来应该了解：\n- MainScheduler：代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。\n- SerialDispatchQueueScheduler：抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。\n- ConcurrentDispatchQueueScheduler：抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。\n- OperationQueueScheduler：抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。\n\n","source":"_posts/RxSwift-核心.md","raw":"---\ntitle: RxSwift 核心\ndate: 2018-09-19 20:49:45\ntags: RxSwift\n---\n在这篇中，简单介绍一下RxSwift的核心内容，首先献祭上一张图：\n![RxSwiftCore.png](https://upload-images.jianshu.io/upload_images/2855070-90edfb06fc5c1b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- Observable:产生事件\n- Observer: 响应事件\n- Operator:创建变化组合事件\n- Disposable:管理绑定（订阅）的生命周期\n- Schedulers:线程队列调配\n## Observable 可被监听的序列\nObservable实质上就是一个Sequence。序列分为有穷序列和无穷序列，主要就是用来形成一条数据流。比如说：我们通过nickname和password向服务器请求用户信息，它就是一个有穷数列，当数据传输完毕，这个序列就闭合了。当我们去监测某个按钮的点击，我们不知道会点击多少次，这就是无穷序列。而我们所有的操作产生的数据都会通过Observable传输。\nObservable<T> 这个类就是Rx 框架的基础，我们称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable<T> 对象会随着时间推移不定期地发出 event(element : T) 。\n举个🌰：\n```\nlet observable = Observable.of(\"A\", \"B\", \"C\")\nobservable.subscribe(onNext: { element in\nprint(element)\n}, onError: { error in\nprint(error)\n}, onCompleted: {\nprint(\"completed\")\n}, onDisposed: {\nprint(\"disposed\")\n})\n```\n这里subscribe后面的onNext,onError, onCompleted 分别响应我们创建 json 时，构建函数里面的onNext,onError, onCompleted 事件。我们称这些事件为 Event。\nEvent的定义如下：\n```\npublic enum Event<Element> {\n/// Next element is produced.\ncase next(Element)\n/// Sequence terminated with an error.\ncase error(Swift.Error)\n/// Sequence completed successfully.\ncase completed\n}\n```\n可以看出Event就是一个枚举，也就是说一个 Observable 是可以发出 3 种不同类型的 Event 事件。\n- next:序列产生了一个新的元素\n- error:创建序列时产生了一个错误，导致序列终止\n- completed:序列的所有元素都已经成功产生，整个序列已经完成\n我们通过这些Event实现业务逻辑。\n##  Observer 观察者\n观察者（Observer）的作用就是监听事件，然后对这个事件做出响应，或者说任何响应事件的行为都是观察者。比如：\n- 当前视频播放到30分钟时，弹出视频小剧场(广告)，后者就是观察者。\n- 当前温度高于30度，打开空调降温，后者就是观察者。\n- 当你点击视频拍摄时，系统弹出弹框问你是否同意使用摄像头，后者就是观察者。\n- ······\n举个🌰：\n```\ntap.subscribe(onNext: { [weak self] in\nself?.showAlert()\n}, onError: { error in\nprint(\"发生错误： \\(error.localizedDescription)\")\n}, onCompleted: {\nprint(\"任务完成\")\n})\n```\n在这里，弹出提示框就是观察者。\n创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述，事件发生时，需要如何做出响应。而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的。此外，我们还有AnyObserver、Binder方式创建观察者。\n## Operator  操作符\n操作符可以帮助大家创建新的序列，或者变化组合原有的序列，从而生成一个新的序列。可以对比一下Swift中的高阶函数。具体使用方法暂不做介绍，只举个🌰：\n```\nlet obserable = Observable<Int>.of(1,2,3,4,5,6,7,8,9,10)\nobserable.filter{ $0 > 5}\n.subscribe(onNext: { print($0) })\n//6 7 8 9 10\n```\n\n## Disposable  可被清除的资源\n一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。激活之后要一直等到它发出了.error或者 .completed的 event 后，它才被终结。而如果我们想提前释放这些资源或者取消订阅的话，可以对返回的可被清除的资源（Disposable） 调用 dispose 方法：\n```\nvar disposable: Disposable?\n\noverride func viewWillAppear(_ animated: Bool) {\nsuper.viewWillAppear(animated)\n\nself.disposable = textField.rx.text.orEmpty\n.subscribe(onNext: { text in print(text) })\n}\n\noverride func viewWillDisappear(_ animated: Bool) {\nsuper.viewWillDisappear(animated)\n\nself.disposable?.dispose()\n}\n```\n当然了，这个方法并不建议。因为Swift是使用ARC管理内存，所有推荐使用清除包（DisposeBag） 来实现这种订阅管理机制。我们可以把一个 DisposeBag对象看成一个垃圾袋，把用过的订阅行为都放进去，这个DisposeBag 就会在自己快要dealloc 的时候，对它里面的所有订阅行为都调用 dispose()方法\n```\nlet disposeBag = DisposeBag()\n\n//第1个Observable，及其订阅\nlet observable1 = Observable.of(\"A\", \"B\", \"C\")\nobservable1.subscribe { event in\nprint(event)\n}.disposed(by: disposeBag)\n\n//第2个Observable，及其订阅\nlet observable2 = Observable.of(1, 2, 3)\nobservable2.subscribe { event in\nprint(event)\n}.disposed(by: disposeBag)\n\n```\n此外，还有一种takeUntil，这里就不做过多描述了。\n## Schedulers 调度器\nSchedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。\n在Swift中，我们写一个GCD这么写：\n```\n// 后台取得数据，主线程处理结果\nDispatchQueue.global(qos: .userInitiated).async {\nlet data = try? Data(contentsOf: url)\nDispatchQueue.main.async {\nself.data = data\n}\n}\n```\n如果用RxSwift去实现，就这么写:\n```\nlet rxData: Observable<Data> = ...\n\nrxData\n.subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))\n.observeOn(MainScheduler.instance)\n.subscribe(onNext: { [weak self] data in\nself?.data = data\n})\n.disposed(by: disposeBag)\n```\n在这里，我们用subscribeOn来决定数据序列的构建函数在哪个 Scheduler 上运行，用observeOn来决定在哪个 Scheduler 监听这个数据序列。比如说：在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn切到后台去发送请求并解析数据，最后用 observeOn切换到主线程更新页面。此外，我们来应该了解：\n- MainScheduler：代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。\n- SerialDispatchQueueScheduler：抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。\n- ConcurrentDispatchQueueScheduler：抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。\n- OperationQueueScheduler：抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。\n\n","slug":"RxSwift-核心","published":1,"updated":"2018-10-19T07:16:01.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxrz00052ycwkkey1w33","content":"<p>在这篇中，简单介绍一下RxSwift的核心内容，首先献祭上一张图：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-90edfb06fc5c1b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RxSwiftCore.png\"></p>\n<ul>\n<li>Observable:产生事件</li>\n<li>Observer: 响应事件</li>\n<li>Operator:创建变化组合事件</li>\n<li>Disposable:管理绑定（订阅）的生命周期</li>\n<li>Schedulers:线程队列调配<h2 id=\"Observable-可被监听的序列\"><a href=\"#Observable-可被监听的序列\" class=\"headerlink\" title=\"Observable 可被监听的序列\"></a>Observable 可被监听的序列</h2>Observable实质上就是一个Sequence。序列分为有穷序列和无穷序列，主要就是用来形成一条数据流。比如说：我们通过nickname和password向服务器请求用户信息，它就是一个有穷数列，当数据传输完毕，这个序列就闭合了。当我们去监测某个按钮的点击，我们不知道会点击多少次，这就是无穷序列。而我们所有的操作产生的数据都会通过Observable传输。<br>Observable<t> 这个类就是Rx 框架的基础，我们称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable<t> 对象会随着时间推移不定期地发出 event(element : T) 。<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class=\"line\">observable.subscribe(onNext: &#123; element in</span><br><span class=\"line\">print(element)</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">print(error)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;, onDisposed: &#123;</span><br><span class=\"line\">print(&quot;disposed&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</t></t></li>\n</ul>\n<p>这里subscribe后面的onNext,onError, onCompleted 分别响应我们创建 json 时，构建函数里面的onNext,onError, onCompleted 事件。我们称这些事件为 Event。<br>Event的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Event&lt;Element&gt; &#123;</span><br><span class=\"line\">/// Next element is produced.</span><br><span class=\"line\">case next(Element)</span><br><span class=\"line\">/// Sequence terminated with an error.</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">/// Sequence completed successfully.</span><br><span class=\"line\">case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出Event就是一个枚举，也就是说一个 Observable 是可以发出 3 种不同类型的 Event 事件。</p>\n<ul>\n<li>next:序列产生了一个新的元素</li>\n<li>error:创建序列时产生了一个错误，导致序列终止</li>\n<li>completed:序列的所有元素都已经成功产生，整个序列已经完成<br>我们通过这些Event实现业务逻辑。<h2 id=\"Observer-观察者\"><a href=\"#Observer-观察者\" class=\"headerlink\" title=\"Observer 观察者\"></a>Observer 观察者</h2>观察者（Observer）的作用就是监听事件，然后对这个事件做出响应，或者说任何响应事件的行为都是观察者。比如：</li>\n<li>当前视频播放到30分钟时，弹出视频小剧场(广告)，后者就是观察者。</li>\n<li>当前温度高于30度，打开空调降温，后者就是观察者。</li>\n<li>当你点击视频拍摄时，系统弹出弹框问你是否同意使用摄像头，后者就是观察者。</li>\n<li>······<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tap.subscribe(onNext: &#123; [weak self] in</span><br><span class=\"line\">self?.showAlert()</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">print(&quot;发生错误： \\(error.localizedDescription)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">print(&quot;任务完成&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在这里，弹出提示框就是观察者。<br>创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述，事件发生时，需要如何做出响应。而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的。此外，我们还有AnyObserver、Binder方式创建观察者。</p>\n<h2 id=\"Operator-操作符\"><a href=\"#Operator-操作符\" class=\"headerlink\" title=\"Operator  操作符\"></a>Operator  操作符</h2><p>操作符可以帮助大家创建新的序列，或者变化组合原有的序列，从而生成一个新的序列。可以对比一下Swift中的高阶函数。具体使用方法暂不做介绍，只举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obserable = Observable&lt;Int&gt;.of(1,2,3,4,5,6,7,8,9,10)</span><br><span class=\"line\">obserable.filter&#123; $0 &gt; 5&#125;</span><br><span class=\"line\">.subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">//6 7 8 9 10</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Disposable-可被清除的资源\"><a href=\"#Disposable-可被清除的资源\" class=\"headerlink\" title=\"Disposable  可被清除的资源\"></a>Disposable  可被清除的资源</h2><p>一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。激活之后要一直等到它发出了.error或者 .completed的 event 后，它才被终结。而如果我们想提前释放这些资源或者取消订阅的话，可以对返回的可被清除的资源（Disposable） 调用 dispose 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var disposable: Disposable?</span><br><span class=\"line\"></span><br><span class=\"line\">override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class=\"line\">super.viewWillAppear(animated)</span><br><span class=\"line\"></span><br><span class=\"line\">self.disposable = textField.rx.text.orEmpty</span><br><span class=\"line\">.subscribe(onNext: &#123; text in print(text) &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">override func viewWillDisappear(_ animated: Bool) &#123;</span><br><span class=\"line\">super.viewWillDisappear(animated)</span><br><span class=\"line\"></span><br><span class=\"line\">self.disposable?.dispose()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然了，这个方法并不建议。因为Swift是使用ARC管理内存，所有推荐使用清除包（DisposeBag） 来实现这种订阅管理机制。我们可以把一个 DisposeBag对象看成一个垃圾袋，把用过的订阅行为都放进去，这个DisposeBag 就会在自己快要dealloc 的时候，对它里面的所有订阅行为都调用 dispose()方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">//第1个Observable，及其订阅</span><br><span class=\"line\">let observable1 = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class=\"line\">observable1.subscribe &#123; event in</span><br><span class=\"line\">print(event)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">//第2个Observable，及其订阅</span><br><span class=\"line\">let observable2 = Observable.of(1, 2, 3)</span><br><span class=\"line\">observable2.subscribe &#123; event in</span><br><span class=\"line\">print(event)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>此外，还有一种takeUntil，这里就不做过多描述了。</p>\n<h2 id=\"Schedulers-调度器\"><a href=\"#Schedulers-调度器\" class=\"headerlink\" title=\"Schedulers 调度器\"></a>Schedulers 调度器</h2><p>Schedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。<br>在Swift中，我们写一个GCD这么写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 后台取得数据，主线程处理结果</span><br><span class=\"line\">DispatchQueue.global(qos: .userInitiated).async &#123;</span><br><span class=\"line\">let data = try? Data(contentsOf: url)</span><br><span class=\"line\">DispatchQueue.main.async &#123;</span><br><span class=\"line\">self.data = data</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用RxSwift去实现，就这么写:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let rxData: Observable&lt;Data&gt; = ...</span><br><span class=\"line\"></span><br><span class=\"line\">rxData</span><br><span class=\"line\">.subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))</span><br><span class=\"line\">.observeOn(MainScheduler.instance)</span><br><span class=\"line\">.subscribe(onNext: &#123; [weak self] data in</span><br><span class=\"line\">self?.data = data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>在这里，我们用subscribeOn来决定数据序列的构建函数在哪个 Scheduler 上运行，用observeOn来决定在哪个 Scheduler 监听这个数据序列。比如说：在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn切到后台去发送请求并解析数据，最后用 observeOn切换到主线程更新页面。此外，我们来应该了解：</p>\n<ul>\n<li>MainScheduler：代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。</li>\n<li>SerialDispatchQueueScheduler：抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。</li>\n<li>ConcurrentDispatchQueueScheduler：抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。</li>\n<li>OperationQueueScheduler：抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在这篇中，简单介绍一下RxSwift的核心内容，首先献祭上一张图：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-90edfb06fc5c1b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"RxSwiftCore.png\"></p>\n<ul>\n<li>Observable:产生事件</li>\n<li>Observer: 响应事件</li>\n<li>Operator:创建变化组合事件</li>\n<li>Disposable:管理绑定（订阅）的生命周期</li>\n<li>Schedulers:线程队列调配<h2 id=\"Observable-可被监听的序列\"><a href=\"#Observable-可被监听的序列\" class=\"headerlink\" title=\"Observable 可被监听的序列\"></a>Observable 可被监听的序列</h2>Observable实质上就是一个Sequence。序列分为有穷序列和无穷序列，主要就是用来形成一条数据流。比如说：我们通过nickname和password向服务器请求用户信息，它就是一个有穷数列，当数据传输完毕，这个序列就闭合了。当我们去监测某个按钮的点击，我们不知道会点击多少次，这就是无穷序列。而我们所有的操作产生的数据都会通过Observable传输。<br>Observable<t> 这个类就是Rx 框架的基础，我们称它为可观察序列。它的作用就是可以异步地产生一系列的 Event（事件），即一个 Observable<t> 对象会随着时间推移不定期地发出 event(element : T) 。<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class=\"line\">observable.subscribe(onNext: &#123; element in</span><br><span class=\"line\">print(element)</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">print(error)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;, onDisposed: &#123;</span><br><span class=\"line\">print(&quot;disposed&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</t></t></li>\n</ul>\n<p>这里subscribe后面的onNext,onError, onCompleted 分别响应我们创建 json 时，构建函数里面的onNext,onError, onCompleted 事件。我们称这些事件为 Event。<br>Event的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum Event&lt;Element&gt; &#123;</span><br><span class=\"line\">/// Next element is produced.</span><br><span class=\"line\">case next(Element)</span><br><span class=\"line\">/// Sequence terminated with an error.</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">/// Sequence completed successfully.</span><br><span class=\"line\">case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出Event就是一个枚举，也就是说一个 Observable 是可以发出 3 种不同类型的 Event 事件。</p>\n<ul>\n<li>next:序列产生了一个新的元素</li>\n<li>error:创建序列时产生了一个错误，导致序列终止</li>\n<li>completed:序列的所有元素都已经成功产生，整个序列已经完成<br>我们通过这些Event实现业务逻辑。<h2 id=\"Observer-观察者\"><a href=\"#Observer-观察者\" class=\"headerlink\" title=\"Observer 观察者\"></a>Observer 观察者</h2>观察者（Observer）的作用就是监听事件，然后对这个事件做出响应，或者说任何响应事件的行为都是观察者。比如：</li>\n<li>当前视频播放到30分钟时，弹出视频小剧场(广告)，后者就是观察者。</li>\n<li>当前温度高于30度，打开空调降温，后者就是观察者。</li>\n<li>当你点击视频拍摄时，系统弹出弹框问你是否同意使用摄像头，后者就是观察者。</li>\n<li>······<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tap.subscribe(onNext: &#123; [weak self] in</span><br><span class=\"line\">self?.showAlert()</span><br><span class=\"line\">&#125;, onError: &#123; error in</span><br><span class=\"line\">print(&quot;发生错误： \\(error.localizedDescription)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">print(&quot;任务完成&quot;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在这里，弹出提示框就是观察者。<br>创建观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述，事件发生时，需要如何做出响应。而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的。此外，我们还有AnyObserver、Binder方式创建观察者。</p>\n<h2 id=\"Operator-操作符\"><a href=\"#Operator-操作符\" class=\"headerlink\" title=\"Operator  操作符\"></a>Operator  操作符</h2><p>操作符可以帮助大家创建新的序列，或者变化组合原有的序列，从而生成一个新的序列。可以对比一下Swift中的高阶函数。具体使用方法暂不做介绍，只举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obserable = Observable&lt;Int&gt;.of(1,2,3,4,5,6,7,8,9,10)</span><br><span class=\"line\">obserable.filter&#123; $0 &gt; 5&#125;</span><br><span class=\"line\">.subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">//6 7 8 9 10</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Disposable-可被清除的资源\"><a href=\"#Disposable-可被清除的资源\" class=\"headerlink\" title=\"Disposable  可被清除的资源\"></a>Disposable  可被清除的资源</h2><p>一个 Observable 序列被创建出来后它不会马上就开始被激活从而发出 Event，而是要等到它被某个人订阅了才会激活它。激活之后要一直等到它发出了.error或者 .completed的 event 后，它才被终结。而如果我们想提前释放这些资源或者取消订阅的话，可以对返回的可被清除的资源（Disposable） 调用 dispose 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var disposable: Disposable?</span><br><span class=\"line\"></span><br><span class=\"line\">override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class=\"line\">super.viewWillAppear(animated)</span><br><span class=\"line\"></span><br><span class=\"line\">self.disposable = textField.rx.text.orEmpty</span><br><span class=\"line\">.subscribe(onNext: &#123; text in print(text) &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">override func viewWillDisappear(_ animated: Bool) &#123;</span><br><span class=\"line\">super.viewWillDisappear(animated)</span><br><span class=\"line\"></span><br><span class=\"line\">self.disposable?.dispose()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然了，这个方法并不建议。因为Swift是使用ARC管理内存，所有推荐使用清除包（DisposeBag） 来实现这种订阅管理机制。我们可以把一个 DisposeBag对象看成一个垃圾袋，把用过的订阅行为都放进去，这个DisposeBag 就会在自己快要dealloc 的时候，对它里面的所有订阅行为都调用 dispose()方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">//第1个Observable，及其订阅</span><br><span class=\"line\">let observable1 = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br><span class=\"line\">observable1.subscribe &#123; event in</span><br><span class=\"line\">print(event)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">//第2个Observable，及其订阅</span><br><span class=\"line\">let observable2 = Observable.of(1, 2, 3)</span><br><span class=\"line\">observable2.subscribe &#123; event in</span><br><span class=\"line\">print(event)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>此外，还有一种takeUntil，这里就不做过多描述了。</p>\n<h2 id=\"Schedulers-调度器\"><a href=\"#Schedulers-调度器\" class=\"headerlink\" title=\"Schedulers 调度器\"></a>Schedulers 调度器</h2><p>Schedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。<br>在Swift中，我们写一个GCD这么写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 后台取得数据，主线程处理结果</span><br><span class=\"line\">DispatchQueue.global(qos: .userInitiated).async &#123;</span><br><span class=\"line\">let data = try? Data(contentsOf: url)</span><br><span class=\"line\">DispatchQueue.main.async &#123;</span><br><span class=\"line\">self.data = data</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果用RxSwift去实现，就这么写:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let rxData: Observable&lt;Data&gt; = ...</span><br><span class=\"line\"></span><br><span class=\"line\">rxData</span><br><span class=\"line\">.subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))</span><br><span class=\"line\">.observeOn(MainScheduler.instance)</span><br><span class=\"line\">.subscribe(onNext: &#123; [weak self] data in</span><br><span class=\"line\">self?.data = data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>在这里，我们用subscribeOn来决定数据序列的构建函数在哪个 Scheduler 上运行，用observeOn来决定在哪个 Scheduler 监听这个数据序列。比如说：在后台发起网络请求，然后解析数据，最后在主线程刷新页面。你就可以先用 subscribeOn切到后台去发送请求并解析数据，最后用 observeOn切换到主线程更新页面。此外，我们来应该了解：</p>\n<ul>\n<li>MainScheduler：代表主线程。如果你需要执行一些和 UI 相关的任务，就需要切换到该 Scheduler 运行。</li>\n<li>SerialDispatchQueueScheduler：抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。</li>\n<li>ConcurrentDispatchQueueScheduler：抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。</li>\n<li>OperationQueueScheduler：抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。</li>\n</ul>\n"},{"title":"RxSwift 结合操作符","date":"2018-09-28T13:47:21.000Z","_content":"结合操作（或者称合并操作）指的是将多个`Observable`序列进行组合，拼装成一个新的`Observable`序列。\n#### 1. startWith\n该方法会在`Observable`序列开始之前插入一些事件元素。即发出事件消息之前，会先发出这些预先插入的事件消息。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-1e67a4bb28af2c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(2, 3)\n        .startWith(1)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\n2\n3\n```\n#### 2. concat\n- `concat`操作符将多个`Observables`按顺序串联起来，当前一个`Observable`元素发送完毕后，后一个 Observable 才可以开始发出元素。\n- `concat`将等待前一个 Observable 产生完成事件后，才对后一个`Observable`进行订阅。如果后一个是“热”`Observable`，在它前一个`Observable`产生完成事件前，所产生的元素将不会被发送出来。\n\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-8a8303ad65144b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\net disposeBag = DisposeBag()\n\nlet subject1 = BehaviorSubject.init(value: \"1\")\nlet subject2 = BehaviorSubject.init(value: \"A\")\n\nlet variable = Variable.init(subject1)\nvariable.asObservable()\n        .concat()\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"2\")\nsubject1.onNext(\"3\")\n\nvariable.value = subject2\nsubject2.onNext(\"I would be ignored\")\nsubject2.onNext(\"B\")\n\nsubject1.onCompleted()\nsubject2.onNext(\"C\")\n```\n结果如下：\n```\nnext(1)\nnext(2)\nnext(3)\nnext(B)\nnext(C)\n```\n#### 3. merge\n- 通过使用`merge`操作符你可以将多个`Observables`合并成一个，当某一个`Observable`发出一个元素时，他就将这个元素发出。\n- 如果，某一个`Observable`发出一个`onError`事件，那么被合并的`Observable`也会将它发出，并且立即终止序列。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-4982880854a4f8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<Int>()\nlet subject2 = PublishSubject<Int>()\n\nObservable.of(subject1, subject2)\n        .merge()\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject1.onNext(20)\nsubject1.onNext(40)\nsubject1.onNext(60)\nsubject2.onNext(1)\nsubject1.onNext(80)\nsubject1.onNext(100)\nsubject2.onNext(1)\n```\n结果如下：\n```\n20\n40\n60\n1\n80\n100\n1\n```\n#### 4. zip\n`zip`操作符将多个(最多不超过8个)`Observables`的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的`Observable`的第一个元素，是由每一个源`Observables`的第一个元素组合出来的。它的第二个元素 ，是由每一个源`Observables`的第二个元素组合出来的。它的第三个元素 ，是由每一个源`Observables`的第三个元素组合出来的，以此类推。它的元素数量等于源`Observables`中元素数量最少的那个。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-ae17319dd7d0a940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet first = PublishSubject<String>()\nlet second = PublishSubject<String>()\n\nObservable.zip(first, second) { $0 + $1 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nfirst.onNext(\"1\")\nsecond.onNext(\"A\")\nfirst.onNext(\"2\")\nsecond.onNext(\"B\")\nsecond.onNext(\"C\")\nsecond.onNext(\"D\")\nfirst.onNext(\"3\")\nfirst.onNext(\"4\")\n```\n结果如下：\n```\n1A\n2B\n3C\n4D\n```\n#### 5. combineLatest\n`combineLatest`操作符将多个`Observables`中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源`Observables`中任何一个发出一个元素，他都会发出一个元素（前提是，这些`Observables`曾经发出过元素）。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-2fab45bfd4b8c814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet first = PublishSubject<String>()\nlet second = PublishSubject<String>()\n\nObservable.combineLatest(first, second) { $0 + $1 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nfirst.onNext(\"1\")\nsecond.onNext(\"A\")\nfirst.onNext(\"2\")\nsecond.onNext(\"B\")\nsecond.onNext(\"C\")\nsecond.onNext(\"D\")\nfirst.onNext(\"3\")\nfirst.onNext(\"4\")\n```\n结果如下：\n```\n1A\n2A\n2B\n2C\n2D\n3D\n4D\n```\n#### 6. withLatestFrom\n`withLatestFrom`操作符将两个`Observables`中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。当第一个`Observable`发出一个元素时，就立即取出第二个`Observable`中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-9bfeb60b798296e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<String>()\nlet subject2 = PublishSubject<String>()\n\nsubject1.withLatestFrom(subject2)\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"A\")\nsubject2.onNext(\"1\")\nsubject1.onNext(\"B\")\nsubject1.onNext(\"C\")\nsubject2.onNext(\"2\")\nsubject1.onNext(\"D\")\n\n```\n结果如下：\n```\n1\n1\n2\n```\n","source":"_posts/RxSwift-结合操作符.md","raw":"---\ntitle: RxSwift 结合操作符\ndate: 2018-09-28 21:47:21\ntags: RxSwift\n---\n结合操作（或者称合并操作）指的是将多个`Observable`序列进行组合，拼装成一个新的`Observable`序列。\n#### 1. startWith\n该方法会在`Observable`序列开始之前插入一些事件元素。即发出事件消息之前，会先发出这些预先插入的事件消息。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-1e67a4bb28af2c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nObservable.of(2, 3)\n        .startWith(1)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\n2\n3\n```\n#### 2. concat\n- `concat`操作符将多个`Observables`按顺序串联起来，当前一个`Observable`元素发送完毕后，后一个 Observable 才可以开始发出元素。\n- `concat`将等待前一个 Observable 产生完成事件后，才对后一个`Observable`进行订阅。如果后一个是“热”`Observable`，在它前一个`Observable`产生完成事件前，所产生的元素将不会被发送出来。\n\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-8a8303ad65144b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\net disposeBag = DisposeBag()\n\nlet subject1 = BehaviorSubject.init(value: \"1\")\nlet subject2 = BehaviorSubject.init(value: \"A\")\n\nlet variable = Variable.init(subject1)\nvariable.asObservable()\n        .concat()\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"2\")\nsubject1.onNext(\"3\")\n\nvariable.value = subject2\nsubject2.onNext(\"I would be ignored\")\nsubject2.onNext(\"B\")\n\nsubject1.onCompleted()\nsubject2.onNext(\"C\")\n```\n结果如下：\n```\nnext(1)\nnext(2)\nnext(3)\nnext(B)\nnext(C)\n```\n#### 3. merge\n- 通过使用`merge`操作符你可以将多个`Observables`合并成一个，当某一个`Observable`发出一个元素时，他就将这个元素发出。\n- 如果，某一个`Observable`发出一个`onError`事件，那么被合并的`Observable`也会将它发出，并且立即终止序列。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-4982880854a4f8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<Int>()\nlet subject2 = PublishSubject<Int>()\n\nObservable.of(subject1, subject2)\n        .merge()\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject1.onNext(20)\nsubject1.onNext(40)\nsubject1.onNext(60)\nsubject2.onNext(1)\nsubject1.onNext(80)\nsubject1.onNext(100)\nsubject2.onNext(1)\n```\n结果如下：\n```\n20\n40\n60\n1\n80\n100\n1\n```\n#### 4. zip\n`zip`操作符将多个(最多不超过8个)`Observables`的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的`Observable`的第一个元素，是由每一个源`Observables`的第一个元素组合出来的。它的第二个元素 ，是由每一个源`Observables`的第二个元素组合出来的。它的第三个元素 ，是由每一个源`Observables`的第三个元素组合出来的，以此类推。它的元素数量等于源`Observables`中元素数量最少的那个。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-ae17319dd7d0a940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet first = PublishSubject<String>()\nlet second = PublishSubject<String>()\n\nObservable.zip(first, second) { $0 + $1 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nfirst.onNext(\"1\")\nsecond.onNext(\"A\")\nfirst.onNext(\"2\")\nsecond.onNext(\"B\")\nsecond.onNext(\"C\")\nsecond.onNext(\"D\")\nfirst.onNext(\"3\")\nfirst.onNext(\"4\")\n```\n结果如下：\n```\n1A\n2B\n3C\n4D\n```\n#### 5. combineLatest\n`combineLatest`操作符将多个`Observables`中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源`Observables`中任何一个发出一个元素，他都会发出一个元素（前提是，这些`Observables`曾经发出过元素）。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-2fab45bfd4b8c814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet first = PublishSubject<String>()\nlet second = PublishSubject<String>()\n\nObservable.combineLatest(first, second) { $0 + $1 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nfirst.onNext(\"1\")\nsecond.onNext(\"A\")\nfirst.onNext(\"2\")\nsecond.onNext(\"B\")\nsecond.onNext(\"C\")\nsecond.onNext(\"D\")\nfirst.onNext(\"3\")\nfirst.onNext(\"4\")\n```\n结果如下：\n```\n1A\n2A\n2B\n2C\n2D\n3D\n4D\n```\n#### 6. withLatestFrom\n`withLatestFrom`操作符将两个`Observables`中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。当第一个`Observable`发出一个元素时，就立即取出第二个`Observable`中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。\n![image.png](https://upload-images.jianshu.io/upload_images/2855070-9bfeb60b798296e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet subject1 = PublishSubject<String>()\nlet subject2 = PublishSubject<String>()\n\nsubject1.withLatestFrom(subject2)\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n\nsubject1.onNext(\"A\")\nsubject2.onNext(\"1\")\nsubject1.onNext(\"B\")\nsubject1.onNext(\"C\")\nsubject2.onNext(\"2\")\nsubject1.onNext(\"D\")\n\n```\n结果如下：\n```\n1\n1\n2\n```\n","slug":"RxSwift-结合操作符","published":1,"updated":"2018-10-19T07:16:01.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxs300082ycw4lky00qt","content":"<p>结合操作（或者称合并操作）指的是将多个<code>Observable</code>序列进行组合，拼装成一个新的<code>Observable</code>序列。</p>\n<h4 id=\"1-startWith\"><a href=\"#1-startWith\" class=\"headerlink\" title=\"1. startWith\"></a>1. startWith</h4><p>该方法会在<code>Observable</code>序列开始之前插入一些事件元素。即发出事件消息之前，会先发出这些预先插入的事件消息。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-1e67a4bb28af2c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(2, 3)</span><br><span class=\"line\">        .startWith(1)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-concat\"><a href=\"#2-concat\" class=\"headerlink\" title=\"2. concat\"></a>2. concat</h4><ul>\n<li><code>concat</code>操作符将多个<code>Observables</code>按顺序串联起来，当前一个<code>Observable</code>元素发送完毕后，后一个 Observable 才可以开始发出元素。</li>\n<li><code>concat</code>将等待前一个 Observable 产生完成事件后，才对后一个<code>Observable</code>进行订阅。如果后一个是“热”<code>Observable</code>，在它前一个<code>Observable</code>产生完成事件前，所产生的元素将不会被发送出来。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-8a8303ad65144b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">et disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = BehaviorSubject.init(value: &quot;1&quot;)</span><br><span class=\"line\">let subject2 = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">let variable = Variable.init(subject1)</span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .concat()</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;2&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;3&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.value = subject2</span><br><span class=\"line\">subject2.onNext(&quot;I would be ignored&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;B&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onCompleted()</span><br><span class=\"line\">subject2.onNext(&quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(1)</span><br><span class=\"line\">next(2)</span><br><span class=\"line\">next(3)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">next(C)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-merge\"><a href=\"#3-merge\" class=\"headerlink\" title=\"3. merge\"></a>3. merge</h4><ul>\n<li>通过使用<code>merge</code>操作符你可以将多个<code>Observables</code>合并成一个，当某一个<code>Observable</code>发出一个元素时，他就将这个元素发出。</li>\n<li>如果，某一个<code>Observable</code>发出一个<code>onError</code>事件，那么被合并的<code>Observable</code>也会将它发出，并且立即终止序列。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4982880854a4f8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(subject1, subject2)</span><br><span class=\"line\">        .merge()</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(20)</span><br><span class=\"line\">subject1.onNext(40)</span><br><span class=\"line\">subject1.onNext(60)</span><br><span class=\"line\">subject2.onNext(1)</span><br><span class=\"line\">subject1.onNext(80)</span><br><span class=\"line\">subject1.onNext(100)</span><br><span class=\"line\">subject2.onNext(1)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20</span><br><span class=\"line\">40</span><br><span class=\"line\">60</span><br><span class=\"line\">1</span><br><span class=\"line\">80</span><br><span class=\"line\">100</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-zip\"><a href=\"#4-zip\" class=\"headerlink\" title=\"4. zip\"></a>4. zip</h4><p><code>zip</code>操作符将多个(最多不超过8个)<code>Observables</code>的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的<code>Observable</code>的第一个元素，是由每一个源<code>Observables</code>的第一个元素组合出来的。它的第二个元素 ，是由每一个源<code>Observables</code>的第二个元素组合出来的。它的第三个元素 ，是由每一个源<code>Observables</code>的第三个元素组合出来的，以此类推。它的元素数量等于源<code>Observables</code>中元素数量最少的那个。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ae17319dd7d0a940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let first = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let second = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.zip(first, second) &#123; $0 + $1 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">second.onNext(&quot;A&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\">second.onNext(&quot;B&quot;)</span><br><span class=\"line\">second.onNext(&quot;C&quot;)</span><br><span class=\"line\">second.onNext(&quot;D&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br><span class=\"line\">first.onNext(&quot;4&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1A</span><br><span class=\"line\">2B</span><br><span class=\"line\">3C</span><br><span class=\"line\">4D</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-combineLatest\"><a href=\"#5-combineLatest\" class=\"headerlink\" title=\"5. combineLatest\"></a>5. combineLatest</h4><p><code>combineLatest</code>操作符将多个<code>Observables</code>中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源<code>Observables</code>中任何一个发出一个元素，他都会发出一个元素（前提是，这些<code>Observables</code>曾经发出过元素）。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-2fab45bfd4b8c814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let first = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let second = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.combineLatest(first, second) &#123; $0 + $1 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">second.onNext(&quot;A&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\">second.onNext(&quot;B&quot;)</span><br><span class=\"line\">second.onNext(&quot;C&quot;)</span><br><span class=\"line\">second.onNext(&quot;D&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br><span class=\"line\">first.onNext(&quot;4&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1A</span><br><span class=\"line\">2A</span><br><span class=\"line\">2B</span><br><span class=\"line\">2C</span><br><span class=\"line\">2D</span><br><span class=\"line\">3D</span><br><span class=\"line\">4D</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-withLatestFrom\"><a href=\"#6-withLatestFrom\" class=\"headerlink\" title=\"6. withLatestFrom\"></a>6. withLatestFrom</h4><p><code>withLatestFrom</code>操作符将两个<code>Observables</code>中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。当第一个<code>Observable</code>发出一个元素时，就立即取出第二个<code>Observable</code>中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-9bfeb60b798296e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.withLatestFrom(subject2)</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;1&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;2&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;D&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>结合操作（或者称合并操作）指的是将多个<code>Observable</code>序列进行组合，拼装成一个新的<code>Observable</code>序列。</p>\n<h4 id=\"1-startWith\"><a href=\"#1-startWith\" class=\"headerlink\" title=\"1. startWith\"></a>1. startWith</h4><p>该方法会在<code>Observable</code>序列开始之前插入一些事件元素。即发出事件消息之前，会先发出这些预先插入的事件消息。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-1e67a4bb28af2c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(2, 3)</span><br><span class=\"line\">        .startWith(1)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-concat\"><a href=\"#2-concat\" class=\"headerlink\" title=\"2. concat\"></a>2. concat</h4><ul>\n<li><code>concat</code>操作符将多个<code>Observables</code>按顺序串联起来，当前一个<code>Observable</code>元素发送完毕后，后一个 Observable 才可以开始发出元素。</li>\n<li><code>concat</code>将等待前一个 Observable 产生完成事件后，才对后一个<code>Observable</code>进行订阅。如果后一个是“热”<code>Observable</code>，在它前一个<code>Observable</code>产生完成事件前，所产生的元素将不会被发送出来。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-8a8303ad65144b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">et disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = BehaviorSubject.init(value: &quot;1&quot;)</span><br><span class=\"line\">let subject2 = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">let variable = Variable.init(subject1)</span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .concat()</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;2&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;3&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.value = subject2</span><br><span class=\"line\">subject2.onNext(&quot;I would be ignored&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;B&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onCompleted()</span><br><span class=\"line\">subject2.onNext(&quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(1)</span><br><span class=\"line\">next(2)</span><br><span class=\"line\">next(3)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">next(C)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-merge\"><a href=\"#3-merge\" class=\"headerlink\" title=\"3. merge\"></a>3. merge</h4><ul>\n<li>通过使用<code>merge</code>操作符你可以将多个<code>Observables</code>合并成一个，当某一个<code>Observable</code>发出一个元素时，他就将这个元素发出。</li>\n<li>如果，某一个<code>Observable</code>发出一个<code>onError</code>事件，那么被合并的<code>Observable</code>也会将它发出，并且立即终止序列。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4982880854a4f8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(subject1, subject2)</span><br><span class=\"line\">        .merge()</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(20)</span><br><span class=\"line\">subject1.onNext(40)</span><br><span class=\"line\">subject1.onNext(60)</span><br><span class=\"line\">subject2.onNext(1)</span><br><span class=\"line\">subject1.onNext(80)</span><br><span class=\"line\">subject1.onNext(100)</span><br><span class=\"line\">subject2.onNext(1)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">20</span><br><span class=\"line\">40</span><br><span class=\"line\">60</span><br><span class=\"line\">1</span><br><span class=\"line\">80</span><br><span class=\"line\">100</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-zip\"><a href=\"#4-zip\" class=\"headerlink\" title=\"4. zip\"></a>4. zip</h4><p><code>zip</code>操作符将多个(最多不超过8个)<code>Observables</code>的元素通过一个函数组合起来，然后将这个组合的结果发出来。它会严格的按照序列的索引数进行组合。例如，返回的<code>Observable</code>的第一个元素，是由每一个源<code>Observables</code>的第一个元素组合出来的。它的第二个元素 ，是由每一个源<code>Observables</code>的第二个元素组合出来的。它的第三个元素 ，是由每一个源<code>Observables</code>的第三个元素组合出来的，以此类推。它的元素数量等于源<code>Observables</code>中元素数量最少的那个。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ae17319dd7d0a940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let first = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let second = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.zip(first, second) &#123; $0 + $1 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">second.onNext(&quot;A&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\">second.onNext(&quot;B&quot;)</span><br><span class=\"line\">second.onNext(&quot;C&quot;)</span><br><span class=\"line\">second.onNext(&quot;D&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br><span class=\"line\">first.onNext(&quot;4&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1A</span><br><span class=\"line\">2B</span><br><span class=\"line\">3C</span><br><span class=\"line\">4D</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-combineLatest\"><a href=\"#5-combineLatest\" class=\"headerlink\" title=\"5. combineLatest\"></a>5. combineLatest</h4><p><code>combineLatest</code>操作符将多个<code>Observables</code>中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。这些源<code>Observables</code>中任何一个发出一个元素，他都会发出一个元素（前提是，这些<code>Observables</code>曾经发出过元素）。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-2fab45bfd4b8c814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let first = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let second = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.combineLatest(first, second) &#123; $0 + $1 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">second.onNext(&quot;A&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\">second.onNext(&quot;B&quot;)</span><br><span class=\"line\">second.onNext(&quot;C&quot;)</span><br><span class=\"line\">second.onNext(&quot;D&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br><span class=\"line\">first.onNext(&quot;4&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1A</span><br><span class=\"line\">2A</span><br><span class=\"line\">2B</span><br><span class=\"line\">2C</span><br><span class=\"line\">2D</span><br><span class=\"line\">3D</span><br><span class=\"line\">4D</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-withLatestFrom\"><a href=\"#6-withLatestFrom\" class=\"headerlink\" title=\"6. withLatestFrom\"></a>6. withLatestFrom</h4><p><code>withLatestFrom</code>操作符将两个<code>Observables</code>中最新的元素通过一个函数组合起来，然后将这个组合的结果发出来。当第一个<code>Observable</code>发出一个元素时，就立即取出第二个<code>Observable</code>中最新的元素，通过一个组合函数将两个最新的元素合并后发送出去。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-9bfeb60b798296e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let subject1 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">let subject2 = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.withLatestFrom(subject2)</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject1.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;1&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject2.onNext(&quot;2&quot;)</span><br><span class=\"line\">subject1.onNext(&quot;D&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n"},{"title":"RxSwift 过滤操作符(Filtering Observables)","date":"2018-09-26T13:30:34.000Z","_content":"过滤操作指的是从源`Observable`中选择特定的数据发送。\n#### 1. filter\n`filter`操作符将通过你提供的判定方法过滤一个`Observable`。\n![filter.png](https://upload-images.jianshu.io/upload_images/2855070-7403d9c225aec4cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nObservable.of(2, 30, 22, 5, 60, 1)\n        .filter{ $0 > 10 }\n        .subscribe(onNext: { print( $0 )})\n        .disposed(by: disposeBag)\n```\n输出结果：\n```\n30\n22\n60\n```\n#### 2. distinctUntilChanged\n`distinctUntilChanged`操作符将阻止`Observable`发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。\n![distinctUntilChanged.png](https://upload-images.jianshu.io/upload_images/2855070-0c5afa37f9610704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 2, 1, 3)\n        .distinctUntilChanged()\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n输出结果：\n```\n1\n2\n1\n3\n```\n#### 3. single\n- 限制只发送一次事件，或者满足条件的第一个事件。\n- 如果存在有多个事件或者没有事件都会发出一个`error`事件。\n- 如果只有一个事件，则不会发出`error`事件\n\n![single.png](https://upload-images.jianshu.io/upload_images/2855070-29bfd143ec29394e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 4, 4, 5)\n        .single()\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n\nObservable.of(\"A\")\n        .single()\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\nUnhandled error happened: Sequence contains more than one element.\nsubscription called from:\nA\n```\n#### 4. elementAt\n`elementAt`操作符将拉取`Observable`序列中指定索引数的元素，然后将它作为唯一的元素发出。\n![elementAt.png](https://upload-images.jianshu.io/upload_images/2855070-b8ac9409cc9bf25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .elementAt(2)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n3\n```\n#### 5. ignoreElements\n- 该操作符可以忽略掉所有的元素，只发出`error`或`completed`事件。\n- 如果我们并不关心`Observable`的任何元素，只想知道`Observable`在什么时候终止，那就可以使用`ignoreElements`操作符。\n\n![ignoreElements.png](https://upload-images.jianshu.io/upload_images/2855070-bcadae47ddc7f71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 4, 4, 5)\n        .ignoreElements()\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\ncompleted\n```\n#### 6.take\n该方法实现仅发送`Observable`序列中的前`n`个事件，在满足数量之后会自动`.completed`\n![take.png](https://upload-images.jianshu.io/upload_images/2855070-ba890655a1787c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .take(2)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\n2\n```\n#### 7. takeLast\n该方法实现仅发送`Observable`序列中的后`n`个事件\n![takeLast.png](https://upload-images.jianshu.io/upload_images/2855070-3e60ff6e411e234c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .takeLast(1)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n4\n```\n#### 8. skip\n该方法用于跳过源`Observable`序列发出的前`n`个事件。\n![skip.png](https://upload-images.jianshu.io/upload_images/2855070-439c4618a9901d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .skip(2)\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n3\n4\n```\n#### 9. Sample\n- `Sample`除了订阅源`Observable`外，还可以监视另外一个`Observable`， 即`notifier`。\n每当收到`notifier`事件，就会从源序列取一个最新的事件并发送。而如果两次`notifier`事件之间没有源序列的事件，则不发送值。\n\n![sample.png](https://upload-images.jianshu.io/upload_images/2855070-509212ce29f1c102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet source = PublishSubject<Int>()\nlet notifier = PublishSubject<String>()\n\nsource.sample(notifier)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n\nsource.onNext(1)\n\nnotifier.onNext(\"A\")\n\nsource.onNext(2)\n\nnotifier.onNext(\"B\")\nnotifier.onNext(\"C\")\n\nsource.onNext(3)\nsource.onNext(4)\n\nnotifier.onNext(\"D\")\n\nsource.onNext(5)\n\nnotifier.onCompleted()\n```\n结果如下：\n```\n1\n2\n4\n5\n```\n#### 10. debounce\n- `debounce`操作符可以用来_过滤掉高频产生的元素_，它只会发出这种元素：该元素产生后，一段时间内没有新元素产生。\n- 换句话说就是，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉。\n- `debounce`常用在_用户输入_的时候，不需要每个字母敲进去都发送一个事件，而是稍等一下取最后一个事件。\n\n![debounce.png](https://upload-images.jianshu.io/upload_images/2855070-b313fa33f47012ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\n\n//定义好每个事件里的值以及发送的时间\nlet times = [\n[ \"value\": 1, \"time\": 0.1 ],\n[ \"value\": 2, \"time\": 1.1 ],\n[ \"value\": 3, \"time\": 1.2 ],\n[ \"value\": 4, \"time\": 1.2 ],\n[ \"value\": 5, \"time\": 1.4 ],\n[ \"value\": 6, \"time\": 2.1 ]\n]\n\n//生成对应的 Observable 序列并订阅\nObservable.from(times)\n        .flatMap { item in\n            return Observable.of(Int(item[\"value\"]!))\n                            .delaySubscription(Double(item[\"time\"]!),scheduler: MainScheduler.instance)\n                }\n        .debounce(0.5, scheduler: MainScheduler.instance) //只发出与下一个间隔超过0.5秒的元素\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n```\n运行结果......为啥我啥也没打印出来？？？\n![u=4240739968,2514380758&fm=27&gp=0.jpg](https://upload-images.jianshu.io/upload_images/2855070-bafa66b6f115f0c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个留在下回思考......\n但据可靠信息，咳咳咳，打印出来的应该是\n```\n1\n5\n6\n```\n\n","source":"_posts/RxSwift-过滤操作符-Filtering-Observables.md","raw":"---\ntitle: RxSwift 过滤操作符(Filtering Observables)\ndate: 2018-09-26 21:30:34\ntags: RxSwift\n---\n过滤操作指的是从源`Observable`中选择特定的数据发送。\n#### 1. filter\n`filter`操作符将通过你提供的判定方法过滤一个`Observable`。\n![filter.png](https://upload-images.jianshu.io/upload_images/2855070-7403d9c225aec4cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nObservable.of(2, 30, 22, 5, 60, 1)\n        .filter{ $0 > 10 }\n        .subscribe(onNext: { print( $0 )})\n        .disposed(by: disposeBag)\n```\n输出结果：\n```\n30\n22\n60\n```\n#### 2. distinctUntilChanged\n`distinctUntilChanged`操作符将阻止`Observable`发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。\n![distinctUntilChanged.png](https://upload-images.jianshu.io/upload_images/2855070-0c5afa37f9610704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 2, 1, 3)\n        .distinctUntilChanged()\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n输出结果：\n```\n1\n2\n1\n3\n```\n#### 3. single\n- 限制只发送一次事件，或者满足条件的第一个事件。\n- 如果存在有多个事件或者没有事件都会发出一个`error`事件。\n- 如果只有一个事件，则不会发出`error`事件\n\n![single.png](https://upload-images.jianshu.io/upload_images/2855070-29bfd143ec29394e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 4, 4, 5)\n        .single()\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n\nObservable.of(\"A\")\n        .single()\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\nUnhandled error happened: Sequence contains more than one element.\nsubscription called from:\nA\n```\n#### 4. elementAt\n`elementAt`操作符将拉取`Observable`序列中指定索引数的元素，然后将它作为唯一的元素发出。\n![elementAt.png](https://upload-images.jianshu.io/upload_images/2855070-b8ac9409cc9bf25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .elementAt(2)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n3\n```\n#### 5. ignoreElements\n- 该操作符可以忽略掉所有的元素，只发出`error`或`completed`事件。\n- 如果我们并不关心`Observable`的任何元素，只想知道`Observable`在什么时候终止，那就可以使用`ignoreElements`操作符。\n\n![ignoreElements.png](https://upload-images.jianshu.io/upload_images/2855070-bcadae47ddc7f71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 4, 4, 5)\n        .ignoreElements()\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\ncompleted\n```\n#### 6.take\n该方法实现仅发送`Observable`序列中的前`n`个事件，在满足数量之后会自动`.completed`\n![take.png](https://upload-images.jianshu.io/upload_images/2855070-ba890655a1787c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .take(2)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n1\n2\n```\n#### 7. takeLast\n该方法实现仅发送`Observable`序列中的后`n`个事件\n![takeLast.png](https://upload-images.jianshu.io/upload_images/2855070-3e60ff6e411e234c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .takeLast(1)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n4\n```\n#### 8. skip\n该方法用于跳过源`Observable`序列发出的前`n`个事件。\n![skip.png](https://upload-images.jianshu.io/upload_images/2855070-439c4618a9901d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4)\n        .skip(2)\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n结果如下：\n```\n3\n4\n```\n#### 9. Sample\n- `Sample`除了订阅源`Observable`外，还可以监视另外一个`Observable`， 即`notifier`。\n每当收到`notifier`事件，就会从源序列取一个最新的事件并发送。而如果两次`notifier`事件之间没有源序列的事件，则不发送值。\n\n![sample.png](https://upload-images.jianshu.io/upload_images/2855070-509212ce29f1c102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\n\nlet source = PublishSubject<Int>()\nlet notifier = PublishSubject<String>()\n\nsource.sample(notifier)\n        .subscribe(onNext: {print($0)})\n        .disposed(by: disposeBag)\n\nsource.onNext(1)\n\nnotifier.onNext(\"A\")\n\nsource.onNext(2)\n\nnotifier.onNext(\"B\")\nnotifier.onNext(\"C\")\n\nsource.onNext(3)\nsource.onNext(4)\n\nnotifier.onNext(\"D\")\n\nsource.onNext(5)\n\nnotifier.onCompleted()\n```\n结果如下：\n```\n1\n2\n4\n5\n```\n#### 10. debounce\n- `debounce`操作符可以用来_过滤掉高频产生的元素_，它只会发出这种元素：该元素产生后，一段时间内没有新元素产生。\n- 换句话说就是，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉。\n- `debounce`常用在_用户输入_的时候，不需要每个字母敲进去都发送一个事件，而是稍等一下取最后一个事件。\n\n![debounce.png](https://upload-images.jianshu.io/upload_images/2855070-b313fa33f47012ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\n\n//定义好每个事件里的值以及发送的时间\nlet times = [\n[ \"value\": 1, \"time\": 0.1 ],\n[ \"value\": 2, \"time\": 1.1 ],\n[ \"value\": 3, \"time\": 1.2 ],\n[ \"value\": 4, \"time\": 1.2 ],\n[ \"value\": 5, \"time\": 1.4 ],\n[ \"value\": 6, \"time\": 2.1 ]\n]\n\n//生成对应的 Observable 序列并订阅\nObservable.from(times)\n        .flatMap { item in\n            return Observable.of(Int(item[\"value\"]!))\n                            .delaySubscription(Double(item[\"time\"]!),scheduler: MainScheduler.instance)\n                }\n        .debounce(0.5, scheduler: MainScheduler.instance) //只发出与下一个间隔超过0.5秒的元素\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n```\n运行结果......为啥我啥也没打印出来？？？\n![u=4240739968,2514380758&fm=27&gp=0.jpg](https://upload-images.jianshu.io/upload_images/2855070-bafa66b6f115f0c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这个留在下回思考......\n但据可靠信息，咳咳咳，打印出来的应该是\n```\n1\n5\n6\n```\n\n","slug":"RxSwift-过滤操作符-Filtering-Observables","published":1,"updated":"2018-10-19T07:16:01.843Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxs5000a2ycwxpysfsbj","content":"<p>过滤操作指的是从源<code>Observable</code>中选择特定的数据发送。</p>\n<h4 id=\"1-filter\"><a href=\"#1-filter\" class=\"headerlink\" title=\"1. filter\"></a>1. filter</h4><p><code>filter</code>操作符将通过你提供的判定方法过滤一个<code>Observable</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-7403d9c225aec4cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"filter.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(2, 30, 22, 5, 60, 1)</span><br><span class=\"line\">        .filter&#123; $0 &gt; 10 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print( $0 )&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30</span><br><span class=\"line\">22</span><br><span class=\"line\">60</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-distinctUntilChanged\"><a href=\"#2-distinctUntilChanged\" class=\"headerlink\" title=\"2. distinctUntilChanged\"></a>2. distinctUntilChanged</h4><p><code>distinctUntilChanged</code>操作符将阻止<code>Observable</code>发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-0c5afa37f9610704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"distinctUntilChanged.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 2, 1, 3)</span><br><span class=\"line\">        .distinctUntilChanged()</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-single\"><a href=\"#3-single\" class=\"headerlink\" title=\"3. single\"></a>3. single</h4><ul>\n<li>限制只发送一次事件，或者满足条件的第一个事件。</li>\n<li>如果存在有多个事件或者没有事件都会发出一个<code>error</code>事件。</li>\n<li>如果只有一个事件，则不会发出<code>error</code>事件</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-29bfd143ec29394e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"single.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 4, 4, 5)</span><br><span class=\"line\">        .single()</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(&quot;A&quot;)</span><br><span class=\"line\">        .single()</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">Unhandled error happened: Sequence contains more than one element.</span><br><span class=\"line\">subscription called from:</span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-elementAt\"><a href=\"#4-elementAt\" class=\"headerlink\" title=\"4. elementAt\"></a>4. elementAt</h4><p><code>elementAt</code>操作符将拉取<code>Observable</code>序列中指定索引数的元素，然后将它作为唯一的元素发出。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b8ac9409cc9bf25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"elementAt.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .elementAt(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-ignoreElements\"><a href=\"#5-ignoreElements\" class=\"headerlink\" title=\"5. ignoreElements\"></a>5. ignoreElements</h4><ul>\n<li>该操作符可以忽略掉所有的元素，只发出<code>error</code>或<code>completed</code>事件。</li>\n<li>如果我们并不关心<code>Observable</code>的任何元素，只想知道<code>Observable</code>在什么时候终止，那就可以使用<code>ignoreElements</code>操作符。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bcadae47ddc7f71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ignoreElements.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 4, 4, 5)</span><br><span class=\"line\">        .ignoreElements()</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-take\"><a href=\"#6-take\" class=\"headerlink\" title=\"6.take\"></a>6.take</h4><p>该方法实现仅发送<code>Observable</code>序列中的前<code>n</code>个事件，在满足数量之后会自动<code>.completed</code><br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ba890655a1787c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"take.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .take(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-takeLast\"><a href=\"#7-takeLast\" class=\"headerlink\" title=\"7. takeLast\"></a>7. takeLast</h4><p>该方法实现仅发送<code>Observable</code>序列中的后<code>n</code>个事件<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-3e60ff6e411e234c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"takeLast.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .takeLast(1)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-skip\"><a href=\"#8-skip\" class=\"headerlink\" title=\"8. skip\"></a>8. skip</h4><p>该方法用于跳过源<code>Observable</code>序列发出的前<code>n</code>个事件。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-439c4618a9901d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"skip.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .skip(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"9-Sample\"><a href=\"#9-Sample\" class=\"headerlink\" title=\"9. Sample\"></a>9. Sample</h4><ul>\n<li><code>Sample</code>除了订阅源<code>Observable</code>外，还可以监视另外一个<code>Observable</code>， 即<code>notifier</code>。<br>每当收到<code>notifier</code>事件，就会从源序列取一个最新的事件并发送。而如果两次<code>notifier</code>事件之间没有源序列的事件，则不发送值。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-509212ce29f1c102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"sample.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let source = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let notifier = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">source.sample(notifier)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(1)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;A&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(2)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;B&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(3)</span><br><span class=\"line\">source.onNext(4)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;D&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(5)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onCompleted()</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"10-debounce\"><a href=\"#10-debounce\" class=\"headerlink\" title=\"10. debounce\"></a>10. debounce</h4><ul>\n<li><code>debounce</code>操作符可以用来<em>过滤掉高频产生的元素</em>，它只会发出这种元素：该元素产生后，一段时间内没有新元素产生。</li>\n<li>换句话说就是，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉。</li>\n<li><code>debounce</code>常用在<em>用户输入</em>的时候，不需要每个字母敲进去都发送一个事件，而是稍等一下取最后一个事件。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b313fa33f47012ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"debounce.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">//定义好每个事件里的值以及发送的时间</span><br><span class=\"line\">let times = [</span><br><span class=\"line\">[ &quot;value&quot;: 1, &quot;time&quot;: 0.1 ],</span><br><span class=\"line\">[ &quot;value&quot;: 2, &quot;time&quot;: 1.1 ],</span><br><span class=\"line\">[ &quot;value&quot;: 3, &quot;time&quot;: 1.2 ],</span><br><span class=\"line\">[ &quot;value&quot;: 4, &quot;time&quot;: 1.2 ],</span><br><span class=\"line\">[ &quot;value&quot;: 5, &quot;time&quot;: 1.4 ],</span><br><span class=\"line\">[ &quot;value&quot;: 6, &quot;time&quot;: 2.1 ]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">//生成对应的 Observable 序列并订阅</span><br><span class=\"line\">Observable.from(times)</span><br><span class=\"line\">        .flatMap &#123; item in</span><br><span class=\"line\">            return Observable.of(Int(item[&quot;value&quot;]!))</span><br><span class=\"line\">                            .delaySubscription(Double(item[&quot;time&quot;]!),scheduler: MainScheduler.instance)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        .debounce(0.5, scheduler: MainScheduler.instance) //只发出与下一个间隔超过0.5秒的元素</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>运行结果……为啥我啥也没打印出来？？？<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bafa66b6f115f0c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"u=4240739968,2514380758&amp;fm=27&amp;gp=0.jpg\"><br>这个留在下回思考……<br>但据可靠信息，咳咳咳，打印出来的应该是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>过滤操作指的是从源<code>Observable</code>中选择特定的数据发送。</p>\n<h4 id=\"1-filter\"><a href=\"#1-filter\" class=\"headerlink\" title=\"1. filter\"></a>1. filter</h4><p><code>filter</code>操作符将通过你提供的判定方法过滤一个<code>Observable</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-7403d9c225aec4cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"filter.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(2, 30, 22, 5, 60, 1)</span><br><span class=\"line\">        .filter&#123; $0 &gt; 10 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print( $0 )&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30</span><br><span class=\"line\">22</span><br><span class=\"line\">60</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-distinctUntilChanged\"><a href=\"#2-distinctUntilChanged\" class=\"headerlink\" title=\"2. distinctUntilChanged\"></a>2. distinctUntilChanged</h4><p><code>distinctUntilChanged</code>操作符将阻止<code>Observable</code>发出相同的元素。如果后一个元素和前一个元素是相同的，那么这个元素将不会被发出来。如果后一个元素和前一个元素不相同，那么这个元素才会被发出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-0c5afa37f9610704.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"distinctUntilChanged.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 2, 1, 3)</span><br><span class=\"line\">        .distinctUntilChanged()</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-single\"><a href=\"#3-single\" class=\"headerlink\" title=\"3. single\"></a>3. single</h4><ul>\n<li>限制只发送一次事件，或者满足条件的第一个事件。</li>\n<li>如果存在有多个事件或者没有事件都会发出一个<code>error</code>事件。</li>\n<li>如果只有一个事件，则不会发出<code>error</code>事件</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-29bfd143ec29394e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"single.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 4, 4, 5)</span><br><span class=\"line\">        .single()</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">Observable.of(&quot;A&quot;)</span><br><span class=\"line\">        .single()</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">Unhandled error happened: Sequence contains more than one element.</span><br><span class=\"line\">subscription called from:</span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-elementAt\"><a href=\"#4-elementAt\" class=\"headerlink\" title=\"4. elementAt\"></a>4. elementAt</h4><p><code>elementAt</code>操作符将拉取<code>Observable</code>序列中指定索引数的元素，然后将它作为唯一的元素发出。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b8ac9409cc9bf25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"elementAt.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .elementAt(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-ignoreElements\"><a href=\"#5-ignoreElements\" class=\"headerlink\" title=\"5. ignoreElements\"></a>5. ignoreElements</h4><ul>\n<li>该操作符可以忽略掉所有的元素，只发出<code>error</code>或<code>completed</code>事件。</li>\n<li>如果我们并不关心<code>Observable</code>的任何元素，只想知道<code>Observable</code>在什么时候终止，那就可以使用<code>ignoreElements</code>操作符。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bcadae47ddc7f71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ignoreElements.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 4, 4, 5)</span><br><span class=\"line\">        .ignoreElements()</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-take\"><a href=\"#6-take\" class=\"headerlink\" title=\"6.take\"></a>6.take</h4><p>该方法实现仅发送<code>Observable</code>序列中的前<code>n</code>个事件，在满足数量之后会自动<code>.completed</code><br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ba890655a1787c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"take.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .take(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-takeLast\"><a href=\"#7-takeLast\" class=\"headerlink\" title=\"7. takeLast\"></a>7. takeLast</h4><p>该方法实现仅发送<code>Observable</code>序列中的后<code>n</code>个事件<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-3e60ff6e411e234c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"takeLast.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .takeLast(1)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-skip\"><a href=\"#8-skip\" class=\"headerlink\" title=\"8. skip\"></a>8. skip</h4><p>该方法用于跳过源<code>Observable</code>序列发出的前<code>n</code>个事件。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-439c4618a9901d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"skip.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4)</span><br><span class=\"line\">        .skip(2)</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"9-Sample\"><a href=\"#9-Sample\" class=\"headerlink\" title=\"9. Sample\"></a>9. Sample</h4><ul>\n<li><code>Sample</code>除了订阅源<code>Observable</code>外，还可以监视另外一个<code>Observable</code>， 即<code>notifier</code>。<br>每当收到<code>notifier</code>事件，就会从源序列取一个最新的事件并发送。而如果两次<code>notifier</code>事件之间没有源序列的事件，则不发送值。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-509212ce29f1c102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"sample.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">let source = PublishSubject&lt;Int&gt;()</span><br><span class=\"line\">let notifier = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">source.sample(notifier)</span><br><span class=\"line\">        .subscribe(onNext: &#123;print($0)&#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(1)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;A&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(2)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;B&quot;)</span><br><span class=\"line\">notifier.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(3)</span><br><span class=\"line\">source.onNext(4)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onNext(&quot;D&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">source.onNext(5)</span><br><span class=\"line\"></span><br><span class=\"line\">notifier.onCompleted()</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"10-debounce\"><a href=\"#10-debounce\" class=\"headerlink\" title=\"10. debounce\"></a>10. debounce</h4><ul>\n<li><code>debounce</code>操作符可以用来<em>过滤掉高频产生的元素</em>，它只会发出这种元素：该元素产生后，一段时间内没有新元素产生。</li>\n<li>换句话说就是，队列中的元素如果和下一个元素的间隔小于了指定的时间间隔，那么这个元素将被过滤掉。</li>\n<li><code>debounce</code>常用在<em>用户输入</em>的时候，不需要每个字母敲进去都发送一个事件，而是稍等一下取最后一个事件。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b313fa33f47012ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"debounce.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">//定义好每个事件里的值以及发送的时间</span><br><span class=\"line\">let times = [</span><br><span class=\"line\">[ &quot;value&quot;: 1, &quot;time&quot;: 0.1 ],</span><br><span class=\"line\">[ &quot;value&quot;: 2, &quot;time&quot;: 1.1 ],</span><br><span class=\"line\">[ &quot;value&quot;: 3, &quot;time&quot;: 1.2 ],</span><br><span class=\"line\">[ &quot;value&quot;: 4, &quot;time&quot;: 1.2 ],</span><br><span class=\"line\">[ &quot;value&quot;: 5, &quot;time&quot;: 1.4 ],</span><br><span class=\"line\">[ &quot;value&quot;: 6, &quot;time&quot;: 2.1 ]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">//生成对应的 Observable 序列并订阅</span><br><span class=\"line\">Observable.from(times)</span><br><span class=\"line\">        .flatMap &#123; item in</span><br><span class=\"line\">            return Observable.of(Int(item[&quot;value&quot;]!))</span><br><span class=\"line\">                            .delaySubscription(Double(item[&quot;time&quot;]!),scheduler: MainScheduler.instance)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        .debounce(0.5, scheduler: MainScheduler.instance) //只发出与下一个间隔超过0.5秒的元素</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n<p>运行结果……为啥我啥也没打印出来？？？<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bafa66b6f115f0c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"u=4240739968,2514380758&amp;fm=27&amp;gp=0.jpg\"><br>这个留在下回思考……<br>但据可靠信息，咳咳咳，打印出来的应该是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure></p>\n"},{"title":"swift 获取应用相关信息","date":"2018-12-10T05:33:10.000Z","_content":"有时我们在 App 中提交一些统计信息或者用户反馈信息时，为了能更好地进行分析，通常会附带上当前应用程序的名称、版本号、设备型号、以及设备系统版本。\n这一篇主要是记录一些自己遇到过或已知的方法，纯水文，没什么好讲的，直接展示代码：\n```\n//获取设备名称\nlet deviceName = UIDevice.current.name\nprint(\"deviceName:\\(deviceName)\")\n//获取系统名称\nlet sysName = UIDevice.current.systemName\nprint(\"sysName:\\(sysName)\")\n//获取系统版本\nlet sysVersion = UIDevice.current.systemVersion\nprint(\"sysVersion:\\(sysVersion)\")\n//获取设备唯一标识符\nlet deviceUUID = UIDevice.current.identifierForVendor?.uuidString\nprint(\"deviceUUID:\\(deviceUUID!)\")\n//获取设备的型号\nlet deviceModel = UIDevice.current.model\nprint(\"deviceModel:\\(deviceModel)\")\n//电池电量\n//UIDevice.current.isBatteryMonitoringEnabled 方法必须使用\nUIDevice.current.isBatteryMonitoringEnabled = true\nlet batteryLevel = UIDevice.current.batteryLevel\nprint(\"batteryLevel:\\(batteryLevel)\")\n//电池状态\nlet batteryState = UIDevice.current.batteryState\nswitch batteryState {\ncase .unknown: print(\"未识别\")\ncase .charging: print(\"充电中\")\ncase .full: print(\"充满状态\")\ncase .unplugged: print(\"非充电状态\")\n}\nUIDevice.current.isBatteryMonitoringEnabled = false\n\n\nlet infoDictionary = Bundle.main.infoDictionary!\n//app版本号\nif let appVersion = infoDictionary[\"CFBundleVersion\"]{\nprint(\"appVersion:\\(appVersion)\")\n}\n\n//app名称\nif let appName = infoDictionary[\"CFBundleDisplayName\"]{\nprint(\"appName:\\(appName)\")\n}\n\n//主程序版本号\nif let shortVersion = infoDictionary[\"CFBundleShortVersionString\"]{\nprint(\"shortVersion:\\(shortVersion)\")\n}\n```\n获取手机具体型号：\n```\nextension UIDevice{\nvar deviceName: String{\nvar systemInfo = utsname()\nuname(&systemInfo)\n\nlet platform = withUnsafePointer(to: &systemInfo.machine.0) { ptr in\nreturn String(cString: ptr)\n}\nswitch platform {\ncase \"iPhone3,1\", \"iPhone3,2\", \"iPhone3,3\":  return \"iPhone 4\"\ncase \"iPhone4,1\":  return \"iPhone 4s\"\ncase \"iPhone5,1\":  return \"iPhone 5\"\ncase \"iPhone5,2\":  return \"iPhone 5 (GSM+CDMA)\"\ncase \"iPhone5,3\":  return \"iPhone 5c (GSM)\"\ncase \"iPhone5,4\":  return \"iPhone 5c (GSM+CDMA)\"\ncase \"iPhone6,1\":  return \"iPhone 5s (GSM)\"\ncase \"iPhone6,2\":  return \"iPhone 5s (GSM+CDMA)\"\ncase \"iPhone7,2\":  return \"iPhone 6\"\ncase \"iPhone7,1\":  return \"iPhone 6 Plus\"\ncase \"iPhone8,1\":  return \"iPhone 6s\"\ncase \"iPhone8,2\":  return \"iPhone 6s Plus\"\ncase \"iPhone8,4\":  return \"iPhone SE\"\ncase \"iPhone9,1\":  return \"国行、日版、港行iPhone 7\"\ncase \"iPhone9,2\":  return \"港行、国行iPhone 7 Plus\"\ncase \"iPhone9,3\":  return \"美版、台版iPhone 7\"\ncase \"iPhone9,4\":  return \"美版、台版iPhone 7 Plus\"\ncase \"iPhone10,1\", \"iPhone10,4\":   return \"iPhone 8\"\ncase \"iPhone10,2\", \"iPhone10,5\":   return \"iPhone 8 Plus\"\ncase \"iPhone10,3\", \"iPhone10,6\":   return \"iPhone X\"\ncase \"iPhone11,2\":   return \"iPhone XS\"\ncase \"iPhone11,4\", \"iPhone11,6\":   return \"iPhone XS MAX\"\ncase \"iPhone11,8\":   return \"iPhone XR\"\n\n\ncase \"iPad1,1\":   return \"iPad\"\ncase \"iPad1,2\":   return \"iPad 3G\"\ncase \"iPad2,1\", \"iPad2,2\", \"iPad2,3\", \"iPad2,4\":   return \"iPad 2\"\ncase \"iPad2,5\", \"iPad2,6\", \"iPad2,7\":  return \"iPad Mini\"\ncase \"iPad3,1\", \"iPad3,2\", \"iPad3,3\":  return \"iPad 3\"\ncase \"iPad3,4\", \"iPad3,5\", \"iPad3,6\":  return \"iPad 4\"\ncase \"iPad4,1\", \"iPad4,2\", \"iPad4,3\":  return \"iPad Air\"\ncase \"iPad4,4\", \"iPad4,5\", \"iPad4,6\":  return \"iPad Mini 2\"\ncase \"iPad4,7\", \"iPad4,8\", \"iPad4,9\":  return \"iPad Mini 3\"\ncase \"iPad5,1\", \"iPad5,2\":  return \"iPad Mini 4\"\ncase \"iPad5,3\", \"iPad5,4\":  return \"iPad Air 2\"\ncase \"iPad6,3\", \"iPad6,4\":  return \"iPad Pro 9.7\"\ncase \"iPad6,7\", \"iPad6,8\":  return \"iPad Pro 12.9\"\ncase \"iPad6,11\", \"iPad6,12\":  return \"iPad 5\"\ncase \"iPad7,1\", \"iPad7,2\":   return \"iPad Pro 12.9-inch 2nd-gen\"\ncase \"iPad7,3\", \"iPad7,4\":   return \"iPad Pro 10.5\"\ncase \"iPad7,5\", \"iPad7,6\":   return \"iPad 6\"\n\n\ncase \"AppleTV2,1\":  return \"Apple TV 2\"\ncase \"AppleTV3,1\", \"AppleTV3,2\":  return \"Apple TV 3\"\ncase \"AppleTV5,3\":   return \"Apple TV 4\"\ncase \"i386\", \"x86_64\":   return \"Simulator\"\n\ncase \"iPod1,1\":  return \"iPod Touch 1\"\ncase \"iPod2,1\":  return \"iPod Touch 2\"\ncase \"iPod3,1\":  return \"iPod Touch 3\"\ncase \"iPod4,1\":  return \"iPod Touch 4\"\ncase \"iPod5,1\":  return \"iPod Touch (5 Gen)\"\ncase \"iPod7,1\":  return \"iPod Touch 6\"\n\ndefault:  return platform\n\n}\n\n}\n}\n```\n直接使用\n```\nUIDevice.current.deviceName\n```\n还有一些方法没有记下，日后遇到再补上。\n\n[demo地址](https://github.com/darren1192/DeviceInfoDemo)\n","source":"_posts/swift-获取应用相关信息.md","raw":"---\ntitle: swift 获取应用相关信息\ndate: 2018-12-10 13:33:10\ntags:\n---\n有时我们在 App 中提交一些统计信息或者用户反馈信息时，为了能更好地进行分析，通常会附带上当前应用程序的名称、版本号、设备型号、以及设备系统版本。\n这一篇主要是记录一些自己遇到过或已知的方法，纯水文，没什么好讲的，直接展示代码：\n```\n//获取设备名称\nlet deviceName = UIDevice.current.name\nprint(\"deviceName:\\(deviceName)\")\n//获取系统名称\nlet sysName = UIDevice.current.systemName\nprint(\"sysName:\\(sysName)\")\n//获取系统版本\nlet sysVersion = UIDevice.current.systemVersion\nprint(\"sysVersion:\\(sysVersion)\")\n//获取设备唯一标识符\nlet deviceUUID = UIDevice.current.identifierForVendor?.uuidString\nprint(\"deviceUUID:\\(deviceUUID!)\")\n//获取设备的型号\nlet deviceModel = UIDevice.current.model\nprint(\"deviceModel:\\(deviceModel)\")\n//电池电量\n//UIDevice.current.isBatteryMonitoringEnabled 方法必须使用\nUIDevice.current.isBatteryMonitoringEnabled = true\nlet batteryLevel = UIDevice.current.batteryLevel\nprint(\"batteryLevel:\\(batteryLevel)\")\n//电池状态\nlet batteryState = UIDevice.current.batteryState\nswitch batteryState {\ncase .unknown: print(\"未识别\")\ncase .charging: print(\"充电中\")\ncase .full: print(\"充满状态\")\ncase .unplugged: print(\"非充电状态\")\n}\nUIDevice.current.isBatteryMonitoringEnabled = false\n\n\nlet infoDictionary = Bundle.main.infoDictionary!\n//app版本号\nif let appVersion = infoDictionary[\"CFBundleVersion\"]{\nprint(\"appVersion:\\(appVersion)\")\n}\n\n//app名称\nif let appName = infoDictionary[\"CFBundleDisplayName\"]{\nprint(\"appName:\\(appName)\")\n}\n\n//主程序版本号\nif let shortVersion = infoDictionary[\"CFBundleShortVersionString\"]{\nprint(\"shortVersion:\\(shortVersion)\")\n}\n```\n获取手机具体型号：\n```\nextension UIDevice{\nvar deviceName: String{\nvar systemInfo = utsname()\nuname(&systemInfo)\n\nlet platform = withUnsafePointer(to: &systemInfo.machine.0) { ptr in\nreturn String(cString: ptr)\n}\nswitch platform {\ncase \"iPhone3,1\", \"iPhone3,2\", \"iPhone3,3\":  return \"iPhone 4\"\ncase \"iPhone4,1\":  return \"iPhone 4s\"\ncase \"iPhone5,1\":  return \"iPhone 5\"\ncase \"iPhone5,2\":  return \"iPhone 5 (GSM+CDMA)\"\ncase \"iPhone5,3\":  return \"iPhone 5c (GSM)\"\ncase \"iPhone5,4\":  return \"iPhone 5c (GSM+CDMA)\"\ncase \"iPhone6,1\":  return \"iPhone 5s (GSM)\"\ncase \"iPhone6,2\":  return \"iPhone 5s (GSM+CDMA)\"\ncase \"iPhone7,2\":  return \"iPhone 6\"\ncase \"iPhone7,1\":  return \"iPhone 6 Plus\"\ncase \"iPhone8,1\":  return \"iPhone 6s\"\ncase \"iPhone8,2\":  return \"iPhone 6s Plus\"\ncase \"iPhone8,4\":  return \"iPhone SE\"\ncase \"iPhone9,1\":  return \"国行、日版、港行iPhone 7\"\ncase \"iPhone9,2\":  return \"港行、国行iPhone 7 Plus\"\ncase \"iPhone9,3\":  return \"美版、台版iPhone 7\"\ncase \"iPhone9,4\":  return \"美版、台版iPhone 7 Plus\"\ncase \"iPhone10,1\", \"iPhone10,4\":   return \"iPhone 8\"\ncase \"iPhone10,2\", \"iPhone10,5\":   return \"iPhone 8 Plus\"\ncase \"iPhone10,3\", \"iPhone10,6\":   return \"iPhone X\"\ncase \"iPhone11,2\":   return \"iPhone XS\"\ncase \"iPhone11,4\", \"iPhone11,6\":   return \"iPhone XS MAX\"\ncase \"iPhone11,8\":   return \"iPhone XR\"\n\n\ncase \"iPad1,1\":   return \"iPad\"\ncase \"iPad1,2\":   return \"iPad 3G\"\ncase \"iPad2,1\", \"iPad2,2\", \"iPad2,3\", \"iPad2,4\":   return \"iPad 2\"\ncase \"iPad2,5\", \"iPad2,6\", \"iPad2,7\":  return \"iPad Mini\"\ncase \"iPad3,1\", \"iPad3,2\", \"iPad3,3\":  return \"iPad 3\"\ncase \"iPad3,4\", \"iPad3,5\", \"iPad3,6\":  return \"iPad 4\"\ncase \"iPad4,1\", \"iPad4,2\", \"iPad4,3\":  return \"iPad Air\"\ncase \"iPad4,4\", \"iPad4,5\", \"iPad4,6\":  return \"iPad Mini 2\"\ncase \"iPad4,7\", \"iPad4,8\", \"iPad4,9\":  return \"iPad Mini 3\"\ncase \"iPad5,1\", \"iPad5,2\":  return \"iPad Mini 4\"\ncase \"iPad5,3\", \"iPad5,4\":  return \"iPad Air 2\"\ncase \"iPad6,3\", \"iPad6,4\":  return \"iPad Pro 9.7\"\ncase \"iPad6,7\", \"iPad6,8\":  return \"iPad Pro 12.9\"\ncase \"iPad6,11\", \"iPad6,12\":  return \"iPad 5\"\ncase \"iPad7,1\", \"iPad7,2\":   return \"iPad Pro 12.9-inch 2nd-gen\"\ncase \"iPad7,3\", \"iPad7,4\":   return \"iPad Pro 10.5\"\ncase \"iPad7,5\", \"iPad7,6\":   return \"iPad 6\"\n\n\ncase \"AppleTV2,1\":  return \"Apple TV 2\"\ncase \"AppleTV3,1\", \"AppleTV3,2\":  return \"Apple TV 3\"\ncase \"AppleTV5,3\":   return \"Apple TV 4\"\ncase \"i386\", \"x86_64\":   return \"Simulator\"\n\ncase \"iPod1,1\":  return \"iPod Touch 1\"\ncase \"iPod2,1\":  return \"iPod Touch 2\"\ncase \"iPod3,1\":  return \"iPod Touch 3\"\ncase \"iPod4,1\":  return \"iPod Touch 4\"\ncase \"iPod5,1\":  return \"iPod Touch (5 Gen)\"\ncase \"iPod7,1\":  return \"iPod Touch 6\"\n\ndefault:  return platform\n\n}\n\n}\n}\n```\n直接使用\n```\nUIDevice.current.deviceName\n```\n还有一些方法没有记下，日后遇到再补上。\n\n[demo地址](https://github.com/darren1192/DeviceInfoDemo)\n","slug":"swift-获取应用相关信息","published":1,"updated":"2018-12-10T05:33:27.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxs7000d2ycwwdzshebh","content":"<p>有时我们在 App 中提交一些统计信息或者用户反馈信息时，为了能更好地进行分析，通常会附带上当前应用程序的名称、版本号、设备型号、以及设备系统版本。<br>这一篇主要是记录一些自己遇到过或已知的方法，纯水文，没什么好讲的，直接展示代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取设备名称</span><br><span class=\"line\">let deviceName = UIDevice.current.name</span><br><span class=\"line\">print(&quot;deviceName:\\(deviceName)&quot;)</span><br><span class=\"line\">//获取系统名称</span><br><span class=\"line\">let sysName = UIDevice.current.systemName</span><br><span class=\"line\">print(&quot;sysName:\\(sysName)&quot;)</span><br><span class=\"line\">//获取系统版本</span><br><span class=\"line\">let sysVersion = UIDevice.current.systemVersion</span><br><span class=\"line\">print(&quot;sysVersion:\\(sysVersion)&quot;)</span><br><span class=\"line\">//获取设备唯一标识符</span><br><span class=\"line\">let deviceUUID = UIDevice.current.identifierForVendor?.uuidString</span><br><span class=\"line\">print(&quot;deviceUUID:\\(deviceUUID!)&quot;)</span><br><span class=\"line\">//获取设备的型号</span><br><span class=\"line\">let deviceModel = UIDevice.current.model</span><br><span class=\"line\">print(&quot;deviceModel:\\(deviceModel)&quot;)</span><br><span class=\"line\">//电池电量</span><br><span class=\"line\">//UIDevice.current.isBatteryMonitoringEnabled 方法必须使用</span><br><span class=\"line\">UIDevice.current.isBatteryMonitoringEnabled = true</span><br><span class=\"line\">let batteryLevel = UIDevice.current.batteryLevel</span><br><span class=\"line\">print(&quot;batteryLevel:\\(batteryLevel)&quot;)</span><br><span class=\"line\">//电池状态</span><br><span class=\"line\">let batteryState = UIDevice.current.batteryState</span><br><span class=\"line\">switch batteryState &#123;</span><br><span class=\"line\">case .unknown: print(&quot;未识别&quot;)</span><br><span class=\"line\">case .charging: print(&quot;充电中&quot;)</span><br><span class=\"line\">case .full: print(&quot;充满状态&quot;)</span><br><span class=\"line\">case .unplugged: print(&quot;非充电状态&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">UIDevice.current.isBatteryMonitoringEnabled = false</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">let infoDictionary = Bundle.main.infoDictionary!</span><br><span class=\"line\">//app版本号</span><br><span class=\"line\">if let appVersion = infoDictionary[&quot;CFBundleVersion&quot;]&#123;</span><br><span class=\"line\">print(&quot;appVersion:\\(appVersion)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//app名称</span><br><span class=\"line\">if let appName = infoDictionary[&quot;CFBundleDisplayName&quot;]&#123;</span><br><span class=\"line\">print(&quot;appName:\\(appName)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//主程序版本号</span><br><span class=\"line\">if let shortVersion = infoDictionary[&quot;CFBundleShortVersionString&quot;]&#123;</span><br><span class=\"line\">print(&quot;shortVersion:\\(shortVersion)&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取手机具体型号：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension UIDevice&#123;</span><br><span class=\"line\">var deviceName: String&#123;</span><br><span class=\"line\">var systemInfo = utsname()</span><br><span class=\"line\">uname(&amp;systemInfo)</span><br><span class=\"line\"></span><br><span class=\"line\">let platform = withUnsafePointer(to: &amp;systemInfo.machine.0) &#123; ptr in</span><br><span class=\"line\">return String(cString: ptr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">switch platform &#123;</span><br><span class=\"line\">case &quot;iPhone3,1&quot;, &quot;iPhone3,2&quot;, &quot;iPhone3,3&quot;:  return &quot;iPhone 4&quot;</span><br><span class=\"line\">case &quot;iPhone4,1&quot;:  return &quot;iPhone 4s&quot;</span><br><span class=\"line\">case &quot;iPhone5,1&quot;:  return &quot;iPhone 5&quot;</span><br><span class=\"line\">case &quot;iPhone5,2&quot;:  return &quot;iPhone 5 (GSM+CDMA)&quot;</span><br><span class=\"line\">case &quot;iPhone5,3&quot;:  return &quot;iPhone 5c (GSM)&quot;</span><br><span class=\"line\">case &quot;iPhone5,4&quot;:  return &quot;iPhone 5c (GSM+CDMA)&quot;</span><br><span class=\"line\">case &quot;iPhone6,1&quot;:  return &quot;iPhone 5s (GSM)&quot;</span><br><span class=\"line\">case &quot;iPhone6,2&quot;:  return &quot;iPhone 5s (GSM+CDMA)&quot;</span><br><span class=\"line\">case &quot;iPhone7,2&quot;:  return &quot;iPhone 6&quot;</span><br><span class=\"line\">case &quot;iPhone7,1&quot;:  return &quot;iPhone 6 Plus&quot;</span><br><span class=\"line\">case &quot;iPhone8,1&quot;:  return &quot;iPhone 6s&quot;</span><br><span class=\"line\">case &quot;iPhone8,2&quot;:  return &quot;iPhone 6s Plus&quot;</span><br><span class=\"line\">case &quot;iPhone8,4&quot;:  return &quot;iPhone SE&quot;</span><br><span class=\"line\">case &quot;iPhone9,1&quot;:  return &quot;国行、日版、港行iPhone 7&quot;</span><br><span class=\"line\">case &quot;iPhone9,2&quot;:  return &quot;港行、国行iPhone 7 Plus&quot;</span><br><span class=\"line\">case &quot;iPhone9,3&quot;:  return &quot;美版、台版iPhone 7&quot;</span><br><span class=\"line\">case &quot;iPhone9,4&quot;:  return &quot;美版、台版iPhone 7 Plus&quot;</span><br><span class=\"line\">case &quot;iPhone10,1&quot;, &quot;iPhone10,4&quot;:   return &quot;iPhone 8&quot;</span><br><span class=\"line\">case &quot;iPhone10,2&quot;, &quot;iPhone10,5&quot;:   return &quot;iPhone 8 Plus&quot;</span><br><span class=\"line\">case &quot;iPhone10,3&quot;, &quot;iPhone10,6&quot;:   return &quot;iPhone X&quot;</span><br><span class=\"line\">case &quot;iPhone11,2&quot;:   return &quot;iPhone XS&quot;</span><br><span class=\"line\">case &quot;iPhone11,4&quot;, &quot;iPhone11,6&quot;:   return &quot;iPhone XS MAX&quot;</span><br><span class=\"line\">case &quot;iPhone11,8&quot;:   return &quot;iPhone XR&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">case &quot;iPad1,1&quot;:   return &quot;iPad&quot;</span><br><span class=\"line\">case &quot;iPad1,2&quot;:   return &quot;iPad 3G&quot;</span><br><span class=\"line\">case &quot;iPad2,1&quot;, &quot;iPad2,2&quot;, &quot;iPad2,3&quot;, &quot;iPad2,4&quot;:   return &quot;iPad 2&quot;</span><br><span class=\"line\">case &quot;iPad2,5&quot;, &quot;iPad2,6&quot;, &quot;iPad2,7&quot;:  return &quot;iPad Mini&quot;</span><br><span class=\"line\">case &quot;iPad3,1&quot;, &quot;iPad3,2&quot;, &quot;iPad3,3&quot;:  return &quot;iPad 3&quot;</span><br><span class=\"line\">case &quot;iPad3,4&quot;, &quot;iPad3,5&quot;, &quot;iPad3,6&quot;:  return &quot;iPad 4&quot;</span><br><span class=\"line\">case &quot;iPad4,1&quot;, &quot;iPad4,2&quot;, &quot;iPad4,3&quot;:  return &quot;iPad Air&quot;</span><br><span class=\"line\">case &quot;iPad4,4&quot;, &quot;iPad4,5&quot;, &quot;iPad4,6&quot;:  return &quot;iPad Mini 2&quot;</span><br><span class=\"line\">case &quot;iPad4,7&quot;, &quot;iPad4,8&quot;, &quot;iPad4,9&quot;:  return &quot;iPad Mini 3&quot;</span><br><span class=\"line\">case &quot;iPad5,1&quot;, &quot;iPad5,2&quot;:  return &quot;iPad Mini 4&quot;</span><br><span class=\"line\">case &quot;iPad5,3&quot;, &quot;iPad5,4&quot;:  return &quot;iPad Air 2&quot;</span><br><span class=\"line\">case &quot;iPad6,3&quot;, &quot;iPad6,4&quot;:  return &quot;iPad Pro 9.7&quot;</span><br><span class=\"line\">case &quot;iPad6,7&quot;, &quot;iPad6,8&quot;:  return &quot;iPad Pro 12.9&quot;</span><br><span class=\"line\">case &quot;iPad6,11&quot;, &quot;iPad6,12&quot;:  return &quot;iPad 5&quot;</span><br><span class=\"line\">case &quot;iPad7,1&quot;, &quot;iPad7,2&quot;:   return &quot;iPad Pro 12.9-inch 2nd-gen&quot;</span><br><span class=\"line\">case &quot;iPad7,3&quot;, &quot;iPad7,4&quot;:   return &quot;iPad Pro 10.5&quot;</span><br><span class=\"line\">case &quot;iPad7,5&quot;, &quot;iPad7,6&quot;:   return &quot;iPad 6&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">case &quot;AppleTV2,1&quot;:  return &quot;Apple TV 2&quot;</span><br><span class=\"line\">case &quot;AppleTV3,1&quot;, &quot;AppleTV3,2&quot;:  return &quot;Apple TV 3&quot;</span><br><span class=\"line\">case &quot;AppleTV5,3&quot;:   return &quot;Apple TV 4&quot;</span><br><span class=\"line\">case &quot;i386&quot;, &quot;x86_64&quot;:   return &quot;Simulator&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">case &quot;iPod1,1&quot;:  return &quot;iPod Touch 1&quot;</span><br><span class=\"line\">case &quot;iPod2,1&quot;:  return &quot;iPod Touch 2&quot;</span><br><span class=\"line\">case &quot;iPod3,1&quot;:  return &quot;iPod Touch 3&quot;</span><br><span class=\"line\">case &quot;iPod4,1&quot;:  return &quot;iPod Touch 4&quot;</span><br><span class=\"line\">case &quot;iPod5,1&quot;:  return &quot;iPod Touch (5 Gen)&quot;</span><br><span class=\"line\">case &quot;iPod7,1&quot;:  return &quot;iPod Touch 6&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">default:  return platform</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>直接使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIDevice.current.deviceName</span><br></pre></td></tr></table></figure></p>\n<p>还有一些方法没有记下，日后遇到再补上。</p>\n<p><a href=\"https://github.com/darren1192/DeviceInfoDemo\" target=\"_blank\" rel=\"noopener\">demo地址</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>有时我们在 App 中提交一些统计信息或者用户反馈信息时，为了能更好地进行分析，通常会附带上当前应用程序的名称、版本号、设备型号、以及设备系统版本。<br>这一篇主要是记录一些自己遇到过或已知的方法，纯水文，没什么好讲的，直接展示代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取设备名称</span><br><span class=\"line\">let deviceName = UIDevice.current.name</span><br><span class=\"line\">print(&quot;deviceName:\\(deviceName)&quot;)</span><br><span class=\"line\">//获取系统名称</span><br><span class=\"line\">let sysName = UIDevice.current.systemName</span><br><span class=\"line\">print(&quot;sysName:\\(sysName)&quot;)</span><br><span class=\"line\">//获取系统版本</span><br><span class=\"line\">let sysVersion = UIDevice.current.systemVersion</span><br><span class=\"line\">print(&quot;sysVersion:\\(sysVersion)&quot;)</span><br><span class=\"line\">//获取设备唯一标识符</span><br><span class=\"line\">let deviceUUID = UIDevice.current.identifierForVendor?.uuidString</span><br><span class=\"line\">print(&quot;deviceUUID:\\(deviceUUID!)&quot;)</span><br><span class=\"line\">//获取设备的型号</span><br><span class=\"line\">let deviceModel = UIDevice.current.model</span><br><span class=\"line\">print(&quot;deviceModel:\\(deviceModel)&quot;)</span><br><span class=\"line\">//电池电量</span><br><span class=\"line\">//UIDevice.current.isBatteryMonitoringEnabled 方法必须使用</span><br><span class=\"line\">UIDevice.current.isBatteryMonitoringEnabled = true</span><br><span class=\"line\">let batteryLevel = UIDevice.current.batteryLevel</span><br><span class=\"line\">print(&quot;batteryLevel:\\(batteryLevel)&quot;)</span><br><span class=\"line\">//电池状态</span><br><span class=\"line\">let batteryState = UIDevice.current.batteryState</span><br><span class=\"line\">switch batteryState &#123;</span><br><span class=\"line\">case .unknown: print(&quot;未识别&quot;)</span><br><span class=\"line\">case .charging: print(&quot;充电中&quot;)</span><br><span class=\"line\">case .full: print(&quot;充满状态&quot;)</span><br><span class=\"line\">case .unplugged: print(&quot;非充电状态&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">UIDevice.current.isBatteryMonitoringEnabled = false</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">let infoDictionary = Bundle.main.infoDictionary!</span><br><span class=\"line\">//app版本号</span><br><span class=\"line\">if let appVersion = infoDictionary[&quot;CFBundleVersion&quot;]&#123;</span><br><span class=\"line\">print(&quot;appVersion:\\(appVersion)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//app名称</span><br><span class=\"line\">if let appName = infoDictionary[&quot;CFBundleDisplayName&quot;]&#123;</span><br><span class=\"line\">print(&quot;appName:\\(appName)&quot;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//主程序版本号</span><br><span class=\"line\">if let shortVersion = infoDictionary[&quot;CFBundleShortVersionString&quot;]&#123;</span><br><span class=\"line\">print(&quot;shortVersion:\\(shortVersion)&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取手机具体型号：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension UIDevice&#123;</span><br><span class=\"line\">var deviceName: String&#123;</span><br><span class=\"line\">var systemInfo = utsname()</span><br><span class=\"line\">uname(&amp;systemInfo)</span><br><span class=\"line\"></span><br><span class=\"line\">let platform = withUnsafePointer(to: &amp;systemInfo.machine.0) &#123; ptr in</span><br><span class=\"line\">return String(cString: ptr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">switch platform &#123;</span><br><span class=\"line\">case &quot;iPhone3,1&quot;, &quot;iPhone3,2&quot;, &quot;iPhone3,3&quot;:  return &quot;iPhone 4&quot;</span><br><span class=\"line\">case &quot;iPhone4,1&quot;:  return &quot;iPhone 4s&quot;</span><br><span class=\"line\">case &quot;iPhone5,1&quot;:  return &quot;iPhone 5&quot;</span><br><span class=\"line\">case &quot;iPhone5,2&quot;:  return &quot;iPhone 5 (GSM+CDMA)&quot;</span><br><span class=\"line\">case &quot;iPhone5,3&quot;:  return &quot;iPhone 5c (GSM)&quot;</span><br><span class=\"line\">case &quot;iPhone5,4&quot;:  return &quot;iPhone 5c (GSM+CDMA)&quot;</span><br><span class=\"line\">case &quot;iPhone6,1&quot;:  return &quot;iPhone 5s (GSM)&quot;</span><br><span class=\"line\">case &quot;iPhone6,2&quot;:  return &quot;iPhone 5s (GSM+CDMA)&quot;</span><br><span class=\"line\">case &quot;iPhone7,2&quot;:  return &quot;iPhone 6&quot;</span><br><span class=\"line\">case &quot;iPhone7,1&quot;:  return &quot;iPhone 6 Plus&quot;</span><br><span class=\"line\">case &quot;iPhone8,1&quot;:  return &quot;iPhone 6s&quot;</span><br><span class=\"line\">case &quot;iPhone8,2&quot;:  return &quot;iPhone 6s Plus&quot;</span><br><span class=\"line\">case &quot;iPhone8,4&quot;:  return &quot;iPhone SE&quot;</span><br><span class=\"line\">case &quot;iPhone9,1&quot;:  return &quot;国行、日版、港行iPhone 7&quot;</span><br><span class=\"line\">case &quot;iPhone9,2&quot;:  return &quot;港行、国行iPhone 7 Plus&quot;</span><br><span class=\"line\">case &quot;iPhone9,3&quot;:  return &quot;美版、台版iPhone 7&quot;</span><br><span class=\"line\">case &quot;iPhone9,4&quot;:  return &quot;美版、台版iPhone 7 Plus&quot;</span><br><span class=\"line\">case &quot;iPhone10,1&quot;, &quot;iPhone10,4&quot;:   return &quot;iPhone 8&quot;</span><br><span class=\"line\">case &quot;iPhone10,2&quot;, &quot;iPhone10,5&quot;:   return &quot;iPhone 8 Plus&quot;</span><br><span class=\"line\">case &quot;iPhone10,3&quot;, &quot;iPhone10,6&quot;:   return &quot;iPhone X&quot;</span><br><span class=\"line\">case &quot;iPhone11,2&quot;:   return &quot;iPhone XS&quot;</span><br><span class=\"line\">case &quot;iPhone11,4&quot;, &quot;iPhone11,6&quot;:   return &quot;iPhone XS MAX&quot;</span><br><span class=\"line\">case &quot;iPhone11,8&quot;:   return &quot;iPhone XR&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">case &quot;iPad1,1&quot;:   return &quot;iPad&quot;</span><br><span class=\"line\">case &quot;iPad1,2&quot;:   return &quot;iPad 3G&quot;</span><br><span class=\"line\">case &quot;iPad2,1&quot;, &quot;iPad2,2&quot;, &quot;iPad2,3&quot;, &quot;iPad2,4&quot;:   return &quot;iPad 2&quot;</span><br><span class=\"line\">case &quot;iPad2,5&quot;, &quot;iPad2,6&quot;, &quot;iPad2,7&quot;:  return &quot;iPad Mini&quot;</span><br><span class=\"line\">case &quot;iPad3,1&quot;, &quot;iPad3,2&quot;, &quot;iPad3,3&quot;:  return &quot;iPad 3&quot;</span><br><span class=\"line\">case &quot;iPad3,4&quot;, &quot;iPad3,5&quot;, &quot;iPad3,6&quot;:  return &quot;iPad 4&quot;</span><br><span class=\"line\">case &quot;iPad4,1&quot;, &quot;iPad4,2&quot;, &quot;iPad4,3&quot;:  return &quot;iPad Air&quot;</span><br><span class=\"line\">case &quot;iPad4,4&quot;, &quot;iPad4,5&quot;, &quot;iPad4,6&quot;:  return &quot;iPad Mini 2&quot;</span><br><span class=\"line\">case &quot;iPad4,7&quot;, &quot;iPad4,8&quot;, &quot;iPad4,9&quot;:  return &quot;iPad Mini 3&quot;</span><br><span class=\"line\">case &quot;iPad5,1&quot;, &quot;iPad5,2&quot;:  return &quot;iPad Mini 4&quot;</span><br><span class=\"line\">case &quot;iPad5,3&quot;, &quot;iPad5,4&quot;:  return &quot;iPad Air 2&quot;</span><br><span class=\"line\">case &quot;iPad6,3&quot;, &quot;iPad6,4&quot;:  return &quot;iPad Pro 9.7&quot;</span><br><span class=\"line\">case &quot;iPad6,7&quot;, &quot;iPad6,8&quot;:  return &quot;iPad Pro 12.9&quot;</span><br><span class=\"line\">case &quot;iPad6,11&quot;, &quot;iPad6,12&quot;:  return &quot;iPad 5&quot;</span><br><span class=\"line\">case &quot;iPad7,1&quot;, &quot;iPad7,2&quot;:   return &quot;iPad Pro 12.9-inch 2nd-gen&quot;</span><br><span class=\"line\">case &quot;iPad7,3&quot;, &quot;iPad7,4&quot;:   return &quot;iPad Pro 10.5&quot;</span><br><span class=\"line\">case &quot;iPad7,5&quot;, &quot;iPad7,6&quot;:   return &quot;iPad 6&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">case &quot;AppleTV2,1&quot;:  return &quot;Apple TV 2&quot;</span><br><span class=\"line\">case &quot;AppleTV3,1&quot;, &quot;AppleTV3,2&quot;:  return &quot;Apple TV 3&quot;</span><br><span class=\"line\">case &quot;AppleTV5,3&quot;:   return &quot;Apple TV 4&quot;</span><br><span class=\"line\">case &quot;i386&quot;, &quot;x86_64&quot;:   return &quot;Simulator&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">case &quot;iPod1,1&quot;:  return &quot;iPod Touch 1&quot;</span><br><span class=\"line\">case &quot;iPod2,1&quot;:  return &quot;iPod Touch 2&quot;</span><br><span class=\"line\">case &quot;iPod3,1&quot;:  return &quot;iPod Touch 3&quot;</span><br><span class=\"line\">case &quot;iPod4,1&quot;:  return &quot;iPod Touch 4&quot;</span><br><span class=\"line\">case &quot;iPod5,1&quot;:  return &quot;iPod Touch (5 Gen)&quot;</span><br><span class=\"line\">case &quot;iPod7,1&quot;:  return &quot;iPod Touch 6&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">default:  return platform</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>直接使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIDevice.current.deviceName</span><br></pre></td></tr></table></figure></p>\n<p>还有一些方法没有记下，日后遇到再补上。</p>\n<p><a href=\"https://github.com/darren1192/DeviceInfoDemo\" target=\"_blank\" rel=\"noopener\">demo地址</a></p>\n"},{"title":"一张图片引发的思考","date":"2018-10-18T06:09:38.000Z","_content":"## 背景：\n前段时间做微信小程序分享，用了某家的SDK，然鹅......他们家SDK只能上传`png`、`jpeg`格式的图片，微信不是可以上传`Data`吗？？？？\n![???.jpeg](https://upload-images.jianshu.io/upload_images/2855070-1e640864e3ce90f4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我吭哧吭哧半天用`UIImageJPEGRepresentation`压缩图片，然后在生成图片，也没把图片传上去。我当时想肯定是图片大小有问题，因为微信限制128KB以内。我查看保存在沙盒里的图片才32KB啊？？怎么会上传不上去呢？再查看`Image`的`Data`大小，噗~~~168KB。好吧，我被打败了。最后还是用微信原生SDK才搞定，直接传一个`Data`过去，多开心，多easy。\n## 正文\n好的，扯了这么多，其实就是想说一下为啥会有今天这篇大水文。在解决问题的过程中，我对iOS加载图片的理解稍微深入了那么一丢丢。现在，就水一下我理解的那么一丢丢东西。\n### 图片经过哪些流程加载到屏幕上\n1. 从磁盘拷贝数据到内核缓冲区\n2. 从内核缓冲区复制数据到用户空间（内存级别拷贝）\n3. 生成`UIImage`，把`UIImage`赋值给`UIImageView`\n4. 如果图像数据为未解码的PNG/JPG，解码为位图数据\n5. 隐式`CATransaction`捕获到`UIImageView`图层树的变化\n6. 主线程`Runloop`提交`CATransaction`，开始进行图像渲染\n6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐\n6.2 GPU处理位图数据，进行渲染\n\n其中第四点就是导致我32KB变168KB的“罪魁祸首”。为啥这么说呢？先了解一些东西。\n\n### PNG\n`PNG`只支持无损压缩，所以它的压缩比是有上限的。它有`alpha`通道，支持图片透明。此外xcode会对png格式进行特殊的优化处理，而对于其他图片不做处理，所以我们一些小图标经常用`PNG`。\n### JPEG\n`JPEG`支持有损压缩，不含有`alpha`通道，它可以通过图片质量换取内存空间。网络图片最好选用`JPEG`，可以节省流量、提高下载速度。\n### 位图\n我们是否可以直接使用图片，使其显示在屏幕上呢？答案显然后__不可以__。图片经过解压后，变成位图数据。那么[位图](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3)是什么呢?苹果给出的解释是\n> A bitmap image (or sampled image) is an array of pixels (or samples)\n\n位图是一个像素数组。至于怎么将像素绘制到屏幕上，可以看[这篇文章](https://objccn.io/issue-3-1/)，就不做过多叙述（人家说的很明白）。\n### 解码\n解码其实就是将图片的二进制数据转换成像素数据。这个过程是比较耗时的，不能使用 GPU 硬解码，只能通过 CPU 软解码实现（硬解码是通过解码电路实现，软解码是通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码）。解码后的文件大小计算公式\n```\n 解压缩后的图片大小 = 图片的像素宽 * 图片的像素高 * 每个像素所占的字节数 (4)\n```\n\n每个像素所占的字节数为什么是4呢？因为我们所使用的位图大部分是32位的RGBA模式，这种模式位图的一个像素所占内存为32位，也就是4个字节的长度 。[出处在此](https://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use)\n所以，本地保存的32KB的图片，解码就是168KB了。（解压缩后的数据）\n![恍然大悟.jpg](https://upload-images.jianshu.io/upload_images/2855070-2e399ff3e5457a17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 压缩图片\n不过分享某一张图片的时候，我用`UIImageJPEGRepresentation`方法压缩不到128KB一下？？？什么图片这么大？后来问一下后台才知道，这张图片是相机拍摄的，尺寸非常大，只能重新设置图片尺寸。献上我的代码\n```\n\nfunc compressImage(_ image: UIImage, toByte maxLength: Int) -> Data?{\n    var compression: CGFloat = 1\n\n    var data = UIImageJPEGRepresentation(image, compression)!\n        if data.count <= maxLength {\n        return data\n    }\n\n    var max: CGFloat = 1\n    var min: CGFloat = 0\n\n    let newSize = CGSize.init(width: 200, height: 160)\n    UIGraphicsBeginImageContext(newSize)\n    image.draw(in: CGRect.init(x: 0, y: 0, width: newSize.width, height: newSize.height))\n    let newImage = UIGraphicsGetImageFromCurrentImageContext()!\n    UIGraphicsEndImageContext()\n    data = UIImageJPEGRepresentation(newImage, 1.0)!\n    if data.count <= maxLength {\n        return data\n    }\n\n    for _ in 0..<10 {\n        compression = (max + min) / 2\n        data = UIImageJPEGRepresentation(newImage, compression)!\n\n        if CGFloat(data.count) < CGFloat(maxLength) * 0.9 {\n            min = compression\n        } else if data.count > maxLength {\n            max = compression\n        } else {\n            break\n        }\n    }\n\n    return data\n}\n\n```\n## 图片加载\n通常我们说图片加载会用到两种方法：`imageNamed `、`imageWithContentsOfFile `，我们简单介绍这两种方法\n### imageNamed\n该方法的特点在于可以缓存已经加载的图片；使用时，先根据文件名在系统缓存中寻找图片，如果找到了就返回；如果没有，就在`Bundle`内查找到文件名，找到后把这个文件名放到`UIImage`里返回，并没有进行实际的文件读取和解码。当`UIImage`第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。\n### imageWithContentsOfFile\n该方法仅加载图片，不缓存图像数据，其解码依然要等到第一次显示该图片的时候。\n对于这两种方法，我们可以做出如下比较：\n- 本地（Assets）保存的图标加载使用`imageNamed`\n- 经常使用且文件不大的图片使用`imageNamed`\n- 对于一些文件较大的图片使用`imageWithContentsOfFile`，当然最好的办法是用`UIGraphicsBeginImageContext`方法重新绘制图片\n\n此外，在 WWDC 2018上，苹果为我们建议了一种大家平时使用较少的大图加载方式，它的实际占用内存与理论值最为接近。\n```\nfunc downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -> UIImage\n{\n    let sourceOpt = [kCGImageSourceShouldCache : false] as  CFDictionary\n// 其他场景可以用createwithdata (data并未decode,所占内存没那么大),\n    let source = CGImageSourceCreateWithURL(imageURL as CFURL, sourceOpt)!\n\n    let maxDimension = max(pointSize.width, pointSize.height) * scale\n    let downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : true,\n                         kCGImageSourceShouldCacheImmediately : true ,\n                         kCGImageSourceCreateThumbnailWithTransform : true,\n                         kCGImageSourceThumbnailMaxPixelSize : maxDimension] as CFDictionary\n    let downsampleImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOpt)!\n    return UIImage(cgImage: downsampleImage)\n}\n```\n## 参考\n[iOS图片加载速度极限优化—FastImageCache解析](http://blog.cnbang.net/tech/2578/)\n[谈谈 iOS 中图片的解压缩](http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina)\n[iOS中的图片使用方式、内存对比和最佳实践](https://juejin.im/post/5b2ddfa7e51d4553156be305)\n\n\n\n\n\n","source":"_posts/一张图片引发的思考.md","raw":"---\ntitle: 一张图片引发的思考\ndate: 2018-10-18 14:09:38\ntags: 其它\n---\n## 背景：\n前段时间做微信小程序分享，用了某家的SDK，然鹅......他们家SDK只能上传`png`、`jpeg`格式的图片，微信不是可以上传`Data`吗？？？？\n![???.jpeg](https://upload-images.jianshu.io/upload_images/2855070-1e640864e3ce90f4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我吭哧吭哧半天用`UIImageJPEGRepresentation`压缩图片，然后在生成图片，也没把图片传上去。我当时想肯定是图片大小有问题，因为微信限制128KB以内。我查看保存在沙盒里的图片才32KB啊？？怎么会上传不上去呢？再查看`Image`的`Data`大小，噗~~~168KB。好吧，我被打败了。最后还是用微信原生SDK才搞定，直接传一个`Data`过去，多开心，多easy。\n## 正文\n好的，扯了这么多，其实就是想说一下为啥会有今天这篇大水文。在解决问题的过程中，我对iOS加载图片的理解稍微深入了那么一丢丢。现在，就水一下我理解的那么一丢丢东西。\n### 图片经过哪些流程加载到屏幕上\n1. 从磁盘拷贝数据到内核缓冲区\n2. 从内核缓冲区复制数据到用户空间（内存级别拷贝）\n3. 生成`UIImage`，把`UIImage`赋值给`UIImageView`\n4. 如果图像数据为未解码的PNG/JPG，解码为位图数据\n5. 隐式`CATransaction`捕获到`UIImageView`图层树的变化\n6. 主线程`Runloop`提交`CATransaction`，开始进行图像渲染\n6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐\n6.2 GPU处理位图数据，进行渲染\n\n其中第四点就是导致我32KB变168KB的“罪魁祸首”。为啥这么说呢？先了解一些东西。\n\n### PNG\n`PNG`只支持无损压缩，所以它的压缩比是有上限的。它有`alpha`通道，支持图片透明。此外xcode会对png格式进行特殊的优化处理，而对于其他图片不做处理，所以我们一些小图标经常用`PNG`。\n### JPEG\n`JPEG`支持有损压缩，不含有`alpha`通道，它可以通过图片质量换取内存空间。网络图片最好选用`JPEG`，可以节省流量、提高下载速度。\n### 位图\n我们是否可以直接使用图片，使其显示在屏幕上呢？答案显然后__不可以__。图片经过解压后，变成位图数据。那么[位图](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3)是什么呢?苹果给出的解释是\n> A bitmap image (or sampled image) is an array of pixels (or samples)\n\n位图是一个像素数组。至于怎么将像素绘制到屏幕上，可以看[这篇文章](https://objccn.io/issue-3-1/)，就不做过多叙述（人家说的很明白）。\n### 解码\n解码其实就是将图片的二进制数据转换成像素数据。这个过程是比较耗时的，不能使用 GPU 硬解码，只能通过 CPU 软解码实现（硬解码是通过解码电路实现，软解码是通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码）。解码后的文件大小计算公式\n```\n 解压缩后的图片大小 = 图片的像素宽 * 图片的像素高 * 每个像素所占的字节数 (4)\n```\n\n每个像素所占的字节数为什么是4呢？因为我们所使用的位图大部分是32位的RGBA模式，这种模式位图的一个像素所占内存为32位，也就是4个字节的长度 。[出处在此](https://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use)\n所以，本地保存的32KB的图片，解码就是168KB了。（解压缩后的数据）\n![恍然大悟.jpg](https://upload-images.jianshu.io/upload_images/2855070-2e399ff3e5457a17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 压缩图片\n不过分享某一张图片的时候，我用`UIImageJPEGRepresentation`方法压缩不到128KB一下？？？什么图片这么大？后来问一下后台才知道，这张图片是相机拍摄的，尺寸非常大，只能重新设置图片尺寸。献上我的代码\n```\n\nfunc compressImage(_ image: UIImage, toByte maxLength: Int) -> Data?{\n    var compression: CGFloat = 1\n\n    var data = UIImageJPEGRepresentation(image, compression)!\n        if data.count <= maxLength {\n        return data\n    }\n\n    var max: CGFloat = 1\n    var min: CGFloat = 0\n\n    let newSize = CGSize.init(width: 200, height: 160)\n    UIGraphicsBeginImageContext(newSize)\n    image.draw(in: CGRect.init(x: 0, y: 0, width: newSize.width, height: newSize.height))\n    let newImage = UIGraphicsGetImageFromCurrentImageContext()!\n    UIGraphicsEndImageContext()\n    data = UIImageJPEGRepresentation(newImage, 1.0)!\n    if data.count <= maxLength {\n        return data\n    }\n\n    for _ in 0..<10 {\n        compression = (max + min) / 2\n        data = UIImageJPEGRepresentation(newImage, compression)!\n\n        if CGFloat(data.count) < CGFloat(maxLength) * 0.9 {\n            min = compression\n        } else if data.count > maxLength {\n            max = compression\n        } else {\n            break\n        }\n    }\n\n    return data\n}\n\n```\n## 图片加载\n通常我们说图片加载会用到两种方法：`imageNamed `、`imageWithContentsOfFile `，我们简单介绍这两种方法\n### imageNamed\n该方法的特点在于可以缓存已经加载的图片；使用时，先根据文件名在系统缓存中寻找图片，如果找到了就返回；如果没有，就在`Bundle`内查找到文件名，找到后把这个文件名放到`UIImage`里返回，并没有进行实际的文件读取和解码。当`UIImage`第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。\n### imageWithContentsOfFile\n该方法仅加载图片，不缓存图像数据，其解码依然要等到第一次显示该图片的时候。\n对于这两种方法，我们可以做出如下比较：\n- 本地（Assets）保存的图标加载使用`imageNamed`\n- 经常使用且文件不大的图片使用`imageNamed`\n- 对于一些文件较大的图片使用`imageWithContentsOfFile`，当然最好的办法是用`UIGraphicsBeginImageContext`方法重新绘制图片\n\n此外，在 WWDC 2018上，苹果为我们建议了一种大家平时使用较少的大图加载方式，它的实际占用内存与理论值最为接近。\n```\nfunc downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -> UIImage\n{\n    let sourceOpt = [kCGImageSourceShouldCache : false] as  CFDictionary\n// 其他场景可以用createwithdata (data并未decode,所占内存没那么大),\n    let source = CGImageSourceCreateWithURL(imageURL as CFURL, sourceOpt)!\n\n    let maxDimension = max(pointSize.width, pointSize.height) * scale\n    let downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : true,\n                         kCGImageSourceShouldCacheImmediately : true ,\n                         kCGImageSourceCreateThumbnailWithTransform : true,\n                         kCGImageSourceThumbnailMaxPixelSize : maxDimension] as CFDictionary\n    let downsampleImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOpt)!\n    return UIImage(cgImage: downsampleImage)\n}\n```\n## 参考\n[iOS图片加载速度极限优化—FastImageCache解析](http://blog.cnbang.net/tech/2578/)\n[谈谈 iOS 中图片的解压缩](http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina)\n[iOS中的图片使用方式、内存对比和最佳实践](https://juejin.im/post/5b2ddfa7e51d4553156be305)\n\n\n\n\n\n","slug":"一张图片引发的思考","published":1,"updated":"2018-10-27T02:14:03.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxs9000f2ycwlzuha3go","content":"<h2 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h2><p>前段时间做微信小程序分享，用了某家的SDK，然鹅……他们家SDK只能上传<code>png</code>、<code>jpeg</code>格式的图片，微信不是可以上传<code>Data</code>吗？？？？<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-1e640864e3ce90f4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"???.jpeg\"><br>我吭哧吭哧半天用<code>UIImageJPEGRepresentation</code>压缩图片，然后在生成图片，也没把图片传上去。我当时想肯定是图片大小有问题，因为微信限制128KB以内。我查看保存在沙盒里的图片才32KB啊？？怎么会上传不上去呢？再查看<code>Image</code>的<code>Data</code>大小，噗~~~168KB。好吧，我被打败了。最后还是用微信原生SDK才搞定，直接传一个<code>Data</code>过去，多开心，多easy。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>好的，扯了这么多，其实就是想说一下为啥会有今天这篇大水文。在解决问题的过程中，我对iOS加载图片的理解稍微深入了那么一丢丢。现在，就水一下我理解的那么一丢丢东西。</p>\n<h3 id=\"图片经过哪些流程加载到屏幕上\"><a href=\"#图片经过哪些流程加载到屏幕上\" class=\"headerlink\" title=\"图片经过哪些流程加载到屏幕上\"></a>图片经过哪些流程加载到屏幕上</h3><ol>\n<li>从磁盘拷贝数据到内核缓冲区</li>\n<li>从内核缓冲区复制数据到用户空间（内存级别拷贝）</li>\n<li>生成<code>UIImage</code>，把<code>UIImage</code>赋值给<code>UIImageView</code></li>\n<li>如果图像数据为未解码的PNG/JPG，解码为位图数据</li>\n<li>隐式<code>CATransaction</code>捕获到<code>UIImageView</code>图层树的变化</li>\n<li>主线程<code>Runloop</code>提交<code>CATransaction</code>，开始进行图像渲染<br>6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐<br>6.2 GPU处理位图数据，进行渲染</li>\n</ol>\n<p>其中第四点就是导致我32KB变168KB的“罪魁祸首”。为啥这么说呢？先了解一些东西。</p>\n<h3 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h3><p><code>PNG</code>只支持无损压缩，所以它的压缩比是有上限的。它有<code>alpha</code>通道，支持图片透明。此外xcode会对png格式进行特殊的优化处理，而对于其他图片不做处理，所以我们一些小图标经常用<code>PNG</code>。</p>\n<h3 id=\"JPEG\"><a href=\"#JPEG\" class=\"headerlink\" title=\"JPEG\"></a>JPEG</h3><p><code>JPEG</code>支持有损压缩，不含有<code>alpha</code>通道，它可以通过图片质量换取内存空间。网络图片最好选用<code>JPEG</code>，可以节省流量、提高下载速度。</p>\n<h3 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h3><p>我们是否可以直接使用图片，使其显示在屏幕上呢？答案显然后<strong>不可以</strong>。图片经过解压后，变成位图数据。那么<a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3\" target=\"_blank\" rel=\"noopener\">位图</a>是什么呢?苹果给出的解释是</p>\n<blockquote>\n<p>A bitmap image (or sampled image) is an array of pixels (or samples)</p>\n</blockquote>\n<p>位图是一个像素数组。至于怎么将像素绘制到屏幕上，可以看<a href=\"https://objccn.io/issue-3-1/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，就不做过多叙述（人家说的很明白）。</p>\n<h3 id=\"解码\"><a href=\"#解码\" class=\"headerlink\" title=\"解码\"></a>解码</h3><p>解码其实就是将图片的二进制数据转换成像素数据。这个过程是比较耗时的，不能使用 GPU 硬解码，只能通过 CPU 软解码实现（硬解码是通过解码电路实现，软解码是通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码）。解码后的文件大小计算公式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解压缩后的图片大小 = 图片的像素宽 * 图片的像素高 * 每个像素所占的字节数 (4)</span><br></pre></td></tr></table></figure></p>\n<p>每个像素所占的字节数为什么是4呢？因为我们所使用的位图大部分是32位的RGBA模式，这种模式位图的一个像素所占内存为32位，也就是4个字节的长度 。<a href=\"https://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use\" target=\"_blank\" rel=\"noopener\">出处在此</a><br>所以，本地保存的32KB的图片，解码就是168KB了。（解压缩后的数据）<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-2e399ff3e5457a17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"恍然大悟.jpg\"></p>\n<h3 id=\"压缩图片\"><a href=\"#压缩图片\" class=\"headerlink\" title=\"压缩图片\"></a>压缩图片</h3><p>不过分享某一张图片的时候，我用<code>UIImageJPEGRepresentation</code>方法压缩不到128KB一下？？？什么图片这么大？后来问一下后台才知道，这张图片是相机拍摄的，尺寸非常大，只能重新设置图片尺寸。献上我的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">func compressImage(_ image: UIImage, toByte maxLength: Int) -&gt; Data?&#123;</span><br><span class=\"line\">    var compression: CGFloat = 1</span><br><span class=\"line\"></span><br><span class=\"line\">    var data = UIImageJPEGRepresentation(image, compression)!</span><br><span class=\"line\">        if data.count &lt;= maxLength &#123;</span><br><span class=\"line\">        return data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var max: CGFloat = 1</span><br><span class=\"line\">    var min: CGFloat = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    let newSize = CGSize.init(width: 200, height: 160)</span><br><span class=\"line\">    UIGraphicsBeginImageContext(newSize)</span><br><span class=\"line\">    image.draw(in: CGRect.init(x: 0, y: 0, width: newSize.width, height: newSize.height))</span><br><span class=\"line\">    let newImage = UIGraphicsGetImageFromCurrentImageContext()!</span><br><span class=\"line\">    UIGraphicsEndImageContext()</span><br><span class=\"line\">    data = UIImageJPEGRepresentation(newImage, 1.0)!</span><br><span class=\"line\">    if data.count &lt;= maxLength &#123;</span><br><span class=\"line\">        return data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for _ in 0..&lt;10 &#123;</span><br><span class=\"line\">        compression = (max + min) / 2</span><br><span class=\"line\">        data = UIImageJPEGRepresentation(newImage, compression)!</span><br><span class=\"line\"></span><br><span class=\"line\">        if CGFloat(data.count) &lt; CGFloat(maxLength) * 0.9 &#123;</span><br><span class=\"line\">            min = compression</span><br><span class=\"line\">        &#125; else if data.count &gt; maxLength &#123;</span><br><span class=\"line\">            max = compression</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            break</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return data</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"图片加载\"><a href=\"#图片加载\" class=\"headerlink\" title=\"图片加载\"></a>图片加载</h2><p>通常我们说图片加载会用到两种方法：<code>imageNamed</code>、<code>imageWithContentsOfFile</code>，我们简单介绍这两种方法</p>\n<h3 id=\"imageNamed\"><a href=\"#imageNamed\" class=\"headerlink\" title=\"imageNamed\"></a>imageNamed</h3><p>该方法的特点在于可以缓存已经加载的图片；使用时，先根据文件名在系统缓存中寻找图片，如果找到了就返回；如果没有，就在<code>Bundle</code>内查找到文件名，找到后把这个文件名放到<code>UIImage</code>里返回，并没有进行实际的文件读取和解码。当<code>UIImage</code>第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。</p>\n<h3 id=\"imageWithContentsOfFile\"><a href=\"#imageWithContentsOfFile\" class=\"headerlink\" title=\"imageWithContentsOfFile\"></a>imageWithContentsOfFile</h3><p>该方法仅加载图片，不缓存图像数据，其解码依然要等到第一次显示该图片的时候。<br>对于这两种方法，我们可以做出如下比较：</p>\n<ul>\n<li>本地（Assets）保存的图标加载使用<code>imageNamed</code></li>\n<li>经常使用且文件不大的图片使用<code>imageNamed</code></li>\n<li>对于一些文件较大的图片使用<code>imageWithContentsOfFile</code>，当然最好的办法是用<code>UIGraphicsBeginImageContext</code>方法重新绘制图片</li>\n</ul>\n<p>此外，在 WWDC 2018上，苹果为我们建议了一种大家平时使用较少的大图加载方式，它的实际占用内存与理论值最为接近。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -&gt; UIImage</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let sourceOpt = [kCGImageSourceShouldCache : false] as  CFDictionary</span><br><span class=\"line\">// 其他场景可以用createwithdata (data并未decode,所占内存没那么大),</span><br><span class=\"line\">    let source = CGImageSourceCreateWithURL(imageURL as CFURL, sourceOpt)!</span><br><span class=\"line\"></span><br><span class=\"line\">    let maxDimension = max(pointSize.width, pointSize.height) * scale</span><br><span class=\"line\">    let downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : true,</span><br><span class=\"line\">                         kCGImageSourceShouldCacheImmediately : true ,</span><br><span class=\"line\">                         kCGImageSourceCreateThumbnailWithTransform : true,</span><br><span class=\"line\">                         kCGImageSourceThumbnailMaxPixelSize : maxDimension] as CFDictionary</span><br><span class=\"line\">    let downsampleImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOpt)!</span><br><span class=\"line\">    return UIImage(cgImage: downsampleImage)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.cnbang.net/tech/2578/\" target=\"_blank\" rel=\"noopener\">iOS图片加载速度极限优化—FastImageCache解析</a><br><a href=\"http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina\" target=\"_blank\" rel=\"noopener\">谈谈 iOS 中图片的解压缩</a><br><a href=\"https://juejin.im/post/5b2ddfa7e51d4553156be305\" target=\"_blank\" rel=\"noopener\">iOS中的图片使用方式、内存对比和最佳实践</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景：\"><a href=\"#背景：\" class=\"headerlink\" title=\"背景：\"></a>背景：</h2><p>前段时间做微信小程序分享，用了某家的SDK，然鹅……他们家SDK只能上传<code>png</code>、<code>jpeg</code>格式的图片，微信不是可以上传<code>Data</code>吗？？？？<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-1e640864e3ce90f4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"???.jpeg\"><br>我吭哧吭哧半天用<code>UIImageJPEGRepresentation</code>压缩图片，然后在生成图片，也没把图片传上去。我当时想肯定是图片大小有问题，因为微信限制128KB以内。我查看保存在沙盒里的图片才32KB啊？？怎么会上传不上去呢？再查看<code>Image</code>的<code>Data</code>大小，噗~~~168KB。好吧，我被打败了。最后还是用微信原生SDK才搞定，直接传一个<code>Data</code>过去，多开心，多easy。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>好的，扯了这么多，其实就是想说一下为啥会有今天这篇大水文。在解决问题的过程中，我对iOS加载图片的理解稍微深入了那么一丢丢。现在，就水一下我理解的那么一丢丢东西。</p>\n<h3 id=\"图片经过哪些流程加载到屏幕上\"><a href=\"#图片经过哪些流程加载到屏幕上\" class=\"headerlink\" title=\"图片经过哪些流程加载到屏幕上\"></a>图片经过哪些流程加载到屏幕上</h3><ol>\n<li>从磁盘拷贝数据到内核缓冲区</li>\n<li>从内核缓冲区复制数据到用户空间（内存级别拷贝）</li>\n<li>生成<code>UIImage</code>，把<code>UIImage</code>赋值给<code>UIImageView</code></li>\n<li>如果图像数据为未解码的PNG/JPG，解码为位图数据</li>\n<li>隐式<code>CATransaction</code>捕获到<code>UIImageView</code>图层树的变化</li>\n<li>主线程<code>Runloop</code>提交<code>CATransaction</code>，开始进行图像渲染<br>6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐<br>6.2 GPU处理位图数据，进行渲染</li>\n</ol>\n<p>其中第四点就是导致我32KB变168KB的“罪魁祸首”。为啥这么说呢？先了解一些东西。</p>\n<h3 id=\"PNG\"><a href=\"#PNG\" class=\"headerlink\" title=\"PNG\"></a>PNG</h3><p><code>PNG</code>只支持无损压缩，所以它的压缩比是有上限的。它有<code>alpha</code>通道，支持图片透明。此外xcode会对png格式进行特殊的优化处理，而对于其他图片不做处理，所以我们一些小图标经常用<code>PNG</code>。</p>\n<h3 id=\"JPEG\"><a href=\"#JPEG\" class=\"headerlink\" title=\"JPEG\"></a>JPEG</h3><p><code>JPEG</code>支持有损压缩，不含有<code>alpha</code>通道，它可以通过图片质量换取内存空间。网络图片最好选用<code>JPEG</code>，可以节省流量、提高下载速度。</p>\n<h3 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h3><p>我们是否可以直接使用图片，使其显示在屏幕上呢？答案显然后<strong>不可以</strong>。图片经过解压后，变成位图数据。那么<a href=\"https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3\" target=\"_blank\" rel=\"noopener\">位图</a>是什么呢?苹果给出的解释是</p>\n<blockquote>\n<p>A bitmap image (or sampled image) is an array of pixels (or samples)</p>\n</blockquote>\n<p>位图是一个像素数组。至于怎么将像素绘制到屏幕上，可以看<a href=\"https://objccn.io/issue-3-1/\" target=\"_blank\" rel=\"noopener\">这篇文章</a>，就不做过多叙述（人家说的很明白）。</p>\n<h3 id=\"解码\"><a href=\"#解码\" class=\"headerlink\" title=\"解码\"></a>解码</h3><p>解码其实就是将图片的二进制数据转换成像素数据。这个过程是比较耗时的，不能使用 GPU 硬解码，只能通过 CPU 软解码实现（硬解码是通过解码电路实现，软解码是通过解码算法、CPU 的通用计算等方式实现软件层面的解码，效率不如 GPU 硬解码）。解码后的文件大小计算公式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">解压缩后的图片大小 = 图片的像素宽 * 图片的像素高 * 每个像素所占的字节数 (4)</span><br></pre></td></tr></table></figure></p>\n<p>每个像素所占的字节数为什么是4呢？因为我们所使用的位图大部分是32位的RGBA模式，这种模式位图的一个像素所占内存为32位，也就是4个字节的长度 。<a href=\"https://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use\" target=\"_blank\" rel=\"noopener\">出处在此</a><br>所以，本地保存的32KB的图片，解码就是168KB了。（解压缩后的数据）<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-2e399ff3e5457a17.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"恍然大悟.jpg\"></p>\n<h3 id=\"压缩图片\"><a href=\"#压缩图片\" class=\"headerlink\" title=\"压缩图片\"></a>压缩图片</h3><p>不过分享某一张图片的时候，我用<code>UIImageJPEGRepresentation</code>方法压缩不到128KB一下？？？什么图片这么大？后来问一下后台才知道，这张图片是相机拍摄的，尺寸非常大，只能重新设置图片尺寸。献上我的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">func compressImage(_ image: UIImage, toByte maxLength: Int) -&gt; Data?&#123;</span><br><span class=\"line\">    var compression: CGFloat = 1</span><br><span class=\"line\"></span><br><span class=\"line\">    var data = UIImageJPEGRepresentation(image, compression)!</span><br><span class=\"line\">        if data.count &lt;= maxLength &#123;</span><br><span class=\"line\">        return data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var max: CGFloat = 1</span><br><span class=\"line\">    var min: CGFloat = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    let newSize = CGSize.init(width: 200, height: 160)</span><br><span class=\"line\">    UIGraphicsBeginImageContext(newSize)</span><br><span class=\"line\">    image.draw(in: CGRect.init(x: 0, y: 0, width: newSize.width, height: newSize.height))</span><br><span class=\"line\">    let newImage = UIGraphicsGetImageFromCurrentImageContext()!</span><br><span class=\"line\">    UIGraphicsEndImageContext()</span><br><span class=\"line\">    data = UIImageJPEGRepresentation(newImage, 1.0)!</span><br><span class=\"line\">    if data.count &lt;= maxLength &#123;</span><br><span class=\"line\">        return data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for _ in 0..&lt;10 &#123;</span><br><span class=\"line\">        compression = (max + min) / 2</span><br><span class=\"line\">        data = UIImageJPEGRepresentation(newImage, compression)!</span><br><span class=\"line\"></span><br><span class=\"line\">        if CGFloat(data.count) &lt; CGFloat(maxLength) * 0.9 &#123;</span><br><span class=\"line\">            min = compression</span><br><span class=\"line\">        &#125; else if data.count &gt; maxLength &#123;</span><br><span class=\"line\">            max = compression</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            break</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return data</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"图片加载\"><a href=\"#图片加载\" class=\"headerlink\" title=\"图片加载\"></a>图片加载</h2><p>通常我们说图片加载会用到两种方法：<code>imageNamed</code>、<code>imageWithContentsOfFile</code>，我们简单介绍这两种方法</p>\n<h3 id=\"imageNamed\"><a href=\"#imageNamed\" class=\"headerlink\" title=\"imageNamed\"></a>imageNamed</h3><p>该方法的特点在于可以缓存已经加载的图片；使用时，先根据文件名在系统缓存中寻找图片，如果找到了就返回；如果没有，就在<code>Bundle</code>内查找到文件名，找到后把这个文件名放到<code>UIImage</code>里返回，并没有进行实际的文件读取和解码。当<code>UIImage</code>第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在。</p>\n<h3 id=\"imageWithContentsOfFile\"><a href=\"#imageWithContentsOfFile\" class=\"headerlink\" title=\"imageWithContentsOfFile\"></a>imageWithContentsOfFile</h3><p>该方法仅加载图片，不缓存图像数据，其解码依然要等到第一次显示该图片的时候。<br>对于这两种方法，我们可以做出如下比较：</p>\n<ul>\n<li>本地（Assets）保存的图标加载使用<code>imageNamed</code></li>\n<li>经常使用且文件不大的图片使用<code>imageNamed</code></li>\n<li>对于一些文件较大的图片使用<code>imageWithContentsOfFile</code>，当然最好的办法是用<code>UIGraphicsBeginImageContext</code>方法重新绘制图片</li>\n</ul>\n<p>此外，在 WWDC 2018上，苹果为我们建议了一种大家平时使用较少的大图加载方式，它的实际占用内存与理论值最为接近。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func downsample(imageAt imageURL: URL, to pointSize: CGSize, scale: CGFloat) -&gt; UIImage</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let sourceOpt = [kCGImageSourceShouldCache : false] as  CFDictionary</span><br><span class=\"line\">// 其他场景可以用createwithdata (data并未decode,所占内存没那么大),</span><br><span class=\"line\">    let source = CGImageSourceCreateWithURL(imageURL as CFURL, sourceOpt)!</span><br><span class=\"line\"></span><br><span class=\"line\">    let maxDimension = max(pointSize.width, pointSize.height) * scale</span><br><span class=\"line\">    let downsampleOpt = [kCGImageSourceCreateThumbnailFromImageAlways : true,</span><br><span class=\"line\">                         kCGImageSourceShouldCacheImmediately : true ,</span><br><span class=\"line\">                         kCGImageSourceCreateThumbnailWithTransform : true,</span><br><span class=\"line\">                         kCGImageSourceThumbnailMaxPixelSize : maxDimension] as CFDictionary</span><br><span class=\"line\">    let downsampleImage = CGImageSourceCreateThumbnailAtIndex(source, 0, downsampleOpt)!</span><br><span class=\"line\">    return UIImage(cgImage: downsampleImage)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.cnbang.net/tech/2578/\" target=\"_blank\" rel=\"noopener\">iOS图片加载速度极限优化—FastImageCache解析</a><br><a href=\"http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina\" target=\"_blank\" rel=\"noopener\">谈谈 iOS 中图片的解压缩</a><br><a href=\"https://juejin.im/post/5b2ddfa7e51d4553156be305\" target=\"_blank\" rel=\"noopener\">iOS中的图片使用方式、内存对比和最佳实践</a></p>\n"},{"title":"RxSwift 变换操作(Transforming Observables)","date":"2018-09-25T13:52:23.000Z","_content":"变换操作指的是对原始的`Observable`序列进行一些转换，类似于 Swift 中`CollectionType`的各种转换\n#### 1. buffer\n`buffer`操作符将缓存`Observable`中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。\n![buffer.png](https://upload-images.jianshu.io/upload_images/2855070-76c121cb942f7c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n🌰：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext([\"A\", \"B\", \"C\"])\nnext([\"🐯\", \"🐭\", \"🐱\"])\n```\n有一点疑问，对于`buffer`在`RxSwift`的解释是\n>Projects each element of an observable sequence into a buffer that's sent out when either it's full or a given amount of time has elapsed, using the specified scheduler to run timers\n\n`RxSwift`中，它的意思是当缓冲区满了或超过了给定的时间时，就会发出缓冲区。可是如果我们把上述代码稍微改变一下\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\n//  subject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext([\"A\", \"B\", \"C\"])\n```\n并没有后面的内容。因为我在很多文章里都看到说如果规定时间内不够要求的数量也会发出（有几个发几个，一个都没有发空数组 []）。所以，这点值得注意。\n#### 2. window\n- `window`操作符和`buffer`十分相似。不过`buffer`是周期性的将缓存的元素集合发送出来，而`window`周期性的将元素集合以`Observable`的形态发送出来。\n同时`buffer`要等到元素搜集完毕后，才会发出元素序列。而`window`可以实时发出元素序列。(这一点证明了`buffer`还是要元素搜集完毕后才会发出序列)\n![window.png](https://upload-images.jianshu.io/upload_images/2855070-4658ffd7d827e9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n首先我们先这么写：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\n......\n```\n可见他在不断打印`next(RxSwift.AddRef<Swift.String>)`\n如果把代码改成这样：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n    .subscribe(onNext: {\n        print(\"subscribe:\\($0)\")\n        $0.asObservable()\n            .subscribe{ print($0) }\n            .disposed(by: disposeBag)\n    })\n    .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nsubscribe:RxSwift.AddRef<Swift.String>\nnext(A)\nnext(B)\nnext(C)\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\nnext(🐯)\nnext(🐭)\nnext(🐱)\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\ncompleted\n```\n#### 3.map\n`map`操作符将`Observable`的每个元素应用你提供的转换方法，然后返回含有转换结果的`Observable`。\n![map.png](https://upload-images.jianshu.io/upload_images/2855070-def03bf478a9770d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1,2,3)\n        .map{ $0 * 2 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果如下：\n```\n2\n4\n6\n```\n其实，swift中也有一个高级函数`map`，可以对数组中的每一个元素做一次处理\n```\nlet array = [1, 2, 3]\nlet nums = array.map {\n    return $0 * 2\n}\nprint(nums)\n```\n结果得出：\n```\n[2, 4, 6]\n```\n#### 4. flatMap\n- `map`在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。\n- 而`flatMap`操作符会对源`Observable`的每一个元素应用一个转换方法，将他们转换成`Observables`。 然后将这些`Observables`的元素合并之后再发送出来。即又将其 \"拍扁\"（降维）成一个`Observable`序列。\n- 这个操作符是非常有用的。比如当`Observable`的元素本生拥有其他的`Observable`时，我们可以将所有子`Observables`的元素发送出来。\n\n![flatMap.png](https://upload-images.jianshu.io/upload_images/2855070-f40ff203991060c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .flatMap{ $0 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nvariable.value = second\nsecond.onNext(\"2\")\nfirst.onNext(\"3\")\n```\n打印结果如下：\n```\nA\n1\nB\n2\n3\n```\n我们依然可以在`Swift`中找到高级函数`flatMap`，它相比`map`有两点不同\n- `flatMap`返回后的数组中不存在`nil`，同时它会把`Optional`解包\n- `flatMap`还能把数组中存有数组的数组（二维数组、N维数组）一同打开变成一个新的数组\n- 也能把两个不同的数组合并成一个数组，这个合并的数组元素个数是前面两个数组元素个数的乘积\n\n只举一个🌰：\n```\nlet array = [[1, 2, 3], [4, 5, 6]]\nlet nums = array.flatMap{ $0 }\nprint(nums)\n```\n运行结果如下：\n```\n[1, 2, 3, 4, 5, 6]\n```\n#### 5. flatMapLatest\n`flatMapLatest`与`flatMap`的唯一区别是：`flatMapLatest`只会接收最新的`value`事件\n![flatMapLatest.png](https://upload-images.jianshu.io/upload_images/2855070-ac2d4f8e45ea1ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n将上述代码中`flatMap`改为`flatMapLatest`\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .flatMapLatest{ $0 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nvariable.value = second\nsecond.onNext(\"2\")\nfirst.onNext(\"3\")\n```\n运行结果如下：\n```\nA\n1\nB\n2\n```\n#### 6. concatMap\n`concatMap`操作符将源`Observable`的每一个元素应用一个转换方法，将他们转换成`Observables`。然后让这些`Observables` 按顺序的发出元素，当前一个`Observable`元素发送完毕后，后一个`Observable`才可以开始发出元素。等待前一个`Observable `产生完成事件后，才对后一个`Observable`进行订阅\n![concatMap.png](https://upload-images.jianshu.io/upload_images/2855070-5969d4c9a2013318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .concatMap{ $0 }\n        .subscribe(onNext: { print($0) })   \n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nfirst.onNext(\"2\")\n\nvariable.value = second\nsecond.onNext(\"3\")\nsecond.onNext(\"4\")\n\nfirst.onCompleted()\nsecond.onNext(\"5\")\n```\n运行结果如下：\n```\nA\n1\n2\n4\n5\n```\n#### 7. scan\n`scan`操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。\n![scan.png](https://upload-images.jianshu.io/upload_images/2855070-83cf372dd5b1cbe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 5)\n        .scan(0) { acum, elem  in\n            acum + elem\n        }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果如下：\n```\n1\n3\n6\n10\n15\n```\n#### 8. groupBy\n- `groupBy`操作符将源`Observable`分解为多个子`Observable`，然后将这些子`Observable`发送出来。\n- 也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以`Observable`的形态发送出来。\n![groupBy.png](https://upload-images.jianshu.io/upload_images/2855070-4193d29d366c8e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable<Int>.of(0, 1, 2, 3, 4, 5)\n        .groupBy { (element) -> String in\n            return element % 2 == 0 ? \"偶数\" : \"奇数\"\n        }\n        .subscribe { (event) in\n            switch event {\n            case .next(let group):\n                group.asObservable().subscribe({ (event) in\n                    print(\"key:\\(group.key)  event:\\(event)\")\n                })\n                .disposed(by: disposeBag)\n            default:\n                print(\"\")\n            }\n}.disposed(by: disposeBag)\n```\n运行结果如下：\n```\nkey:偶数  event:next(0)\nkey:奇数  event:next(1)\nkey:偶数  event:next(2)\nkey:奇数  event:next(3)\nkey:偶数  event:next(4)\nkey:奇数  event:next(5)\nkey:奇数  event:completed\nkey:偶数  event:completed\n```\n","source":"_posts/RxSwift-变换操作-Transforming-Observables.md","raw":"---\ntitle: RxSwift 变换操作(Transforming Observables)\ndate: 2018-09-25 21:52:23\ntags: RxSwift\n---\n变换操作指的是对原始的`Observable`序列进行一些转换，类似于 Swift 中`CollectionType`的各种转换\n#### 1. buffer\n`buffer`操作符将缓存`Observable`中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。\n![buffer.png](https://upload-images.jianshu.io/upload_images/2855070-76c121cb942f7c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n🌰：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext([\"A\", \"B\", \"C\"])\nnext([\"🐯\", \"🐭\", \"🐱\"])\n```\n有一点疑问，对于`buffer`在`RxSwift`的解释是\n>Projects each element of an observable sequence into a buffer that's sent out when either it's full or a given amount of time has elapsed, using the specified scheduler to run timers\n\n`RxSwift`中，它的意思是当缓冲区满了或超过了给定的时间时，就会发出缓冲区。可是如果我们把上述代码稍微改变一下\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\n//  subject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext([\"A\", \"B\", \"C\"])\n```\n并没有后面的内容。因为我在很多文章里都看到说如果规定时间内不够要求的数量也会发出（有几个发几个，一个都没有发空数组 []）。所以，这点值得注意。\n#### 2. window\n- `window`操作符和`buffer`十分相似。不过`buffer`是周期性的将缓存的元素集合发送出来，而`window`周期性的将元素集合以`Observable`的形态发送出来。\n同时`buffer`要等到元素搜集完毕后，才会发出元素序列。而`window`可以实时发出元素序列。(这一点证明了`buffer`还是要元素搜集完毕后才会发出序列)\n![window.png](https://upload-images.jianshu.io/upload_images/2855070-4658ffd7d827e9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n首先我们先这么写：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n        .subscribe{ print($0) }\n        .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\nnext(RxSwift.AddRef<Swift.String>)\n......\n```\n可见他在不断打印`next(RxSwift.AddRef<Swift.String>)`\n如果把代码改成这样：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n\nsubject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)\n    .subscribe(onNext: {\n        print(\"subscribe:\\($0)\")\n        $0.asObservable()\n            .subscribe{ print($0) }\n            .disposed(by: disposeBag)\n    })\n    .disposed(by: disposeBag)\n\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\n\nsubject.onNext(\"🐯\")\nsubject.onNext(\"🐭\")\nsubject.onNext(\"🐱\")\n```\n运行结果如下：\n```\nsubscribe:RxSwift.AddRef<Swift.String>\nnext(A)\nnext(B)\nnext(C)\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\nnext(🐯)\nnext(🐭)\nnext(🐱)\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\ncompleted\nsubscribe:RxSwift.AddRef<Swift.String>\ncompleted\n```\n#### 3.map\n`map`操作符将`Observable`的每个元素应用你提供的转换方法，然后返回含有转换结果的`Observable`。\n![map.png](https://upload-images.jianshu.io/upload_images/2855070-def03bf478a9770d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1,2,3)\n        .map{ $0 * 2 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果如下：\n```\n2\n4\n6\n```\n其实，swift中也有一个高级函数`map`，可以对数组中的每一个元素做一次处理\n```\nlet array = [1, 2, 3]\nlet nums = array.map {\n    return $0 * 2\n}\nprint(nums)\n```\n结果得出：\n```\n[2, 4, 6]\n```\n#### 4. flatMap\n- `map`在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。\n- 而`flatMap`操作符会对源`Observable`的每一个元素应用一个转换方法，将他们转换成`Observables`。 然后将这些`Observables`的元素合并之后再发送出来。即又将其 \"拍扁\"（降维）成一个`Observable`序列。\n- 这个操作符是非常有用的。比如当`Observable`的元素本生拥有其他的`Observable`时，我们可以将所有子`Observables`的元素发送出来。\n\n![flatMap.png](https://upload-images.jianshu.io/upload_images/2855070-f40ff203991060c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .flatMap{ $0 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nvariable.value = second\nsecond.onNext(\"2\")\nfirst.onNext(\"3\")\n```\n打印结果如下：\n```\nA\n1\nB\n2\n3\n```\n我们依然可以在`Swift`中找到高级函数`flatMap`，它相比`map`有两点不同\n- `flatMap`返回后的数组中不存在`nil`，同时它会把`Optional`解包\n- `flatMap`还能把数组中存有数组的数组（二维数组、N维数组）一同打开变成一个新的数组\n- 也能把两个不同的数组合并成一个数组，这个合并的数组元素个数是前面两个数组元素个数的乘积\n\n只举一个🌰：\n```\nlet array = [[1, 2, 3], [4, 5, 6]]\nlet nums = array.flatMap{ $0 }\nprint(nums)\n```\n运行结果如下：\n```\n[1, 2, 3, 4, 5, 6]\n```\n#### 5. flatMapLatest\n`flatMapLatest`与`flatMap`的唯一区别是：`flatMapLatest`只会接收最新的`value`事件\n![flatMapLatest.png](https://upload-images.jianshu.io/upload_images/2855070-ac2d4f8e45ea1ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n将上述代码中`flatMap`改为`flatMapLatest`\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .flatMapLatest{ $0 }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nvariable.value = second\nsecond.onNext(\"2\")\nfirst.onNext(\"3\")\n```\n运行结果如下：\n```\nA\n1\nB\n2\n```\n#### 6. concatMap\n`concatMap`操作符将源`Observable`的每一个元素应用一个转换方法，将他们转换成`Observables`。然后让这些`Observables` 按顺序的发出元素，当前一个`Observable`元素发送完毕后，后一个`Observable`才可以开始发出元素。等待前一个`Observable `产生完成事件后，才对后一个`Observable`进行订阅\n![concatMap.png](https://upload-images.jianshu.io/upload_images/2855070-5969d4c9a2013318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nlet first = BehaviorSubject.init(value: \"A\")\nlet second = BehaviorSubject.init(value: \"B\")\nlet variable = Variable.init(first)\n\nvariable.asObservable()\n        .concatMap{ $0 }\n        .subscribe(onNext: { print($0) })   \n        .disposed(by: disposeBag)\nfirst.onNext(\"1\")\nfirst.onNext(\"2\")\n\nvariable.value = second\nsecond.onNext(\"3\")\nsecond.onNext(\"4\")\n\nfirst.onCompleted()\nsecond.onNext(\"5\")\n```\n运行结果如下：\n```\nA\n1\n2\n4\n5\n```\n#### 7. scan\n`scan`操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。\n![scan.png](https://upload-images.jianshu.io/upload_images/2855070-83cf372dd5b1cbe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable.of(1, 2, 3, 4, 5)\n        .scan(0) { acum, elem  in\n            acum + elem\n        }\n        .subscribe(onNext: { print($0) })\n        .disposed(by: disposeBag)\n```\n运行结果如下：\n```\n1\n3\n6\n10\n15\n```\n#### 8. groupBy\n- `groupBy`操作符将源`Observable`分解为多个子`Observable`，然后将这些子`Observable`发送出来。\n- 也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以`Observable`的形态发送出来。\n![groupBy.png](https://upload-images.jianshu.io/upload_images/2855070-4193d29d366c8e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\nlet disposeBag = DisposeBag()\nObservable<Int>.of(0, 1, 2, 3, 4, 5)\n        .groupBy { (element) -> String in\n            return element % 2 == 0 ? \"偶数\" : \"奇数\"\n        }\n        .subscribe { (event) in\n            switch event {\n            case .next(let group):\n                group.asObservable().subscribe({ (event) in\n                    print(\"key:\\(group.key)  event:\\(event)\")\n                })\n                .disposed(by: disposeBag)\n            default:\n                print(\"\")\n            }\n}.disposed(by: disposeBag)\n```\n运行结果如下：\n```\nkey:偶数  event:next(0)\nkey:奇数  event:next(1)\nkey:偶数  event:next(2)\nkey:奇数  event:next(3)\nkey:偶数  event:next(4)\nkey:奇数  event:next(5)\nkey:奇数  event:completed\nkey:偶数  event:completed\n```\n","slug":"RxSwift-变换操作-Transforming-Observables","published":1,"updated":"2018-10-19T07:16:01.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxxz000m2ycwysey54i7","content":"<p>变换操作指的是对原始的<code>Observable</code>序列进行一些转换，类似于 Swift 中<code>CollectionType</code>的各种转换</p>\n<h4 id=\"1-buffer\"><a href=\"#1-buffer\" class=\"headerlink\" title=\"1. buffer\"></a>1. buffer</h4><p><code>buffer</code>操作符将缓存<code>Observable</code>中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-76c121cb942f7c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"buffer.png\"><br>🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br><span class=\"line\">next([&quot;🐯&quot;, &quot;🐭&quot;, &quot;🐱&quot;])</span><br></pre></td></tr></table></figure></p>\n<p>有一点疑问，对于<code>buffer</code>在<code>RxSwift</code>的解释是</p>\n<blockquote>\n<p>Projects each element of an observable sequence into a buffer that’s sent out when either it’s full or a given amount of time has elapsed, using the specified scheduler to run timers</p>\n</blockquote>\n<p><code>RxSwift</code>中，它的意思是当缓冲区满了或超过了给定的时间时，就会发出缓冲区。可是如果我们把上述代码稍微改变一下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//  subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br></pre></td></tr></table></figure></p>\n<p>并没有后面的内容。因为我在很多文章里都看到说如果规定时间内不够要求的数量也会发出（有几个发几个，一个都没有发空数组 []）。所以，这点值得注意。</p>\n<h4 id=\"2-window\"><a href=\"#2-window\" class=\"headerlink\" title=\"2. window\"></a>2. window</h4><ul>\n<li><code>window</code>操作符和<code>buffer</code>十分相似。不过<code>buffer</code>是周期性的将缓存的元素集合发送出来，而<code>window</code>周期性的将元素集合以<code>Observable</code>的形态发送出来。<br>同时<code>buffer</code>要等到元素搜集完毕后，才会发出元素序列。而<code>window</code>可以实时发出元素序列。(这一点证明了<code>buffer</code>还是要元素搜集完毕后才会发出序列)<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4658ffd7d827e9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"window.png\"><br>首先我们先这么写：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure></p>\n<p>可见他在不断打印<code>next(RxSwift.AddRef&lt;Swift.String&gt;)</code><br>如果把代码改成这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .subscribe(onNext: &#123;</span><br><span class=\"line\">        print(&quot;subscribe:\\($0)&quot;)</span><br><span class=\"line\">        $0.asObservable()</span><br><span class=\"line\">            .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">            .disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">next(A)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">next(C)</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">next(🐯)</span><br><span class=\"line\">next(🐭)</span><br><span class=\"line\">next(🐱)</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-map\"><a href=\"#3-map\" class=\"headerlink\" title=\"3.map\"></a>3.map</h4><p><code>map</code>操作符将<code>Observable</code>的每个元素应用你提供的转换方法，然后返回含有转换结果的<code>Observable</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-def03bf478a9770d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"map.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1,2,3)</span><br><span class=\"line\">        .map&#123; $0 * 2 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure></p>\n<p>其实，swift中也有一个高级函数<code>map</code>，可以对数组中的每一个元素做一次处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let array = [1, 2, 3]</span><br><span class=\"line\">let nums = array.map &#123;</span><br><span class=\"line\">    return $0 * 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure></p>\n<p>结果得出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2, 4, 6]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-flatMap\"><a href=\"#4-flatMap\" class=\"headerlink\" title=\"4. flatMap\"></a>4. flatMap</h4><ul>\n<li><code>map</code>在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。</li>\n<li>而<code>flatMap</code>操作符会对源<code>Observable</code>的每一个元素应用一个转换方法，将他们转换成<code>Observables</code>。 然后将这些<code>Observables</code>的元素合并之后再发送出来。即又将其 “拍扁”（降维）成一个<code>Observable</code>序列。</li>\n<li>这个操作符是非常有用的。比如当<code>Observable</code>的元素本生拥有其他的<code>Observable</code>时，我们可以将所有子<code>Observables</code>的元素发送出来。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-f40ff203991060c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"flatMap.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .flatMap&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;2&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br></pre></td></tr></table></figure>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">B</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<p>我们依然可以在<code>Swift</code>中找到高级函数<code>flatMap</code>，它相比<code>map</code>有两点不同</p>\n<ul>\n<li><code>flatMap</code>返回后的数组中不存在<code>nil</code>，同时它会把<code>Optional</code>解包</li>\n<li><code>flatMap</code>还能把数组中存有数组的数组（二维数组、N维数组）一同打开变成一个新的数组</li>\n<li>也能把两个不同的数组合并成一个数组，这个合并的数组元素个数是前面两个数组元素个数的乘积</li>\n</ul>\n<p>只举一个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let array = [[1, 2, 3], [4, 5, 6]]</span><br><span class=\"line\">let nums = array.flatMap&#123; $0 &#125;</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-flatMapLatest\"><a href=\"#5-flatMapLatest\" class=\"headerlink\" title=\"5. flatMapLatest\"></a>5. flatMapLatest</h4><p><code>flatMapLatest</code>与<code>flatMap</code>的唯一区别是：<code>flatMapLatest</code>只会接收最新的<code>value</code>事件<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ac2d4f8e45ea1ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"flatMapLatest.png\"><br>将上述代码中<code>flatMap</code>改为<code>flatMapLatest</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .flatMapLatest&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;2&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">B</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-concatMap\"><a href=\"#6-concatMap\" class=\"headerlink\" title=\"6. concatMap\"></a>6. concatMap</h4><p><code>concatMap</code>操作符将源<code>Observable</code>的每一个元素应用一个转换方法，将他们转换成<code>Observables</code>。然后让这些<code>Observables</code> 按顺序的发出元素，当前一个<code>Observable</code>元素发送完毕后，后一个<code>Observable</code>才可以开始发出元素。等待前一个<code>Observable</code>产生完成事件后，才对后一个<code>Observable</code>进行订阅<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-5969d4c9a2013318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"concatMap.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .concatMap&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)   </span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;3&quot;)</span><br><span class=\"line\">second.onNext(&quot;4&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onCompleted()</span><br><span class=\"line\">second.onNext(&quot;5&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-scan\"><a href=\"#7-scan\" class=\"headerlink\" title=\"7. scan\"></a>7. scan</h4><p><code>scan</code>操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-83cf372dd5b1cbe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scan.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 5)</span><br><span class=\"line\">        .scan(0) &#123; acum, elem  in</span><br><span class=\"line\">            acum + elem</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">6</span><br><span class=\"line\">10</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-groupBy\"><a href=\"#8-groupBy\" class=\"headerlink\" title=\"8. groupBy\"></a>8. groupBy</h4><ul>\n<li><code>groupBy</code>操作符将源<code>Observable</code>分解为多个子<code>Observable</code>，然后将这些子<code>Observable</code>发送出来。</li>\n<li>也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以<code>Observable</code>的形态发送出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4193d29d366c8e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"groupBy.png\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable&lt;Int&gt;.of(0, 1, 2, 3, 4, 5)</span><br><span class=\"line\">        .groupBy &#123; (element) -&gt; String in</span><br><span class=\"line\">            return element % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .subscribe &#123; (event) in</span><br><span class=\"line\">            switch event &#123;</span><br><span class=\"line\">            case .next(let group):</span><br><span class=\"line\">                group.asObservable().subscribe(&#123; (event) in</span><br><span class=\"line\">                    print(&quot;key:\\(group.key)  event:\\(event)&quot;)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .disposed(by: disposeBag)</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                print(&quot;&quot;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key:偶数  event:next(0)</span><br><span class=\"line\">key:奇数  event:next(1)</span><br><span class=\"line\">key:偶数  event:next(2)</span><br><span class=\"line\">key:奇数  event:next(3)</span><br><span class=\"line\">key:偶数  event:next(4)</span><br><span class=\"line\">key:奇数  event:next(5)</span><br><span class=\"line\">key:奇数  event:completed</span><br><span class=\"line\">key:偶数  event:completed</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>变换操作指的是对原始的<code>Observable</code>序列进行一些转换，类似于 Swift 中<code>CollectionType</code>的各种转换</p>\n<h4 id=\"1-buffer\"><a href=\"#1-buffer\" class=\"headerlink\" title=\"1. buffer\"></a>1. buffer</h4><p><code>buffer</code>操作符将缓存<code>Observable</code>中发出的新元素，当元素达到某个数量，或者经过了特定的时间，它就会将这个元素集合发送出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-76c121cb942f7c65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"buffer.png\"><br>🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br><span class=\"line\">next([&quot;🐯&quot;, &quot;🐭&quot;, &quot;🐱&quot;])</span><br></pre></td></tr></table></figure></p>\n<p>有一点疑问，对于<code>buffer</code>在<code>RxSwift</code>的解释是</p>\n<blockquote>\n<p>Projects each element of an observable sequence into a buffer that’s sent out when either it’s full or a given amount of time has elapsed, using the specified scheduler to run timers</p>\n</blockquote>\n<p><code>RxSwift</code>中，它的意思是当缓冲区满了或超过了给定的时间时，就会发出缓冲区。可是如果我们把上述代码稍微改变一下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.buffer(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//  subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br></pre></td></tr></table></figure></p>\n<p>并没有后面的内容。因为我在很多文章里都看到说如果规定时间内不够要求的数量也会发出（有几个发几个，一个都没有发空数组 []）。所以，这点值得注意。</p>\n<h4 id=\"2-window\"><a href=\"#2-window\" class=\"headerlink\" title=\"2. window\"></a>2. window</h4><ul>\n<li><code>window</code>操作符和<code>buffer</code>十分相似。不过<code>buffer</code>是周期性的将缓存的元素集合发送出来，而<code>window</code>周期性的将元素集合以<code>Observable</code>的形态发送出来。<br>同时<code>buffer</code>要等到元素搜集完毕后，才会发出元素序列。而<code>window</code>可以实时发出元素序列。(这一点证明了<code>buffer</code>还是要元素搜集完毕后才会发出序列)<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4658ffd7d827e9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"window.png\"><br>首先我们先这么写：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">        .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">next(RxSwift.AddRef&lt;Swift.String&gt;)</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure></p>\n<p>可见他在不断打印<code>next(RxSwift.AddRef&lt;Swift.String&gt;)</code><br>如果把代码改成这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">subject.window(timeSpan: 1, count: 3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .subscribe(onNext: &#123;</span><br><span class=\"line\">        print(&quot;subscribe:\\($0)&quot;)</span><br><span class=\"line\">        $0.asObservable()</span><br><span class=\"line\">            .subscribe&#123; print($0) &#125;</span><br><span class=\"line\">            .disposed(by: disposeBag)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐭&quot;)</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">next(A)</span><br><span class=\"line\">next(B)</span><br><span class=\"line\">next(C)</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">next(🐯)</span><br><span class=\"line\">next(🐭)</span><br><span class=\"line\">next(🐱)</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">completed</span><br><span class=\"line\">subscribe:RxSwift.AddRef&lt;Swift.String&gt;</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-map\"><a href=\"#3-map\" class=\"headerlink\" title=\"3.map\"></a>3.map</h4><p><code>map</code>操作符将<code>Observable</code>的每个元素应用你提供的转换方法，然后返回含有转换结果的<code>Observable</code>。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-def03bf478a9770d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"map.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1,2,3)</span><br><span class=\"line\">        .map&#123; $0 * 2 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure></p>\n<p>其实，swift中也有一个高级函数<code>map</code>，可以对数组中的每一个元素做一次处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let array = [1, 2, 3]</span><br><span class=\"line\">let nums = array.map &#123;</span><br><span class=\"line\">    return $0 * 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure></p>\n<p>结果得出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[2, 4, 6]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-flatMap\"><a href=\"#4-flatMap\" class=\"headerlink\" title=\"4. flatMap\"></a>4. flatMap</h4><ul>\n<li><code>map</code>在做转换的时候容易出现“升维”的情况。即转变之后，从一个序列变成了一个序列的序列。</li>\n<li>而<code>flatMap</code>操作符会对源<code>Observable</code>的每一个元素应用一个转换方法，将他们转换成<code>Observables</code>。 然后将这些<code>Observables</code>的元素合并之后再发送出来。即又将其 “拍扁”（降维）成一个<code>Observable</code>序列。</li>\n<li>这个操作符是非常有用的。比如当<code>Observable</code>的元素本生拥有其他的<code>Observable</code>时，我们可以将所有子<code>Observables</code>的元素发送出来。</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-f40ff203991060c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"flatMap.png\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .flatMap&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;2&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br></pre></td></tr></table></figure>\n<p>打印结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">B</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure></p>\n<p>我们依然可以在<code>Swift</code>中找到高级函数<code>flatMap</code>，它相比<code>map</code>有两点不同</p>\n<ul>\n<li><code>flatMap</code>返回后的数组中不存在<code>nil</code>，同时它会把<code>Optional</code>解包</li>\n<li><code>flatMap</code>还能把数组中存有数组的数组（二维数组、N维数组）一同打开变成一个新的数组</li>\n<li>也能把两个不同的数组合并成一个数组，这个合并的数组元素个数是前面两个数组元素个数的乘积</li>\n</ul>\n<p>只举一个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let array = [[1, 2, 3], [4, 5, 6]]</span><br><span class=\"line\">let nums = array.flatMap&#123; $0 &#125;</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-flatMapLatest\"><a href=\"#5-flatMapLatest\" class=\"headerlink\" title=\"5. flatMapLatest\"></a>5. flatMapLatest</h4><p><code>flatMapLatest</code>与<code>flatMap</code>的唯一区别是：<code>flatMapLatest</code>只会接收最新的<code>value</code>事件<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-ac2d4f8e45ea1ebb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"flatMapLatest.png\"><br>将上述代码中<code>flatMap</code>改为<code>flatMapLatest</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .flatMapLatest&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;2&quot;)</span><br><span class=\"line\">first.onNext(&quot;3&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">B</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-concatMap\"><a href=\"#6-concatMap\" class=\"headerlink\" title=\"6. concatMap\"></a>6. concatMap</h4><p><code>concatMap</code>操作符将源<code>Observable</code>的每一个元素应用一个转换方法，将他们转换成<code>Observables</code>。然后让这些<code>Observables</code> 按顺序的发出元素，当前一个<code>Observable</code>元素发送完毕后，后一个<code>Observable</code>才可以开始发出元素。等待前一个<code>Observable</code>产生完成事件后，才对后一个<code>Observable</code>进行订阅<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-5969d4c9a2013318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"concatMap.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let first = BehaviorSubject.init(value: &quot;A&quot;)</span><br><span class=\"line\">let second = BehaviorSubject.init(value: &quot;B&quot;)</span><br><span class=\"line\">let variable = Variable.init(first)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.asObservable()</span><br><span class=\"line\">        .concatMap&#123; $0 &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)   </span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br><span class=\"line\">first.onNext(&quot;1&quot;)</span><br><span class=\"line\">first.onNext(&quot;2&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">variable.value = second</span><br><span class=\"line\">second.onNext(&quot;3&quot;)</span><br><span class=\"line\">second.onNext(&quot;4&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">first.onCompleted()</span><br><span class=\"line\">second.onNext(&quot;5&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-scan\"><a href=\"#7-scan\" class=\"headerlink\" title=\"7. scan\"></a>7. scan</h4><p><code>scan</code>操作符将对第一个元素应用一个函数，将结果作为第一个元素发出。然后，将结果作为参数填入到第二个元素的应用函数中，创建第二个元素。以此类推，直到遍历完全部的元素。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-83cf372dd5b1cbe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"scan.png\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable.of(1, 2, 3, 4, 5)</span><br><span class=\"line\">        .scan(0) &#123; acum, elem  in</span><br><span class=\"line\">            acum + elem</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .subscribe(onNext: &#123; print($0) &#125;)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">6</span><br><span class=\"line\">10</span><br><span class=\"line\">15</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-groupBy\"><a href=\"#8-groupBy\" class=\"headerlink\" title=\"8. groupBy\"></a>8. groupBy</h4><ul>\n<li><code>groupBy</code>操作符将源<code>Observable</code>分解为多个子<code>Observable</code>，然后将这些子<code>Observable</code>发送出来。</li>\n<li>也就是说该操作符会将元素通过某个键进行分组，然后将分组后的元素序列以<code>Observable</code>的形态发送出来。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-4193d29d366c8e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"groupBy.png\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">Observable&lt;Int&gt;.of(0, 1, 2, 3, 4, 5)</span><br><span class=\"line\">        .groupBy &#123; (element) -&gt; String in</span><br><span class=\"line\">            return element % 2 == 0 ? &quot;偶数&quot; : &quot;奇数&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .subscribe &#123; (event) in</span><br><span class=\"line\">            switch event &#123;</span><br><span class=\"line\">            case .next(let group):</span><br><span class=\"line\">                group.asObservable().subscribe(&#123; (event) in</span><br><span class=\"line\">                    print(&quot;key:\\(group.key)  event:\\(event)&quot;)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .disposed(by: disposeBag)</span><br><span class=\"line\">            default:</span><br><span class=\"line\">                print(&quot;&quot;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key:偶数  event:next(0)</span><br><span class=\"line\">key:奇数  event:next(1)</span><br><span class=\"line\">key:偶数  event:next(2)</span><br><span class=\"line\">key:奇数  event:next(3)</span><br><span class=\"line\">key:偶数  event:next(4)</span><br><span class=\"line\">key:奇数  event:next(5)</span><br><span class=\"line\">key:奇数  event:completed</span><br><span class=\"line\">key:偶数  event:completed</span><br></pre></td></tr></table></figure></p>\n"},{"title":"RxSwift Observable-可观察序列","date":"2018-09-20T14:25:46.000Z","_content":"[上一篇](https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more)已经介绍了`Observable`是什么，现在简单介绍一下它怎么创建，以及`RxSwift`里面`Observable`存在的一些特征序列。\n### 常见的创建方法\n####  just() 方法\n该方法通过传入一个默认值完成初始化，并指定了当前`Observable`所发出事件携带的数据类型\n```\nlet observable = Observable<Int>.just(1)\n```\n#### of()方法\n该方法可以接受多个参数来创建实例，但这些参数必须是同类型\n```\nlet observable = Observable.of(\"A\", \"B\", \"C\")\n```\n#### from()方法\n该方法只接收数组作为参数，并抽取出数组里的元素来作为数据流中的元素\n```\nlet observable = Observable.from([\"A\", \"B\", \"C\"])\n```\n#### never()方法\n该方法创建一个永远不会发出`Event`（也不会终止）的 `Observable`序列\n```\nlet observable = Observable<Int>.never()\n```\n#### empty()方法\n该方法创建一个空内容的`Observable`序列\n```\nlet observable = Observable<Int>.empty()\n```\n#### error() 方法\n该方法创建一个不做任何操作，而是直接发送一个错误的`Observable`序列\n```\nenum MyError: Error {\n    case A\n    case B\n}\n\nlet observable = Observable<Int>.error(MyError.A)\n```\n#### range() 方法\n该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的`Observable`序列\n```\nlet observable = Observable.range(start: 1, count: 5)\n```\n#### repeatElement() 方法\n该方法创建一个可以无限发出给定元素的`Event`的`Observable`序列\n```\nlet observable = Observable.repeatElement(1)\n```\n#### generate() 方法\n该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的`Observable`序列\n```\nlet observable = Observable.generate(\n    initialState: 0,\n    condition: { $0 <= 10 },\n    iterate: { $0 + 2 }\n)\n```\n#### interval() 方法\n这个方法创建的`Observable`序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去\n```\nlet observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\nobservable.subscribe { event in\n    print(event)\n//next(0) next(1) next(2)......\n}\n```\n#### timer() 方法\n- 创建的`Observable`序列在经过设定的一段时间后，产生唯一的一个元素\n```\n//10秒种后发出唯一的一个元素0\nlet observable = Observable<Int>.timer(10, scheduler: MainScheduler.instance)\nobservable.subscribe { event in\n    print(event)\n}\n```\n- 创建的`Observable`序列在经过设定的一段时间后，每隔一段时间产生一个元素\n```\n//延时10秒种后，每隔1秒钟发出一个元素\nlet observable = Observable<Int>.timer(10, period: 1, scheduler: MainScheduler.instance)\n    observable.subscribe { event in\n    print(event)\n}\n```\n#### create()方法\n该方法接受一个`block`形式的参数，任务是对每一个过来的订阅进行处理\n```\nlet observable = Observable<String>.create { (observer) -> Disposable in\n    observer.onNext(\"test\")\n    observer.onCompleted()\n    return Disposables.create()\n}\nobservable.subscribe { (element) in\n    print(element)\n}\n//next(test)\n//completed\n```\n#### deferred() 方法\n该个方法相当于是创建一个`Observable`工厂，通过传入一个`block`来执行延迟`Observable`序列创建的行为，而这个`block`里就是真正的实例化序列对象的地方\n```\nvar time = 0\nlet factory: Observable<Int> = Observable.deferred {\n    time += 1\n    return Observable.just(time)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\n/* \n打印结果\nnext(1)\ncompleted\nnext(2)\ncompleted\nnext(3)\ncompleted\nnext(4)\ncompleted\n*/\n```\n### 特征序列\n` Swift`是一个强类型语言，它相对弱类型语言更加严谨。我们可以通过类型来判断出，实例有哪些特征。同样的在`RxSwift` 里面`Observable`也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码，他们分别是`Single`、`Completable`、`Maybe`、`Driver`、`ControlEvent`、`ControlProperty`\n####  Single\n`Single`,在`RxSwift`中,对它的解释是*Represents a push style sequence containing 1 element*，它要么只能发出一个元素，要么产生一个`error`事件\n- 发出一个元素或一个`error`事件\n- 不会共享状态变化\n附：\n```\npublic enum SingleEvent<Element> {\ncase success(Element)\ncase error(Swift.Error)\n}\n```\n比如说，我们利用`Single`实现一个网络请求，返回成功的结果或失败:\n```\nfunc getReop(_ repo: String) -> Single<[String: Any]>{\n    return Single<[String: Any]>.create(subscribe: { (single) -> Disposable in\n        let url = URL.init(string: \"https://api.github.com/repos/\\(repo)\")!\n        let task = URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) in\n            if let error = error{\n                single(.error(error))\n                return\n            }\n            guard let data = data,\n                let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),\n                let result = json as? [String: Any] else{\n                    single(.error(DataError.cantParseJSON))\n                    return\n                }\n                single(.success(result))\n        })\n        task.resume()\n        return Disposables.create {\n            task.cancel()\n        }\n    })\n}\n//与数据相关的错误类型\nenum DataError: Error {\n    case cantParseJSON\n}\n```\n当我们想调用这个方法的时候:\n```\nlet disposeBag = DisposeBag()\ngetReop(\"ReactiveX/RxSwift\").subscribe(onSuccess: { (json) in\n    print(\"Json:\\(json)\")\n}) { (error) in\n    print(\"error:\\(error)\")\n}.disposed(by: disposeBag)\n```\n\n#### Completable\n`Completable`，在`RxSwift`中，对它的解释*Represents a push style sequence containing 0 elements.*可以理解为表示包含0个元素的推送样式序列，它要么产生`completed`事件，要么产生`error`事件。\n- 不会发出任何元素\n- 只会发出一个`completed`事件或者一个`error`事件\n- 不会共享状态变化\n附：\n```\npublic enum CompletableEvent {\n    case error(Swift.Error)  \n    case completed\n}\n```\n举个🌰:\n```\nfunc cacheLocally() -> Completable {\n    return Completable.create(subscribe: { (completable) -> Disposable in\n    //将数据缓存到本地（这里掠过具体的业务代码，随机成功或失败）\n    let success = (arc4random() % 2 == 0)\n    guard success else {\n        completable(.error(CacheError.failedCaching))\n        return Disposables.create{}\n    }\n    completable(.completed)\n    return Disposables.create()\n    })\n}\nenum CacheError: Error {\n    case failedCaching\n}\n```\n调用方法：\n```\ncacheLocally().subscribe(onCompleted: {\n    print(\"completed\")\n}) { (error) in\n    print(\"error:\\(error)\")\n}.disposed(by: disposeBag)\n```\n\n#### Maybe\n`MayBe`介于`Single`和`Completable`之间，它要么只能发出一个元素，要么产生一个`completed`事件，要么产生一个`error`事件。\n- 发出一个元素、或者一个`completed`事件、或者一个`error` 事件\n- 不会共享状态变化\n附：\n```\npublic enum MaybeEvent<Element> {\ncase success(Element)\ncase error(Swift.Error)\ncase completed\n}\n```\n举个🌰：\n```\nfunc generateString() -> Maybe<String>{\n    return Maybe<String>.create(subscribe: { (maybe) -> Disposable in\n    maybe(.success(\"success\"))\n    maybe(.completed)\n    maybe(.error(StringError.failedGenerate))\n    return Disposables.create()\n    })\n}\nenum StringError: Error {\n    case failedGenerate\n}\n```\n调用方法：\n```\ngenerateString().subscribe(onSuccess: { (element) in\n    print(\"success:\\(element)\")\n}, onError: { (error) in\n    print(\"error:\\(error)\")\n}) {\n    print(\"completed\")  \n}.disposed(by: disposeBag)\n```\n#### Driver\n`Driver`准确来说是`RxCocoa`的特征序列，目标是提供一种简便的方式在 UI 层编写响应式代码。\n##### 为什么使用Driver\n[这部分我们引用RxSwift中文文档内容](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html)\n我们举个例子来说明一下，为什么要使用`Driver`\n这是文档简介页的例子:\n```\nlet results = query.rx.text\n                    .throttle(0.3, scheduler: MainScheduler.instance)   \n                    .flatMapLatest { query in\n                        fetchAutoCompleteItems(query)\n                    }\n\nresults\n    .map { \"\\($0.count)\" }\n    .bind(to: resultCount.rx.text)\n    .disposed(by: disposeBag)\n\nresults\n    .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n    cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n这段代码的主要目的是：\n- 取出用户输入稳定后的内容\n- 向服务器请求一组结果\n- 将返回的结果绑定到两个 UI 元素上：`tableView`和 显示结果数量的`label`\n代码存在的问题：\n- 如果`fetchAutoCompleteItems`的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求\n- 如果`fetchAutoCompleteItems`在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃\n- 返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果\n一个更好的方案是这样的：\n```\nlet results = query.rx.text\n    .throttle(0.3, scheduler: MainScheduler.instance)\n    .flatMapLatest { query in\n        fetchAutoCompleteItems(query)\n    .observeOn(MainScheduler.instance)  // 结果在主线程返回\n    .catchErrorJustReturn([])           // 错误被处理了，这样至少不会终止整个序列\n    }\n    .share(replay: 1)                           // HTTP 请求是被共享的\n\nresults\n    .map { \"\\($0.count)\" }\n    .bind(to: resultCount.rx.text)\n    .disposed(by: disposeBag)\n\nresults\n    .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n        cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n在一个大型系统内，要确保每一步不被遗漏是一件不太容易的事情。所以更好的选择是合理运用编译器和特征序列来确保这些必备条件都已经满足。\n以下是使用`Driver`优化后的代码：\n```\nlet results = query.rx.text.asDriver()        // 将普通序列转换为 Driver\n    .throttle(0.3, scheduler: MainScheduler.instance)\n    .flatMapLatest { query in\n        fetchAutoCompleteItems(query)\n            .asDriver(onErrorJustReturn: [])  // 仅仅提供发生错误时的备选返回值\n    }\n\nresults\n    .map { \"\\($0.count)\" }\n    .drive(resultCount.rx.text)               // 这里改用 `drive` 而不是 `bindTo`\n    .disposed(by: disposeBag)                 // 这样可以确保必备条件都已经满足了\n\nresults\n    .drive(resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n        cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n首先第一个`asDriver`方法将`ControlProperty`转换为`Driver`\n然后第二个变化是:\n```\n.asDriver(onErrorJustReturn: [])\n```\n任何可被监听的序列都可以被转换为 Driver，只要他满足 3 个条件:\n- 不会产生 error 事件\n- 一定在 MainScheduler 监听（主线程监听）\n- 共享状态变化\n那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。asDriver(onErrorJustReturn: []) 相当于以下代码\n```\nlet safeSequence = xs\n    .observeOn(MainScheduler.instance)       // 主线程监听\n    .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误\n    .share(replay: 1, scope: .whileConnected)// 共享状态变化\nreturn Driver(raw: safeSequence)           // 封装\n```\n最后使用`drive`而不是`bindTo`。\n#### ControlEvent\n`ControlProperty`是专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（`Observable`），它也是`RxCocoa`的特征序列\n`ControlProperty`具有以下特征：\n- 不会产生`error`事件\n- 一定在`MainScheduler`订阅（主线程订阅）\n- 一定在`MainScheduler`监听（主线程监听）\n- 共享状态变化\n举个🌰：\n```\nimport UIKit\nimport RxSwift\nimport RxCocoa\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var label: UILabel!\n    //负责对象销毁\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        //将textField输入的文字绑定到label上\n        textField.rx.text\n            .bind(to: label.rx.text)\n            .disposed(by: disposeBag)\n        }\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n有人可能会纳闷，这跟`ControlProperty`有什么关系，没看到它的影子啊。我们查看`textField.rx.text`的`text`方法：\n```\nextension Reactive where Base : UITextField {\npublic var text: ControlProperty<String?> {\n        return value\n    }\n\npublic var value: ControlProperty<String?> {\n    return base.rx.controlPropertyWithDefaultEvents(\n        getter: { textField in\n        textField.text\n    },\n        setter: { textField, value in\n            if textField.text != value {\n            textField.text = value\n            }\n        }\n        )\n    }\n}\n```\n原来UITextField 的`rx.text`属性类型便是 `ControlProperty<String?>`\n同时，这段代码也给我们启示，为控件添加属性，可以采用`extension Reactive where Base : UITextField`的方法。\n#### ControlEvent\n`ControlEvent`专门用于描述 UI 控件所产生的事件，它具有跟`ControlProperty`一样的特征：\n- 不会产生`error`事件\n- 一定在`MainScheduler`订阅（主线程订阅）\n- 一定在`MainScheduler`监听（主线程监听）\n- 共享状态变化\n举个🌰：\n```\nimport UIKit\nimport RxSwift\nimport RxCocoa\n\nclass ViewController: UIViewController {\n\n    let disposeBag = DisposeBag()\n\n    @IBOutlet weak var button: UIButton!\n\n    override func viewDidLoad() {\n\n        //订阅按钮点击事件\n        button.rx.tap\n            .subscribe(onNext: {\n                print(\"blick\")\n            }).disposed(by: disposeBag)\n        }\n}\n```\n可能也有人会疑问，`ControlEvent`在哪？查看tap方法，会看到源码（`UIButton+Rx.swift`），这个时候就会发现 UIButton 的`rx.tap`方法类型便是`ControlEvent<Void>`：\n```\nimport RxSwift\nimport UIKit\n\nextension Reactive where Base: UIButton {\npublic var tap: ControlEvent<Void> {\n    return controlEvent(.touchUpInside)\n    }\n}\n```\n至此，我们就对`Observable`有了一个简单的介绍。\n","source":"_posts/RxSwift-Observable-可观察序列.md","raw":"---\ntitle: RxSwift Observable-可观察序列\ndate: 2018-09-20 22:25:46\ntags: RxSwift\n---\n[上一篇](https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more)已经介绍了`Observable`是什么，现在简单介绍一下它怎么创建，以及`RxSwift`里面`Observable`存在的一些特征序列。\n### 常见的创建方法\n####  just() 方法\n该方法通过传入一个默认值完成初始化，并指定了当前`Observable`所发出事件携带的数据类型\n```\nlet observable = Observable<Int>.just(1)\n```\n#### of()方法\n该方法可以接受多个参数来创建实例，但这些参数必须是同类型\n```\nlet observable = Observable.of(\"A\", \"B\", \"C\")\n```\n#### from()方法\n该方法只接收数组作为参数，并抽取出数组里的元素来作为数据流中的元素\n```\nlet observable = Observable.from([\"A\", \"B\", \"C\"])\n```\n#### never()方法\n该方法创建一个永远不会发出`Event`（也不会终止）的 `Observable`序列\n```\nlet observable = Observable<Int>.never()\n```\n#### empty()方法\n该方法创建一个空内容的`Observable`序列\n```\nlet observable = Observable<Int>.empty()\n```\n#### error() 方法\n该方法创建一个不做任何操作，而是直接发送一个错误的`Observable`序列\n```\nenum MyError: Error {\n    case A\n    case B\n}\n\nlet observable = Observable<Int>.error(MyError.A)\n```\n#### range() 方法\n该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的`Observable`序列\n```\nlet observable = Observable.range(start: 1, count: 5)\n```\n#### repeatElement() 方法\n该方法创建一个可以无限发出给定元素的`Event`的`Observable`序列\n```\nlet observable = Observable.repeatElement(1)\n```\n#### generate() 方法\n该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的`Observable`序列\n```\nlet observable = Observable.generate(\n    initialState: 0,\n    condition: { $0 <= 10 },\n    iterate: { $0 + 2 }\n)\n```\n#### interval() 方法\n这个方法创建的`Observable`序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去\n```\nlet observable = Observable<Int>.interval(1, scheduler: MainScheduler.instance)\nobservable.subscribe { event in\n    print(event)\n//next(0) next(1) next(2)......\n}\n```\n#### timer() 方法\n- 创建的`Observable`序列在经过设定的一段时间后，产生唯一的一个元素\n```\n//10秒种后发出唯一的一个元素0\nlet observable = Observable<Int>.timer(10, scheduler: MainScheduler.instance)\nobservable.subscribe { event in\n    print(event)\n}\n```\n- 创建的`Observable`序列在经过设定的一段时间后，每隔一段时间产生一个元素\n```\n//延时10秒种后，每隔1秒钟发出一个元素\nlet observable = Observable<Int>.timer(10, period: 1, scheduler: MainScheduler.instance)\n    observable.subscribe { event in\n    print(event)\n}\n```\n#### create()方法\n该方法接受一个`block`形式的参数，任务是对每一个过来的订阅进行处理\n```\nlet observable = Observable<String>.create { (observer) -> Disposable in\n    observer.onNext(\"test\")\n    observer.onCompleted()\n    return Disposables.create()\n}\nobservable.subscribe { (element) in\n    print(element)\n}\n//next(test)\n//completed\n```\n#### deferred() 方法\n该个方法相当于是创建一个`Observable`工厂，通过传入一个`block`来执行延迟`Observable`序列创建的行为，而这个`block`里就是真正的实例化序列对象的地方\n```\nvar time = 0\nlet factory: Observable<Int> = Observable.deferred {\n    time += 1\n    return Observable.just(time)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\nfactory.subscribe { (event) in\n    print(event)\n}\n/* \n打印结果\nnext(1)\ncompleted\nnext(2)\ncompleted\nnext(3)\ncompleted\nnext(4)\ncompleted\n*/\n```\n### 特征序列\n` Swift`是一个强类型语言，它相对弱类型语言更加严谨。我们可以通过类型来判断出，实例有哪些特征。同样的在`RxSwift` 里面`Observable`也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码，他们分别是`Single`、`Completable`、`Maybe`、`Driver`、`ControlEvent`、`ControlProperty`\n####  Single\n`Single`,在`RxSwift`中,对它的解释是*Represents a push style sequence containing 1 element*，它要么只能发出一个元素，要么产生一个`error`事件\n- 发出一个元素或一个`error`事件\n- 不会共享状态变化\n附：\n```\npublic enum SingleEvent<Element> {\ncase success(Element)\ncase error(Swift.Error)\n}\n```\n比如说，我们利用`Single`实现一个网络请求，返回成功的结果或失败:\n```\nfunc getReop(_ repo: String) -> Single<[String: Any]>{\n    return Single<[String: Any]>.create(subscribe: { (single) -> Disposable in\n        let url = URL.init(string: \"https://api.github.com/repos/\\(repo)\")!\n        let task = URLSession.shared.dataTask(with: url, completionHandler: { (data, response, error) in\n            if let error = error{\n                single(.error(error))\n                return\n            }\n            guard let data = data,\n                let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),\n                let result = json as? [String: Any] else{\n                    single(.error(DataError.cantParseJSON))\n                    return\n                }\n                single(.success(result))\n        })\n        task.resume()\n        return Disposables.create {\n            task.cancel()\n        }\n    })\n}\n//与数据相关的错误类型\nenum DataError: Error {\n    case cantParseJSON\n}\n```\n当我们想调用这个方法的时候:\n```\nlet disposeBag = DisposeBag()\ngetReop(\"ReactiveX/RxSwift\").subscribe(onSuccess: { (json) in\n    print(\"Json:\\(json)\")\n}) { (error) in\n    print(\"error:\\(error)\")\n}.disposed(by: disposeBag)\n```\n\n#### Completable\n`Completable`，在`RxSwift`中，对它的解释*Represents a push style sequence containing 0 elements.*可以理解为表示包含0个元素的推送样式序列，它要么产生`completed`事件，要么产生`error`事件。\n- 不会发出任何元素\n- 只会发出一个`completed`事件或者一个`error`事件\n- 不会共享状态变化\n附：\n```\npublic enum CompletableEvent {\n    case error(Swift.Error)  \n    case completed\n}\n```\n举个🌰:\n```\nfunc cacheLocally() -> Completable {\n    return Completable.create(subscribe: { (completable) -> Disposable in\n    //将数据缓存到本地（这里掠过具体的业务代码，随机成功或失败）\n    let success = (arc4random() % 2 == 0)\n    guard success else {\n        completable(.error(CacheError.failedCaching))\n        return Disposables.create{}\n    }\n    completable(.completed)\n    return Disposables.create()\n    })\n}\nenum CacheError: Error {\n    case failedCaching\n}\n```\n调用方法：\n```\ncacheLocally().subscribe(onCompleted: {\n    print(\"completed\")\n}) { (error) in\n    print(\"error:\\(error)\")\n}.disposed(by: disposeBag)\n```\n\n#### Maybe\n`MayBe`介于`Single`和`Completable`之间，它要么只能发出一个元素，要么产生一个`completed`事件，要么产生一个`error`事件。\n- 发出一个元素、或者一个`completed`事件、或者一个`error` 事件\n- 不会共享状态变化\n附：\n```\npublic enum MaybeEvent<Element> {\ncase success(Element)\ncase error(Swift.Error)\ncase completed\n}\n```\n举个🌰：\n```\nfunc generateString() -> Maybe<String>{\n    return Maybe<String>.create(subscribe: { (maybe) -> Disposable in\n    maybe(.success(\"success\"))\n    maybe(.completed)\n    maybe(.error(StringError.failedGenerate))\n    return Disposables.create()\n    })\n}\nenum StringError: Error {\n    case failedGenerate\n}\n```\n调用方法：\n```\ngenerateString().subscribe(onSuccess: { (element) in\n    print(\"success:\\(element)\")\n}, onError: { (error) in\n    print(\"error:\\(error)\")\n}) {\n    print(\"completed\")  \n}.disposed(by: disposeBag)\n```\n#### Driver\n`Driver`准确来说是`RxCocoa`的特征序列，目标是提供一种简便的方式在 UI 层编写响应式代码。\n##### 为什么使用Driver\n[这部分我们引用RxSwift中文文档内容](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html)\n我们举个例子来说明一下，为什么要使用`Driver`\n这是文档简介页的例子:\n```\nlet results = query.rx.text\n                    .throttle(0.3, scheduler: MainScheduler.instance)   \n                    .flatMapLatest { query in\n                        fetchAutoCompleteItems(query)\n                    }\n\nresults\n    .map { \"\\($0.count)\" }\n    .bind(to: resultCount.rx.text)\n    .disposed(by: disposeBag)\n\nresults\n    .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n    cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n这段代码的主要目的是：\n- 取出用户输入稳定后的内容\n- 向服务器请求一组结果\n- 将返回的结果绑定到两个 UI 元素上：`tableView`和 显示结果数量的`label`\n代码存在的问题：\n- 如果`fetchAutoCompleteItems`的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求\n- 如果`fetchAutoCompleteItems`在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃\n- 返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果\n一个更好的方案是这样的：\n```\nlet results = query.rx.text\n    .throttle(0.3, scheduler: MainScheduler.instance)\n    .flatMapLatest { query in\n        fetchAutoCompleteItems(query)\n    .observeOn(MainScheduler.instance)  // 结果在主线程返回\n    .catchErrorJustReturn([])           // 错误被处理了，这样至少不会终止整个序列\n    }\n    .share(replay: 1)                           // HTTP 请求是被共享的\n\nresults\n    .map { \"\\($0.count)\" }\n    .bind(to: resultCount.rx.text)\n    .disposed(by: disposeBag)\n\nresults\n    .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n        cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n在一个大型系统内，要确保每一步不被遗漏是一件不太容易的事情。所以更好的选择是合理运用编译器和特征序列来确保这些必备条件都已经满足。\n以下是使用`Driver`优化后的代码：\n```\nlet results = query.rx.text.asDriver()        // 将普通序列转换为 Driver\n    .throttle(0.3, scheduler: MainScheduler.instance)\n    .flatMapLatest { query in\n        fetchAutoCompleteItems(query)\n            .asDriver(onErrorJustReturn: [])  // 仅仅提供发生错误时的备选返回值\n    }\n\nresults\n    .map { \"\\($0.count)\" }\n    .drive(resultCount.rx.text)               // 这里改用 `drive` 而不是 `bindTo`\n    .disposed(by: disposeBag)                 // 这样可以确保必备条件都已经满足了\n\nresults\n    .drive(resultsTableView.rx.items(cellIdentifier: \"Cell\")) {\n    (_, result, cell) in\n        cell.textLabel?.text = \"\\(result)\"\n    }\n    .disposed(by: disposeBag)\n```\n首先第一个`asDriver`方法将`ControlProperty`转换为`Driver`\n然后第二个变化是:\n```\n.asDriver(onErrorJustReturn: [])\n```\n任何可被监听的序列都可以被转换为 Driver，只要他满足 3 个条件:\n- 不会产生 error 事件\n- 一定在 MainScheduler 监听（主线程监听）\n- 共享状态变化\n那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。asDriver(onErrorJustReturn: []) 相当于以下代码\n```\nlet safeSequence = xs\n    .observeOn(MainScheduler.instance)       // 主线程监听\n    .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误\n    .share(replay: 1, scope: .whileConnected)// 共享状态变化\nreturn Driver(raw: safeSequence)           // 封装\n```\n最后使用`drive`而不是`bindTo`。\n#### ControlEvent\n`ControlProperty`是专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（`Observable`），它也是`RxCocoa`的特征序列\n`ControlProperty`具有以下特征：\n- 不会产生`error`事件\n- 一定在`MainScheduler`订阅（主线程订阅）\n- 一定在`MainScheduler`监听（主线程监听）\n- 共享状态变化\n举个🌰：\n```\nimport UIKit\nimport RxSwift\nimport RxCocoa\n\nclass ViewController: UIViewController {\n\n    @IBOutlet weak var textField: UITextField!\n    @IBOutlet weak var label: UILabel!\n    //负责对象销毁\n    let disposeBag = DisposeBag()\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        //将textField输入的文字绑定到label上\n        textField.rx.text\n            .bind(to: label.rx.text)\n            .disposed(by: disposeBag)\n        }\n    override func didReceiveMemoryWarning() {\n        super.didReceiveMemoryWarning()\n    }\n}\n```\n有人可能会纳闷，这跟`ControlProperty`有什么关系，没看到它的影子啊。我们查看`textField.rx.text`的`text`方法：\n```\nextension Reactive where Base : UITextField {\npublic var text: ControlProperty<String?> {\n        return value\n    }\n\npublic var value: ControlProperty<String?> {\n    return base.rx.controlPropertyWithDefaultEvents(\n        getter: { textField in\n        textField.text\n    },\n        setter: { textField, value in\n            if textField.text != value {\n            textField.text = value\n            }\n        }\n        )\n    }\n}\n```\n原来UITextField 的`rx.text`属性类型便是 `ControlProperty<String?>`\n同时，这段代码也给我们启示，为控件添加属性，可以采用`extension Reactive where Base : UITextField`的方法。\n#### ControlEvent\n`ControlEvent`专门用于描述 UI 控件所产生的事件，它具有跟`ControlProperty`一样的特征：\n- 不会产生`error`事件\n- 一定在`MainScheduler`订阅（主线程订阅）\n- 一定在`MainScheduler`监听（主线程监听）\n- 共享状态变化\n举个🌰：\n```\nimport UIKit\nimport RxSwift\nimport RxCocoa\n\nclass ViewController: UIViewController {\n\n    let disposeBag = DisposeBag()\n\n    @IBOutlet weak var button: UIButton!\n\n    override func viewDidLoad() {\n\n        //订阅按钮点击事件\n        button.rx.tap\n            .subscribe(onNext: {\n                print(\"blick\")\n            }).disposed(by: disposeBag)\n        }\n}\n```\n可能也有人会疑问，`ControlEvent`在哪？查看tap方法，会看到源码（`UIButton+Rx.swift`），这个时候就会发现 UIButton 的`rx.tap`方法类型便是`ControlEvent<Void>`：\n```\nimport RxSwift\nimport UIKit\n\nextension Reactive where Base: UIButton {\npublic var tap: ControlEvent<Void> {\n    return controlEvent(.touchUpInside)\n    }\n}\n```\n至此，我们就对`Observable`有了一个简单的介绍。\n","slug":"RxSwift-Observable-可观察序列","published":1,"updated":"2018-10-19T07:16:01.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxy4000o2ycweh38rjef","content":"<p><a href=\"https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more\" target=\"_blank\" rel=\"noopener\">上一篇</a>已经介绍了<code>Observable</code>是什么，现在简单介绍一下它怎么创建，以及<code>RxSwift</code>里面<code>Observable</code>存在的一些特征序列。</p>\n<h3 id=\"常见的创建方法\"><a href=\"#常见的创建方法\" class=\"headerlink\" title=\"常见的创建方法\"></a>常见的创建方法</h3><h4 id=\"just-方法\"><a href=\"#just-方法\" class=\"headerlink\" title=\"just() 方法\"></a>just() 方法</h4><p>该方法通过传入一个默认值完成初始化，并指定了当前<code>Observable</code>所发出事件携带的数据类型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.just(1)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"of-方法\"><a href=\"#of-方法\" class=\"headerlink\" title=\"of()方法\"></a>of()方法</h4><p>该方法可以接受多个参数来创建实例，但这些参数必须是同类型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"from-方法\"><a href=\"#from-方法\" class=\"headerlink\" title=\"from()方法\"></a>from()方法</h4><p>该方法只接收数组作为参数，并抽取出数组里的元素来作为数据流中的元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.from([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"never-方法\"><a href=\"#never-方法\" class=\"headerlink\" title=\"never()方法\"></a>never()方法</h4><p>该方法创建一个永远不会发出<code>Event</code>（也不会终止）的 <code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.never()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"empty-方法\"><a href=\"#empty-方法\" class=\"headerlink\" title=\"empty()方法\"></a>empty()方法</h4><p>该方法创建一个空内容的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.empty()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"error-方法\"><a href=\"#error-方法\" class=\"headerlink\" title=\"error() 方法\"></a>error() 方法</h4><p>该方法创建一个不做任何操作，而是直接发送一个错误的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum MyError: Error &#123;</span><br><span class=\"line\">    case A</span><br><span class=\"line\">    case B</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.error(MyError.A)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"range-方法\"><a href=\"#range-方法\" class=\"headerlink\" title=\"range() 方法\"></a>range() 方法</h4><p>该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.range(start: 1, count: 5)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"repeatElement-方法\"><a href=\"#repeatElement-方法\" class=\"headerlink\" title=\"repeatElement() 方法\"></a>repeatElement() 方法</h4><p>该方法创建一个可以无限发出给定元素的<code>Event</code>的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.repeatElement(1)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"generate-方法\"><a href=\"#generate-方法\" class=\"headerlink\" title=\"generate() 方法\"></a>generate() 方法</h4><p>该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.generate(</span><br><span class=\"line\">    initialState: 0,</span><br><span class=\"line\">    condition: &#123; $0 &lt;= 10 &#125;,</span><br><span class=\"line\">    iterate: &#123; $0 + 2 &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"interval-方法\"><a href=\"#interval-方法\" class=\"headerlink\" title=\"interval() 方法\"></a>interval() 方法</h4><p>这个方法创建的<code>Observable</code>序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">//next(0) next(1) next(2)......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"timer-方法\"><a href=\"#timer-方法\" class=\"headerlink\" title=\"timer() 方法\"></a>timer() 方法</h4><ul>\n<li><p>创建的<code>Observable</code>序列在经过设定的一段时间后，产生唯一的一个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//10秒种后发出唯一的一个元素0</span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.timer(10, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建的<code>Observable</code>序列在经过设定的一段时间后，每隔一段时间产生一个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//延时10秒种后，每隔1秒钟发出一个元素</span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.timer(10, period: 1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"create-方法\"><a href=\"#create-方法\" class=\"headerlink\" title=\"create()方法\"></a>create()方法</h4><p>该方法接受一个<code>block</code>形式的参数，任务是对每一个过来的订阅进行处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;String&gt;.create &#123; (observer) -&gt; Disposable in</span><br><span class=\"line\">    observer.onNext(&quot;test&quot;)</span><br><span class=\"line\">    observer.onCompleted()</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">observable.subscribe &#123; (element) in</span><br><span class=\"line\">    print(element)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//next(test)</span><br><span class=\"line\">//completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"deferred-方法\"><a href=\"#deferred-方法\" class=\"headerlink\" title=\"deferred() 方法\"></a>deferred() 方法</h4><p>该个方法相当于是创建一个<code>Observable</code>工厂，通过传入一个<code>block</code>来执行延迟<code>Observable</code>序列创建的行为，而这个<code>block</code>里就是真正的实例化序列对象的地方<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var time = 0</span><br><span class=\"line\">let factory: Observable&lt;Int&gt; = Observable.deferred &#123;</span><br><span class=\"line\">    time += 1</span><br><span class=\"line\">    return Observable.just(time)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* </span><br><span class=\"line\">打印结果</span><br><span class=\"line\">next(1)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(2)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(3)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(4)</span><br><span class=\"line\">completed</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"特征序列\"><a href=\"#特征序列\" class=\"headerlink\" title=\"特征序列\"></a>特征序列</h3><p><code>Swift</code>是一个强类型语言，它相对弱类型语言更加严谨。我们可以通过类型来判断出，实例有哪些特征。同样的在<code>RxSwift</code> 里面<code>Observable</code>也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码，他们分别是<code>Single</code>、<code>Completable</code>、<code>Maybe</code>、<code>Driver</code>、<code>ControlEvent</code>、<code>ControlProperty</code></p>\n<h4 id=\"Single\"><a href=\"#Single\" class=\"headerlink\" title=\"Single\"></a>Single</h4><p><code>Single</code>,在<code>RxSwift</code>中,对它的解释是<em>Represents a push style sequence containing 1 element</em>，它要么只能发出一个元素，要么产生一个<code>error</code>事件</p>\n<ul>\n<li>发出一个元素或一个<code>error</code>事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum SingleEvent&lt;Element&gt; &#123;</span><br><span class=\"line\">case success(Element)</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>比如说，我们利用<code>Single</code>实现一个网络请求，返回成功的结果或失败:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func getReop(_ repo: String) -&gt; Single&lt;[String: Any]&gt;&#123;</span><br><span class=\"line\">    return Single&lt;[String: Any]&gt;.create(subscribe: &#123; (single) -&gt; Disposable in</span><br><span class=\"line\">        let url = URL.init(string: &quot;https://api.github.com/repos/\\(repo)&quot;)!</span><br><span class=\"line\">        let task = URLSession.shared.dataTask(with: url, completionHandler: &#123; (data, response, error) in</span><br><span class=\"line\">            if let error = error&#123;</span><br><span class=\"line\">                single(.error(error))</span><br><span class=\"line\">                return</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            guard let data = data,</span><br><span class=\"line\">                let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),</span><br><span class=\"line\">                let result = json as? [String: Any] else&#123;</span><br><span class=\"line\">                    single(.error(DataError.cantParseJSON))</span><br><span class=\"line\">                    return</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                single(.success(result))</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        task.resume()</span><br><span class=\"line\">        return Disposables.create &#123;</span><br><span class=\"line\">            task.cancel()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//与数据相关的错误类型</span><br><span class=\"line\">enum DataError: Error &#123;</span><br><span class=\"line\">    case cantParseJSON</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当我们想调用这个方法的时候:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">getReop(&quot;ReactiveX/RxSwift&quot;).subscribe(onSuccess: &#123; (json) in</span><br><span class=\"line\">    print(&quot;Json:\\(json)&quot;)</span><br><span class=\"line\">&#125;) &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Completable\"><a href=\"#Completable\" class=\"headerlink\" title=\"Completable\"></a>Completable</h4><p><code>Completable</code>，在<code>RxSwift</code>中，对它的解释<em>Represents a push style sequence containing 0 elements.</em>可以理解为表示包含0个元素的推送样式序列，它要么产生<code>completed</code>事件，要么产生<code>error</code>事件。</p>\n<ul>\n<li>不会发出任何元素</li>\n<li>只会发出一个<code>completed</code>事件或者一个<code>error</code>事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum CompletableEvent &#123;</span><br><span class=\"line\">    case error(Swift.Error)  </span><br><span class=\"line\">    case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>举个🌰:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func cacheLocally() -&gt; Completable &#123;</span><br><span class=\"line\">    return Completable.create(subscribe: &#123; (completable) -&gt; Disposable in</span><br><span class=\"line\">    //将数据缓存到本地（这里掠过具体的业务代码，随机成功或失败）</span><br><span class=\"line\">    let success = (arc4random() % 2 == 0)</span><br><span class=\"line\">    guard success else &#123;</span><br><span class=\"line\">        completable(.error(CacheError.failedCaching))</span><br><span class=\"line\">        return Disposables.create&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    completable(.completed)</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum CacheError: Error &#123;</span><br><span class=\"line\">    case failedCaching</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cacheLocally().subscribe(onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;) &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Maybe\"><a href=\"#Maybe\" class=\"headerlink\" title=\"Maybe\"></a>Maybe</h4><p><code>MayBe</code>介于<code>Single</code>和<code>Completable</code>之间，它要么只能发出一个元素，要么产生一个<code>completed</code>事件，要么产生一个<code>error</code>事件。</p>\n<ul>\n<li>发出一个元素、或者一个<code>completed</code>事件、或者一个<code>error</code> 事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum MaybeEvent&lt;Element&gt; &#123;</span><br><span class=\"line\">case success(Element)</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func generateString() -&gt; Maybe&lt;String&gt;&#123;</span><br><span class=\"line\">    return Maybe&lt;String&gt;.create(subscribe: &#123; (maybe) -&gt; Disposable in</span><br><span class=\"line\">    maybe(.success(&quot;success&quot;))</span><br><span class=\"line\">    maybe(.completed)</span><br><span class=\"line\">    maybe(.error(StringError.failedGenerate))</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum StringError: Error &#123;</span><br><span class=\"line\">    case failedGenerate</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">generateString().subscribe(onSuccess: &#123; (element) in</span><br><span class=\"line\">    print(&quot;success:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onError: &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)  </span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Driver\"><a href=\"#Driver\" class=\"headerlink\" title=\"Driver\"></a>Driver</h4><p><code>Driver</code>准确来说是<code>RxCocoa</code>的特征序列，目标是提供一种简便的方式在 UI 层编写响应式代码。</p>\n<h5 id=\"为什么使用Driver\"><a href=\"#为什么使用Driver\" class=\"headerlink\" title=\"为什么使用Driver\"></a>为什么使用Driver</h5><p><a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html\" target=\"_blank\" rel=\"noopener\">这部分我们引用RxSwift中文文档内容</a><br>我们举个例子来说明一下，为什么要使用<code>Driver</code><br>这是文档简介页的例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text</span><br><span class=\"line\">                    .throttle(0.3, scheduler: MainScheduler.instance)   </span><br><span class=\"line\">                    .flatMapLatest &#123; query in</span><br><span class=\"line\">                        fetchAutoCompleteItems(query)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .bind(to: resultCount.rx.text)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">    cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>这段代码的主要目的是：</p>\n<ul>\n<li>取出用户输入稳定后的内容</li>\n<li>向服务器请求一组结果</li>\n<li>将返回的结果绑定到两个 UI 元素上：<code>tableView</code>和 显示结果数量的<code>label</code><br>代码存在的问题：</li>\n<li>如果<code>fetchAutoCompleteItems</code>的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求</li>\n<li>如果<code>fetchAutoCompleteItems</code>在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃</li>\n<li>返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果<br>一个更好的方案是这样的：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text</span><br><span class=\"line\">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .flatMapLatest &#123; query in</span><br><span class=\"line\">        fetchAutoCompleteItems(query)</span><br><span class=\"line\">    .observeOn(MainScheduler.instance)  // 结果在主线程返回</span><br><span class=\"line\">    .catchErrorJustReturn([])           // 错误被处理了，这样至少不会终止整个序列</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .share(replay: 1)                           // HTTP 请求是被共享的</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .bind(to: resultCount.rx.text)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">        cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在一个大型系统内，要确保每一步不被遗漏是一件不太容易的事情。所以更好的选择是合理运用编译器和特征序列来确保这些必备条件都已经满足。<br>以下是使用<code>Driver</code>优化后的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text.asDriver()        // 将普通序列转换为 Driver</span><br><span class=\"line\">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .flatMapLatest &#123; query in</span><br><span class=\"line\">        fetchAutoCompleteItems(query)</span><br><span class=\"line\">            .asDriver(onErrorJustReturn: [])  // 仅仅提供发生错误时的备选返回值</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .drive(resultCount.rx.text)               // 这里改用 `drive` 而不是 `bindTo`</span><br><span class=\"line\">    .disposed(by: disposeBag)                 // 这样可以确保必备条件都已经满足了</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">        cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>首先第一个<code>asDriver</code>方法将<code>ControlProperty</code>转换为<code>Driver</code><br>然后第二个变化是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.asDriver(onErrorJustReturn: [])</span><br></pre></td></tr></table></figure></p>\n<p>任何可被监听的序列都可以被转换为 Driver，只要他满足 3 个条件:</p>\n<ul>\n<li>不会产生 error 事件</li>\n<li>一定在 MainScheduler 监听（主线程监听）</li>\n<li>共享状态变化<br>那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。asDriver(onErrorJustReturn: []) 相当于以下代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let safeSequence = xs</span><br><span class=\"line\">    .observeOn(MainScheduler.instance)       // 主线程监听</span><br><span class=\"line\">    .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误</span><br><span class=\"line\">    .share(replay: 1, scope: .whileConnected)// 共享状态变化</span><br><span class=\"line\">return Driver(raw: safeSequence)           // 封装</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最后使用<code>drive</code>而不是<code>bindTo</code>。</p>\n<h4 id=\"ControlEvent\"><a href=\"#ControlEvent\" class=\"headerlink\" title=\"ControlEvent\"></a>ControlEvent</h4><p><code>ControlProperty</code>是专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（<code>Observable</code>），它也是<code>RxCocoa</code>的特征序列<br><code>ControlProperty</code>具有以下特征：</p>\n<ul>\n<li>不会产生<code>error</code>事件</li>\n<li>一定在<code>MainScheduler</code>订阅（主线程订阅）</li>\n<li>一定在<code>MainScheduler</code>监听（主线程监听）</li>\n<li>共享状态变化<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var textField: UITextField!</span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    //负责对象销毁</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        //将textField输入的文字绑定到label上</span><br><span class=\"line\">        textField.rx.text</span><br><span class=\"line\">            .bind(to: label.rx.text)</span><br><span class=\"line\">            .disposed(by: disposeBag)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>有人可能会纳闷，这跟<code>ControlProperty</code>有什么关系，没看到它的影子啊。我们查看<code>textField.rx.text</code>的<code>text</code>方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Reactive where Base : UITextField &#123;</span><br><span class=\"line\">public var text: ControlProperty&lt;String?&gt; &#123;</span><br><span class=\"line\">        return value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public var value: ControlProperty&lt;String?&gt; &#123;</span><br><span class=\"line\">    return base.rx.controlPropertyWithDefaultEvents(</span><br><span class=\"line\">        getter: &#123; textField in</span><br><span class=\"line\">        textField.text</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">        setter: &#123; textField, value in</span><br><span class=\"line\">            if textField.text != value &#123;</span><br><span class=\"line\">            textField.text = value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原来UITextField 的<code>rx.text</code>属性类型便是 <code>ControlProperty&lt;String?&gt;</code><br>同时，这段代码也给我们启示，为控件添加属性，可以采用<code>extension Reactive where Base : UITextField</code>的方法。</p>\n<h4 id=\"ControlEvent-1\"><a href=\"#ControlEvent-1\" class=\"headerlink\" title=\"ControlEvent\"></a>ControlEvent</h4><p><code>ControlEvent</code>专门用于描述 UI 控件所产生的事件，它具有跟<code>ControlProperty</code>一样的特征：</p>\n<ul>\n<li>不会产生<code>error</code>事件</li>\n<li>一定在<code>MainScheduler</code>订阅（主线程订阅）</li>\n<li>一定在<code>MainScheduler</code>监听（主线程监听）</li>\n<li>共享状态变化<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var button: UIButton!</span><br><span class=\"line\"></span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        //订阅按钮点击事件</span><br><span class=\"line\">        button.rx.tap</span><br><span class=\"line\">            .subscribe(onNext: &#123;</span><br><span class=\"line\">                print(&quot;blick&quot;)</span><br><span class=\"line\">            &#125;).disposed(by: disposeBag)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可能也有人会疑问，<code>ControlEvent</code>在哪？查看tap方法，会看到源码（<code>UIButton+Rx.swift</code>），这个时候就会发现 UIButton 的<code>rx.tap</code>方法类型便是<code>ControlEvent&lt;Void&gt;</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import RxSwift</span><br><span class=\"line\">import UIKit</span><br><span class=\"line\"></span><br><span class=\"line\">extension Reactive where Base: UIButton &#123;</span><br><span class=\"line\">public var tap: ControlEvent&lt;Void&gt; &#123;</span><br><span class=\"line\">    return controlEvent(.touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，我们就对<code>Observable</code>有了一个简单的介绍。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://darren1192.github.io/2018/09/19/RxSwift-%E6%A0%B8%E5%BF%83/#more\" target=\"_blank\" rel=\"noopener\">上一篇</a>已经介绍了<code>Observable</code>是什么，现在简单介绍一下它怎么创建，以及<code>RxSwift</code>里面<code>Observable</code>存在的一些特征序列。</p>\n<h3 id=\"常见的创建方法\"><a href=\"#常见的创建方法\" class=\"headerlink\" title=\"常见的创建方法\"></a>常见的创建方法</h3><h4 id=\"just-方法\"><a href=\"#just-方法\" class=\"headerlink\" title=\"just() 方法\"></a>just() 方法</h4><p>该方法通过传入一个默认值完成初始化，并指定了当前<code>Observable</code>所发出事件携带的数据类型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.just(1)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"of-方法\"><a href=\"#of-方法\" class=\"headerlink\" title=\"of()方法\"></a>of()方法</h4><p>该方法可以接受多个参数来创建实例，但这些参数必须是同类型<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"from-方法\"><a href=\"#from-方法\" class=\"headerlink\" title=\"from()方法\"></a>from()方法</h4><p>该方法只接收数组作为参数，并抽取出数组里的元素来作为数据流中的元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.from([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"never-方法\"><a href=\"#never-方法\" class=\"headerlink\" title=\"never()方法\"></a>never()方法</h4><p>该方法创建一个永远不会发出<code>Event</code>（也不会终止）的 <code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.never()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"empty-方法\"><a href=\"#empty-方法\" class=\"headerlink\" title=\"empty()方法\"></a>empty()方法</h4><p>该方法创建一个空内容的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.empty()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"error-方法\"><a href=\"#error-方法\" class=\"headerlink\" title=\"error() 方法\"></a>error() 方法</h4><p>该方法创建一个不做任何操作，而是直接发送一个错误的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum MyError: Error &#123;</span><br><span class=\"line\">    case A</span><br><span class=\"line\">    case B</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.error(MyError.A)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"range-方法\"><a href=\"#range-方法\" class=\"headerlink\" title=\"range() 方法\"></a>range() 方法</h4><p>该方法通过指定起始和结束数值，创建一个以这个范围内所有值作为初始值的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.range(start: 1, count: 5)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"repeatElement-方法\"><a href=\"#repeatElement-方法\" class=\"headerlink\" title=\"repeatElement() 方法\"></a>repeatElement() 方法</h4><p>该方法创建一个可以无限发出给定元素的<code>Event</code>的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.repeatElement(1)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"generate-方法\"><a href=\"#generate-方法\" class=\"headerlink\" title=\"generate() 方法\"></a>generate() 方法</h4><p>该方法创建一个只有当提供的所有的判断条件都为 true 的时候，才会给出动作的<code>Observable</code>序列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable.generate(</span><br><span class=\"line\">    initialState: 0,</span><br><span class=\"line\">    condition: &#123; $0 &lt;= 10 &#125;,</span><br><span class=\"line\">    iterate: &#123; $0 + 2 &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"interval-方法\"><a href=\"#interval-方法\" class=\"headerlink\" title=\"interval() 方法\"></a>interval() 方法</h4><p>这个方法创建的<code>Observable</code>序列每隔一段设定的时间，会发出一个索引数的元素。而且它会一直发送下去<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;Int&gt;.interval(1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">//next(0) next(1) next(2)......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"timer-方法\"><a href=\"#timer-方法\" class=\"headerlink\" title=\"timer() 方法\"></a>timer() 方法</h4><ul>\n<li><p>创建的<code>Observable</code>序列在经过设定的一段时间后，产生唯一的一个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//10秒种后发出唯一的一个元素0</span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.timer(10, scheduler: MainScheduler.instance)</span><br><span class=\"line\">observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建的<code>Observable</code>序列在经过设定的一段时间后，每隔一段时间产生一个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//延时10秒种后，每隔1秒钟发出一个元素</span><br><span class=\"line\">let observable = Observable&lt;Int&gt;.timer(10, period: 1, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    observable.subscribe &#123; event in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"create-方法\"><a href=\"#create-方法\" class=\"headerlink\" title=\"create()方法\"></a>create()方法</h4><p>该方法接受一个<code>block</code>形式的参数，任务是对每一个过来的订阅进行处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = Observable&lt;String&gt;.create &#123; (observer) -&gt; Disposable in</span><br><span class=\"line\">    observer.onNext(&quot;test&quot;)</span><br><span class=\"line\">    observer.onCompleted()</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">observable.subscribe &#123; (element) in</span><br><span class=\"line\">    print(element)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//next(test)</span><br><span class=\"line\">//completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"deferred-方法\"><a href=\"#deferred-方法\" class=\"headerlink\" title=\"deferred() 方法\"></a>deferred() 方法</h4><p>该个方法相当于是创建一个<code>Observable</code>工厂，通过传入一个<code>block</code>来执行延迟<code>Observable</code>序列创建的行为，而这个<code>block</code>里就是真正的实例化序列对象的地方<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var time = 0</span><br><span class=\"line\">let factory: Observable&lt;Int&gt; = Observable.deferred &#123;</span><br><span class=\"line\">    time += 1</span><br><span class=\"line\">    return Observable.just(time)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factory.subscribe &#123; (event) in</span><br><span class=\"line\">    print(event)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/* </span><br><span class=\"line\">打印结果</span><br><span class=\"line\">next(1)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(2)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(3)</span><br><span class=\"line\">completed</span><br><span class=\"line\">next(4)</span><br><span class=\"line\">completed</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"特征序列\"><a href=\"#特征序列\" class=\"headerlink\" title=\"特征序列\"></a>特征序列</h3><p><code>Swift</code>是一个强类型语言，它相对弱类型语言更加严谨。我们可以通过类型来判断出，实例有哪些特征。同样的在<code>RxSwift</code> 里面<code>Observable</code>也存在一些特征序列，这些特征序列可以帮助我们更准确的描述序列。并且它们还可以给我们提供语法糖，让我们能够用更加优雅的方式书写代码，他们分别是<code>Single</code>、<code>Completable</code>、<code>Maybe</code>、<code>Driver</code>、<code>ControlEvent</code>、<code>ControlProperty</code></p>\n<h4 id=\"Single\"><a href=\"#Single\" class=\"headerlink\" title=\"Single\"></a>Single</h4><p><code>Single</code>,在<code>RxSwift</code>中,对它的解释是<em>Represents a push style sequence containing 1 element</em>，它要么只能发出一个元素，要么产生一个<code>error</code>事件</p>\n<ul>\n<li>发出一个元素或一个<code>error</code>事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum SingleEvent&lt;Element&gt; &#123;</span><br><span class=\"line\">case success(Element)</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>比如说，我们利用<code>Single</code>实现一个网络请求，返回成功的结果或失败:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func getReop(_ repo: String) -&gt; Single&lt;[String: Any]&gt;&#123;</span><br><span class=\"line\">    return Single&lt;[String: Any]&gt;.create(subscribe: &#123; (single) -&gt; Disposable in</span><br><span class=\"line\">        let url = URL.init(string: &quot;https://api.github.com/repos/\\(repo)&quot;)!</span><br><span class=\"line\">        let task = URLSession.shared.dataTask(with: url, completionHandler: &#123; (data, response, error) in</span><br><span class=\"line\">            if let error = error&#123;</span><br><span class=\"line\">                single(.error(error))</span><br><span class=\"line\">                return</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            guard let data = data,</span><br><span class=\"line\">                let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),</span><br><span class=\"line\">                let result = json as? [String: Any] else&#123;</span><br><span class=\"line\">                    single(.error(DataError.cantParseJSON))</span><br><span class=\"line\">                    return</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                single(.success(result))</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        task.resume()</span><br><span class=\"line\">        return Disposables.create &#123;</span><br><span class=\"line\">            task.cancel()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//与数据相关的错误类型</span><br><span class=\"line\">enum DataError: Error &#123;</span><br><span class=\"line\">    case cantParseJSON</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当我们想调用这个方法的时候:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">getReop(&quot;ReactiveX/RxSwift&quot;).subscribe(onSuccess: &#123; (json) in</span><br><span class=\"line\">    print(&quot;Json:\\(json)&quot;)</span><br><span class=\"line\">&#125;) &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Completable\"><a href=\"#Completable\" class=\"headerlink\" title=\"Completable\"></a>Completable</h4><p><code>Completable</code>，在<code>RxSwift</code>中，对它的解释<em>Represents a push style sequence containing 0 elements.</em>可以理解为表示包含0个元素的推送样式序列，它要么产生<code>completed</code>事件，要么产生<code>error</code>事件。</p>\n<ul>\n<li>不会发出任何元素</li>\n<li>只会发出一个<code>completed</code>事件或者一个<code>error</code>事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum CompletableEvent &#123;</span><br><span class=\"line\">    case error(Swift.Error)  </span><br><span class=\"line\">    case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>举个🌰:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func cacheLocally() -&gt; Completable &#123;</span><br><span class=\"line\">    return Completable.create(subscribe: &#123; (completable) -&gt; Disposable in</span><br><span class=\"line\">    //将数据缓存到本地（这里掠过具体的业务代码，随机成功或失败）</span><br><span class=\"line\">    let success = (arc4random() % 2 == 0)</span><br><span class=\"line\">    guard success else &#123;</span><br><span class=\"line\">        completable(.error(CacheError.failedCaching))</span><br><span class=\"line\">        return Disposables.create&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    completable(.completed)</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum CacheError: Error &#123;</span><br><span class=\"line\">    case failedCaching</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cacheLocally().subscribe(onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;) &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Maybe\"><a href=\"#Maybe\" class=\"headerlink\" title=\"Maybe\"></a>Maybe</h4><p><code>MayBe</code>介于<code>Single</code>和<code>Completable</code>之间，它要么只能发出一个元素，要么产生一个<code>completed</code>事件，要么产生一个<code>error</code>事件。</p>\n<ul>\n<li>发出一个元素、或者一个<code>completed</code>事件、或者一个<code>error</code> 事件</li>\n<li>不会共享状态变化<br>附：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum MaybeEvent&lt;Element&gt; &#123;</span><br><span class=\"line\">case success(Element)</span><br><span class=\"line\">case error(Swift.Error)</span><br><span class=\"line\">case completed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func generateString() -&gt; Maybe&lt;String&gt;&#123;</span><br><span class=\"line\">    return Maybe&lt;String&gt;.create(subscribe: &#123; (maybe) -&gt; Disposable in</span><br><span class=\"line\">    maybe(.success(&quot;success&quot;))</span><br><span class=\"line\">    maybe(.completed)</span><br><span class=\"line\">    maybe(.error(StringError.failedGenerate))</span><br><span class=\"line\">    return Disposables.create()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">enum StringError: Error &#123;</span><br><span class=\"line\">    case failedGenerate</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">generateString().subscribe(onSuccess: &#123; (element) in</span><br><span class=\"line\">    print(&quot;success:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onError: &#123; (error) in</span><br><span class=\"line\">    print(&quot;error:\\(error)&quot;)</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)  </span><br><span class=\"line\">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Driver\"><a href=\"#Driver\" class=\"headerlink\" title=\"Driver\"></a>Driver</h4><p><code>Driver</code>准确来说是<code>RxCocoa</code>的特征序列，目标是提供一种简便的方式在 UI 层编写响应式代码。</p>\n<h5 id=\"为什么使用Driver\"><a href=\"#为什么使用Driver\" class=\"headerlink\" title=\"为什么使用Driver\"></a>为什么使用Driver</h5><p><a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observable/driver.html\" target=\"_blank\" rel=\"noopener\">这部分我们引用RxSwift中文文档内容</a><br>我们举个例子来说明一下，为什么要使用<code>Driver</code><br>这是文档简介页的例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text</span><br><span class=\"line\">                    .throttle(0.3, scheduler: MainScheduler.instance)   </span><br><span class=\"line\">                    .flatMapLatest &#123; query in</span><br><span class=\"line\">                        fetchAutoCompleteItems(query)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .bind(to: resultCount.rx.text)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">    cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>这段代码的主要目的是：</p>\n<ul>\n<li>取出用户输入稳定后的内容</li>\n<li>向服务器请求一组结果</li>\n<li>将返回的结果绑定到两个 UI 元素上：<code>tableView</code>和 显示结果数量的<code>label</code><br>代码存在的问题：</li>\n<li>如果<code>fetchAutoCompleteItems</code>的序列产生了一个错误（网络请求失败），这个错误将取消所有绑定，当用户输入一个新的关键字时，是无法发起新的网络请求</li>\n<li>如果<code>fetchAutoCompleteItems</code>在后台返回序列，那么刷新页面也会在后台进行，这样就会出现异常崩溃</li>\n<li>返回的结果被绑定到两个 UI 元素上。那就意味着，每次用户输入一个新的关键字时，就会分别为两个 UI 元素发起 HTTP 请求，这并不是我们想要的结果<br>一个更好的方案是这样的：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text</span><br><span class=\"line\">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .flatMapLatest &#123; query in</span><br><span class=\"line\">        fetchAutoCompleteItems(query)</span><br><span class=\"line\">    .observeOn(MainScheduler.instance)  // 结果在主线程返回</span><br><span class=\"line\">    .catchErrorJustReturn([])           // 错误被处理了，这样至少不会终止整个序列</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .share(replay: 1)                           // HTTP 请求是被共享的</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .bind(to: resultCount.rx.text)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">        cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在一个大型系统内，要确保每一步不被遗漏是一件不太容易的事情。所以更好的选择是合理运用编译器和特征序列来确保这些必备条件都已经满足。<br>以下是使用<code>Driver</code>优化后的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let results = query.rx.text.asDriver()        // 将普通序列转换为 Driver</span><br><span class=\"line\">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class=\"line\">    .flatMapLatest &#123; query in</span><br><span class=\"line\">        fetchAutoCompleteItems(query)</span><br><span class=\"line\">            .asDriver(onErrorJustReturn: [])  // 仅仅提供发生错误时的备选返回值</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .map &#123; &quot;\\($0.count)&quot; &#125;</span><br><span class=\"line\">    .drive(resultCount.rx.text)               // 这里改用 `drive` 而不是 `bindTo`</span><br><span class=\"line\">    .disposed(by: disposeBag)                 // 这样可以确保必备条件都已经满足了</span><br><span class=\"line\"></span><br><span class=\"line\">results</span><br><span class=\"line\">    .drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class=\"line\">    (_, result, cell) in</span><br><span class=\"line\">        cell.textLabel?.text = &quot;\\(result)&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>首先第一个<code>asDriver</code>方法将<code>ControlProperty</code>转换为<code>Driver</code><br>然后第二个变化是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.asDriver(onErrorJustReturn: [])</span><br></pre></td></tr></table></figure></p>\n<p>任何可被监听的序列都可以被转换为 Driver，只要他满足 3 个条件:</p>\n<ul>\n<li>不会产生 error 事件</li>\n<li>一定在 MainScheduler 监听（主线程监听）</li>\n<li>共享状态变化<br>那么要如何确定条件都被满足？通过 Rx 操作符来进行转换。asDriver(onErrorJustReturn: []) 相当于以下代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let safeSequence = xs</span><br><span class=\"line\">    .observeOn(MainScheduler.instance)       // 主线程监听</span><br><span class=\"line\">    .catchErrorJustReturn(onErrorJustReturn) // 无法产生错误</span><br><span class=\"line\">    .share(replay: 1, scope: .whileConnected)// 共享状态变化</span><br><span class=\"line\">return Driver(raw: safeSequence)           // 封装</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>最后使用<code>drive</code>而不是<code>bindTo</code>。</p>\n<h4 id=\"ControlEvent\"><a href=\"#ControlEvent\" class=\"headerlink\" title=\"ControlEvent\"></a>ControlEvent</h4><p><code>ControlProperty</code>是专门用来描述 UI 控件属性，拥有该类型的属性都是被观察者（<code>Observable</code>），它也是<code>RxCocoa</code>的特征序列<br><code>ControlProperty</code>具有以下特征：</p>\n<ul>\n<li>不会产生<code>error</code>事件</li>\n<li>一定在<code>MainScheduler</code>订阅（主线程订阅）</li>\n<li>一定在<code>MainScheduler</code>监听（主线程监听）</li>\n<li>共享状态变化<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var textField: UITextField!</span><br><span class=\"line\">    @IBOutlet weak var label: UILabel!</span><br><span class=\"line\">    //负责对象销毁</span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\">        super.viewDidLoad()</span><br><span class=\"line\">        //将textField输入的文字绑定到label上</span><br><span class=\"line\">        textField.rx.text</span><br><span class=\"line\">            .bind(to: label.rx.text)</span><br><span class=\"line\">            .disposed(by: disposeBag)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    override func didReceiveMemoryWarning() &#123;</span><br><span class=\"line\">        super.didReceiveMemoryWarning()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>有人可能会纳闷，这跟<code>ControlProperty</code>有什么关系，没看到它的影子啊。我们查看<code>textField.rx.text</code>的<code>text</code>方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Reactive where Base : UITextField &#123;</span><br><span class=\"line\">public var text: ControlProperty&lt;String?&gt; &#123;</span><br><span class=\"line\">        return value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public var value: ControlProperty&lt;String?&gt; &#123;</span><br><span class=\"line\">    return base.rx.controlPropertyWithDefaultEvents(</span><br><span class=\"line\">        getter: &#123; textField in</span><br><span class=\"line\">        textField.text</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">        setter: &#123; textField, value in</span><br><span class=\"line\">            if textField.text != value &#123;</span><br><span class=\"line\">            textField.text = value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原来UITextField 的<code>rx.text</code>属性类型便是 <code>ControlProperty&lt;String?&gt;</code><br>同时，这段代码也给我们启示，为控件添加属性，可以采用<code>extension Reactive where Base : UITextField</code>的方法。</p>\n<h4 id=\"ControlEvent-1\"><a href=\"#ControlEvent-1\" class=\"headerlink\" title=\"ControlEvent\"></a>ControlEvent</h4><p><code>ControlEvent</code>专门用于描述 UI 控件所产生的事件，它具有跟<code>ControlProperty</code>一样的特征：</p>\n<ul>\n<li>不会产生<code>error</code>事件</li>\n<li>一定在<code>MainScheduler</code>订阅（主线程订阅）</li>\n<li>一定在<code>MainScheduler</code>监听（主线程监听）</li>\n<li>共享状态变化<br>举个🌰：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import UIKit</span><br><span class=\"line\">import RxSwift</span><br><span class=\"line\">import RxCocoa</span><br><span class=\"line\"></span><br><span class=\"line\">class ViewController: UIViewController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    let disposeBag = DisposeBag()</span><br><span class=\"line\"></span><br><span class=\"line\">    @IBOutlet weak var button: UIButton!</span><br><span class=\"line\"></span><br><span class=\"line\">    override func viewDidLoad() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        //订阅按钮点击事件</span><br><span class=\"line\">        button.rx.tap</span><br><span class=\"line\">            .subscribe(onNext: &#123;</span><br><span class=\"line\">                print(&quot;blick&quot;)</span><br><span class=\"line\">            &#125;).disposed(by: disposeBag)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可能也有人会疑问，<code>ControlEvent</code>在哪？查看tap方法，会看到源码（<code>UIButton+Rx.swift</code>），这个时候就会发现 UIButton 的<code>rx.tap</code>方法类型便是<code>ControlEvent&lt;Void&gt;</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import RxSwift</span><br><span class=\"line\">import UIKit</span><br><span class=\"line\"></span><br><span class=\"line\">extension Reactive where Base: UIButton &#123;</span><br><span class=\"line\">public var tap: ControlEvent&lt;Void&gt; &#123;</span><br><span class=\"line\">    return controlEvent(.touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，我们就对<code>Observable</code>有了一个简单的介绍。</p>\n"},{"title":"RxSwift 操作符决策树","date":"2018-09-30T13:59:24.000Z","_content":"之前列举了很多操作符的用法，还有很多我们没有列举的。其实写了那么多操作符有时候我还是会忘记选择哪一个。这个时候，我发现在[RxSwift中文文档](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html)有一篇关于选择操作符的文章。这一篇水文纯搬运。\n### 决策树\n\n**我想要创建一个 `Observable`**\n\n*   产生特定的一个元素：[just](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/just.html)\n*   经过一段延时：[timer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html)\n*   从一个序列拉取元素：[from](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/from.html)\n*   重复的产生某一个元素：[repeatElement](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/repeatElement.html)\n*   存在自定义逻辑：[create](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/create.html)\n*   每次订阅时产生：[deferred](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/deferred.html)\n*   每隔一段时间，发出一个元素：[interval](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/interval.html)\n*   在一段延时后：[timer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html)\n*   一个空序列，只有一个完成事件：[empty](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/empty.html)\n*   一个任何事件都没有产生的序列：[never](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/never.html)\n\n**我想要创建一个 `Observable` 通过组合其他的 `Observables`**\n\n*   任意一个 `Observable` 产生了元素，就发出这个元素：[merge](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/merge.html)\n*   让这些 `Observables` 一个接一个的发出元素，当上一个 `Observable` 元素发送完毕后，下一个`Observable` 才能开始发出元素：[concat](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concat.html)\n*   组合多个 `Observables` 的元素\n*   当每一个 `Observable` 都发出一个新的元素：[zip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/zip.html)\n*   当任意一个 `Observable` 发出一个新的元素：[combineLatest](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/combineLatest.html)\n\n**我想要转换 `Observable` 的元素后，再将它们发出来**\n\n*   对每个元素直接转换：[map](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/map.html)\n*   转换到另一个 `Observable`：[flatMap](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMap.html)\n*   只接收最新的元素转换的 `Observable` 所产生的元素：[flatMapLatest](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMapLatest.html)\n*   每一个元素转换的 `Observable` 按顺序产生元素：[concatMap](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concatMap.html)\n*   基于所有遍历过的元素： [scan](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html)\n\n**我想要将产生的每一个元素，拖延一段时间后再发出：[delay](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delay.html)**\n\n**我想要将产生的事件封装成元素发送出来**\n\n*   将他们封装成 `Event<Element>`：[materialize](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/materialize.html)\n*   然后解封出来：[dematerialize](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/dematerialize.html)\n\n**我想要忽略掉所有的 `next` 事件，只接收 `completed` 和 `error` 事件：[ignoreElements](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/ignoreElements.html)**\n\n**我想创建一个新的 `Observable` 在原有的序列前面加入一些元素：[startWith](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/startWith.html)**\n\n**我想从 `Observable` 中收集元素，缓存这些元素之后在发出：[buffer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/buffer.html)**\n\n**我想将 `Observable` 拆分成多个 `Observables`：[window](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/window.html)**\n\n*   基于元素的共同特征：[groupBy](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/groupBy.html)\n\n**我想只接收 `Observable` 中特定的元素**\n\n*   发出唯一的元素：[single](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/single.html)\n\n**我想重新从 `Observable` 中发出某些元素**\n\n*   通过判定条件过滤出一些元素：[filter](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/filter.html)\n*   仅仅发出头几个元素：[take](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html)\n*   仅仅发出尾部的几个元素：[takeLast](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeLast.html)\n*   仅仅发出第 n 个元素：[elementAt](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/elementAt.html)\n*   跳过头几个元素\n*   跳过头 n 个元素：[skip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html)\n*   跳过头几个满足判定的元素：[skipWhile](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html)，[skipWhileWithIndex](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html)\n*   跳过某段时间内产生的头几个元素：[skip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html)\n*   跳过头几个元素直到另一个 `Observable` 发出一个元素：[skipUntil](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipUntil.html)\n*   只取头几个元素\n*   只取头几个满足判定的元素：[takeWhile](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html)，[takeWhileWithIndex](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html)\n*   只取某段时间内产生的头几个元素：[take](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html)\n*   只取头几个元素直到另一个 `Observable` 发出一个元素：[takeUntil](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeUntil.html)\n*   周期性的对 `Observable` 抽样：[sample](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/sample.html)\n*   发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生：[debounce](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/debounce.html)\n*   直到元素的值发生变化，才发出新的元素：[distinctUntilChanged](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html)\n*   并提供元素是否相等的判定函数：[distinctUntilChanged](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html)\n*   在开始发出元素时，延时后进行订阅：[delaySubscription](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delaySubscription.html)\n\n**我想要从一些 `Observables` 中，只取第一个产生元素的 `Observable`：[amb](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/amb.html)**\n\n**我想评估 `Observable` 的全部元素**\n\n*   并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果：[reduce](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/reduce.html)\n*   并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果：[scan](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html)\n\n**我想把 `Observable` 转换为其他的数据结构：as...**\n\n**我想在某个 [Scheduler](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html) 应用操作符：[subscribeOn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html)**\n\n*   在某个 [Scheduler](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html) 监听：[observeOn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html)\n\n**我想要 `Observable` 发生某个事件时, 采取某个行动：[do](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/do.html)**\n\n**我想要 `Observable` 发出一个 `error` 事件：[error](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/error.html)**\n\n*   如果规定时间内没有产生元素：[timeout](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html)\n\n**我想要 `Observable` 发生错误时，优雅的恢复**\n\n*   如果规定时间内没有产生元素，就切换到备选 `Observable` ：[timeout](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html)\n*   如果产生错误，将错误替换成某个元素 ：[catchErrorJustReturn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html)\n*   如果产生错误，就切换到备选 `Observable` ：[catchError](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html)\n*   如果产生错误，就重试 ：[retry](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/retry.html)\n\n**我创建一个 `Disposable` 资源，使它与 `Observable` 具有相同的寿命：[using](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/using.html)**\n\n**我创建一个 `Observable`，直到我通知它可以产生元素后，才能产生元素：[publish](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/publish.html)**\n\n*   并且，就算是在产生元素后订阅，也要发出全部元素：[replay](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/replay.html)\n*   并且，一旦所有观察者取消观察，他就被释放掉：[refCount](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/refCount.html)\n*   通知它可以产生元素了：[connect](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/connect.html)\n\n笨鸟先飞，执行合一。基本了解`RxSwift`后，就应该动手写一些BUG了。\n","source":"_posts/RxSwift-操作符决策树.md","raw":"---\ntitle: RxSwift 操作符决策树\ndate: 2018-09-30 21:59:24\ntags: RxSwift\n---\n之前列举了很多操作符的用法，还有很多我们没有列举的。其实写了那么多操作符有时候我还是会忘记选择哪一个。这个时候，我发现在[RxSwift中文文档](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html)有一篇关于选择操作符的文章。这一篇水文纯搬运。\n### 决策树\n\n**我想要创建一个 `Observable`**\n\n*   产生特定的一个元素：[just](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/just.html)\n*   经过一段延时：[timer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html)\n*   从一个序列拉取元素：[from](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/from.html)\n*   重复的产生某一个元素：[repeatElement](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/repeatElement.html)\n*   存在自定义逻辑：[create](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/create.html)\n*   每次订阅时产生：[deferred](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/deferred.html)\n*   每隔一段时间，发出一个元素：[interval](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/interval.html)\n*   在一段延时后：[timer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html)\n*   一个空序列，只有一个完成事件：[empty](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/empty.html)\n*   一个任何事件都没有产生的序列：[never](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/never.html)\n\n**我想要创建一个 `Observable` 通过组合其他的 `Observables`**\n\n*   任意一个 `Observable` 产生了元素，就发出这个元素：[merge](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/merge.html)\n*   让这些 `Observables` 一个接一个的发出元素，当上一个 `Observable` 元素发送完毕后，下一个`Observable` 才能开始发出元素：[concat](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concat.html)\n*   组合多个 `Observables` 的元素\n*   当每一个 `Observable` 都发出一个新的元素：[zip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/zip.html)\n*   当任意一个 `Observable` 发出一个新的元素：[combineLatest](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/combineLatest.html)\n\n**我想要转换 `Observable` 的元素后，再将它们发出来**\n\n*   对每个元素直接转换：[map](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/map.html)\n*   转换到另一个 `Observable`：[flatMap](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMap.html)\n*   只接收最新的元素转换的 `Observable` 所产生的元素：[flatMapLatest](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMapLatest.html)\n*   每一个元素转换的 `Observable` 按顺序产生元素：[concatMap](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concatMap.html)\n*   基于所有遍历过的元素： [scan](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html)\n\n**我想要将产生的每一个元素，拖延一段时间后再发出：[delay](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delay.html)**\n\n**我想要将产生的事件封装成元素发送出来**\n\n*   将他们封装成 `Event<Element>`：[materialize](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/materialize.html)\n*   然后解封出来：[dematerialize](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/dematerialize.html)\n\n**我想要忽略掉所有的 `next` 事件，只接收 `completed` 和 `error` 事件：[ignoreElements](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/ignoreElements.html)**\n\n**我想创建一个新的 `Observable` 在原有的序列前面加入一些元素：[startWith](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/startWith.html)**\n\n**我想从 `Observable` 中收集元素，缓存这些元素之后在发出：[buffer](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/buffer.html)**\n\n**我想将 `Observable` 拆分成多个 `Observables`：[window](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/window.html)**\n\n*   基于元素的共同特征：[groupBy](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/groupBy.html)\n\n**我想只接收 `Observable` 中特定的元素**\n\n*   发出唯一的元素：[single](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/single.html)\n\n**我想重新从 `Observable` 中发出某些元素**\n\n*   通过判定条件过滤出一些元素：[filter](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/filter.html)\n*   仅仅发出头几个元素：[take](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html)\n*   仅仅发出尾部的几个元素：[takeLast](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeLast.html)\n*   仅仅发出第 n 个元素：[elementAt](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/elementAt.html)\n*   跳过头几个元素\n*   跳过头 n 个元素：[skip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html)\n*   跳过头几个满足判定的元素：[skipWhile](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html)，[skipWhileWithIndex](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html)\n*   跳过某段时间内产生的头几个元素：[skip](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html)\n*   跳过头几个元素直到另一个 `Observable` 发出一个元素：[skipUntil](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipUntil.html)\n*   只取头几个元素\n*   只取头几个满足判定的元素：[takeWhile](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html)，[takeWhileWithIndex](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html)\n*   只取某段时间内产生的头几个元素：[take](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html)\n*   只取头几个元素直到另一个 `Observable` 发出一个元素：[takeUntil](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeUntil.html)\n*   周期性的对 `Observable` 抽样：[sample](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/sample.html)\n*   发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生：[debounce](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/debounce.html)\n*   直到元素的值发生变化，才发出新的元素：[distinctUntilChanged](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html)\n*   并提供元素是否相等的判定函数：[distinctUntilChanged](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html)\n*   在开始发出元素时，延时后进行订阅：[delaySubscription](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delaySubscription.html)\n\n**我想要从一些 `Observables` 中，只取第一个产生元素的 `Observable`：[amb](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/amb.html)**\n\n**我想评估 `Observable` 的全部元素**\n\n*   并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果：[reduce](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/reduce.html)\n*   并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果：[scan](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html)\n\n**我想把 `Observable` 转换为其他的数据结构：as...**\n\n**我想在某个 [Scheduler](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html) 应用操作符：[subscribeOn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html)**\n\n*   在某个 [Scheduler](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html) 监听：[observeOn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html)\n\n**我想要 `Observable` 发生某个事件时, 采取某个行动：[do](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/do.html)**\n\n**我想要 `Observable` 发出一个 `error` 事件：[error](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/error.html)**\n\n*   如果规定时间内没有产生元素：[timeout](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html)\n\n**我想要 `Observable` 发生错误时，优雅的恢复**\n\n*   如果规定时间内没有产生元素，就切换到备选 `Observable` ：[timeout](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html)\n*   如果产生错误，将错误替换成某个元素 ：[catchErrorJustReturn](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html)\n*   如果产生错误，就切换到备选 `Observable` ：[catchError](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html)\n*   如果产生错误，就重试 ：[retry](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/retry.html)\n\n**我创建一个 `Disposable` 资源，使它与 `Observable` 具有相同的寿命：[using](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/using.html)**\n\n**我创建一个 `Observable`，直到我通知它可以产生元素后，才能产生元素：[publish](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/publish.html)**\n\n*   并且，就算是在产生元素后订阅，也要发出全部元素：[replay](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/replay.html)\n*   并且，一旦所有观察者取消观察，他就被释放掉：[refCount](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/refCount.html)\n*   通知它可以产生元素了：[connect](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/connect.html)\n\n笨鸟先飞，执行合一。基本了解`RxSwift`后，就应该动手写一些BUG了。\n","slug":"RxSwift-操作符决策树","published":1,"updated":"2018-10-19T07:16:01.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxy6000q2ycwwxqrl2j2","content":"<p>之前列举了很多操作符的用法，还有很多我们没有列举的。其实写了那么多操作符有时候我还是会忘记选择哪一个。这个时候，我发现在<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html\" target=\"_blank\" rel=\"noopener\">RxSwift中文文档</a>有一篇关于选择操作符的文章。这一篇水文纯搬运。</p>\n<h3 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h3><p><strong>我想要创建一个 <code>Observable</code></strong></p>\n<ul>\n<li>产生特定的一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/just.html\" target=\"_blank\" rel=\"noopener\">just</a></li>\n<li>经过一段延时：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html\" target=\"_blank\" rel=\"noopener\">timer</a></li>\n<li>从一个序列拉取元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/from.html\" target=\"_blank\" rel=\"noopener\">from</a></li>\n<li>重复的产生某一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/repeatElement.html\" target=\"_blank\" rel=\"noopener\">repeatElement</a></li>\n<li>存在自定义逻辑：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/create.html\" target=\"_blank\" rel=\"noopener\">create</a></li>\n<li>每次订阅时产生：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/deferred.html\" target=\"_blank\" rel=\"noopener\">deferred</a></li>\n<li>每隔一段时间，发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/interval.html\" target=\"_blank\" rel=\"noopener\">interval</a></li>\n<li>在一段延时后：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html\" target=\"_blank\" rel=\"noopener\">timer</a></li>\n<li>一个空序列，只有一个完成事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/empty.html\" target=\"_blank\" rel=\"noopener\">empty</a></li>\n<li>一个任何事件都没有产生的序列：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/never.html\" target=\"_blank\" rel=\"noopener\">never</a></li>\n</ul>\n<p><strong>我想要创建一个 <code>Observable</code> 通过组合其他的 <code>Observables</code></strong></p>\n<ul>\n<li>任意一个 <code>Observable</code> 产生了元素，就发出这个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/merge.html\" target=\"_blank\" rel=\"noopener\">merge</a></li>\n<li>让这些 <code>Observables</code> 一个接一个的发出元素，当上一个 <code>Observable</code> 元素发送完毕后，下一个<code>Observable</code> 才能开始发出元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concat.html\" target=\"_blank\" rel=\"noopener\">concat</a></li>\n<li>组合多个 <code>Observables</code> 的元素</li>\n<li>当每一个 <code>Observable</code> 都发出一个新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/zip.html\" target=\"_blank\" rel=\"noopener\">zip</a></li>\n<li>当任意一个 <code>Observable</code> 发出一个新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/combineLatest.html\" target=\"_blank\" rel=\"noopener\">combineLatest</a></li>\n</ul>\n<p><strong>我想要转换 <code>Observable</code> 的元素后，再将它们发出来</strong></p>\n<ul>\n<li>对每个元素直接转换：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/map.html\" target=\"_blank\" rel=\"noopener\">map</a></li>\n<li>转换到另一个 <code>Observable</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMap.html\" target=\"_blank\" rel=\"noopener\">flatMap</a></li>\n<li>只接收最新的元素转换的 <code>Observable</code> 所产生的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMapLatest.html\" target=\"_blank\" rel=\"noopener\">flatMapLatest</a></li>\n<li>每一个元素转换的 <code>Observable</code> 按顺序产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concatMap.html\" target=\"_blank\" rel=\"noopener\">concatMap</a></li>\n<li>基于所有遍历过的元素： <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html\" target=\"_blank\" rel=\"noopener\">scan</a></li>\n</ul>\n<p><strong>我想要将产生的每一个元素，拖延一段时间后再发出：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delay.html\" target=\"_blank\" rel=\"noopener\">delay</a></strong></p>\n<p><strong>我想要将产生的事件封装成元素发送出来</strong></p>\n<ul>\n<li>将他们封装成 <code>Event&lt;Element&gt;</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/materialize.html\" target=\"_blank\" rel=\"noopener\">materialize</a></li>\n<li>然后解封出来：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/dematerialize.html\" target=\"_blank\" rel=\"noopener\">dematerialize</a></li>\n</ul>\n<p><strong>我想要忽略掉所有的 <code>next</code> 事件，只接收 <code>completed</code> 和 <code>error</code> 事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/ignoreElements.html\" target=\"_blank\" rel=\"noopener\">ignoreElements</a></strong></p>\n<p><strong>我想创建一个新的 <code>Observable</code> 在原有的序列前面加入一些元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/startWith.html\" target=\"_blank\" rel=\"noopener\">startWith</a></strong></p>\n<p><strong>我想从 <code>Observable</code> 中收集元素，缓存这些元素之后在发出：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/buffer.html\" target=\"_blank\" rel=\"noopener\">buffer</a></strong></p>\n<p><strong>我想将 <code>Observable</code> 拆分成多个 <code>Observables</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/window.html\" target=\"_blank\" rel=\"noopener\">window</a></strong></p>\n<ul>\n<li>基于元素的共同特征：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/groupBy.html\" target=\"_blank\" rel=\"noopener\">groupBy</a></li>\n</ul>\n<p><strong>我想只接收 <code>Observable</code> 中特定的元素</strong></p>\n<ul>\n<li>发出唯一的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/single.html\" target=\"_blank\" rel=\"noopener\">single</a></li>\n</ul>\n<p><strong>我想重新从 <code>Observable</code> 中发出某些元素</strong></p>\n<ul>\n<li>通过判定条件过滤出一些元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/filter.html\" target=\"_blank\" rel=\"noopener\">filter</a></li>\n<li>仅仅发出头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html\" target=\"_blank\" rel=\"noopener\">take</a></li>\n<li>仅仅发出尾部的几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeLast.html\" target=\"_blank\" rel=\"noopener\">takeLast</a></li>\n<li>仅仅发出第 n 个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/elementAt.html\" target=\"_blank\" rel=\"noopener\">elementAt</a></li>\n<li>跳过头几个元素</li>\n<li>跳过头 n 个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html\" target=\"_blank\" rel=\"noopener\">skip</a></li>\n<li>跳过头几个满足判定的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html\" target=\"_blank\" rel=\"noopener\">skipWhile</a>，<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html\" target=\"_blank\" rel=\"noopener\">skipWhileWithIndex</a></li>\n<li>跳过某段时间内产生的头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html\" target=\"_blank\" rel=\"noopener\">skip</a></li>\n<li>跳过头几个元素直到另一个 <code>Observable</code> 发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipUntil.html\" target=\"_blank\" rel=\"noopener\">skipUntil</a></li>\n<li>只取头几个元素</li>\n<li>只取头几个满足判定的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html\" target=\"_blank\" rel=\"noopener\">takeWhile</a>，<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html\" target=\"_blank\" rel=\"noopener\">takeWhileWithIndex</a></li>\n<li>只取某段时间内产生的头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html\" target=\"_blank\" rel=\"noopener\">take</a></li>\n<li>只取头几个元素直到另一个 <code>Observable</code> 发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeUntil.html\" target=\"_blank\" rel=\"noopener\">takeUntil</a></li>\n<li>周期性的对 <code>Observable</code> 抽样：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/sample.html\" target=\"_blank\" rel=\"noopener\">sample</a></li>\n<li>发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/debounce.html\" target=\"_blank\" rel=\"noopener\">debounce</a></li>\n<li>直到元素的值发生变化，才发出新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html\" target=\"_blank\" rel=\"noopener\">distinctUntilChanged</a></li>\n<li>并提供元素是否相等的判定函数：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html\" target=\"_blank\" rel=\"noopener\">distinctUntilChanged</a></li>\n<li>在开始发出元素时，延时后进行订阅：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delaySubscription.html\" target=\"_blank\" rel=\"noopener\">delaySubscription</a></li>\n</ul>\n<p><strong>我想要从一些 <code>Observables</code> 中，只取第一个产生元素的 <code>Observable</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/amb.html\" target=\"_blank\" rel=\"noopener\">amb</a></strong></p>\n<p><strong>我想评估 <code>Observable</code> 的全部元素</strong></p>\n<ul>\n<li>并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/reduce.html\" target=\"_blank\" rel=\"noopener\">reduce</a></li>\n<li>并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html\" target=\"_blank\" rel=\"noopener\">scan</a></li>\n</ul>\n<p><strong>我想把 <code>Observable</code> 转换为其他的数据结构：as…</strong></p>\n<p><strong>我想在某个 <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html\" target=\"_blank\" rel=\"noopener\">Scheduler</a> 应用操作符：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html\" target=\"_blank\" rel=\"noopener\">subscribeOn</a></strong></p>\n<ul>\n<li>在某个 <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html\" target=\"_blank\" rel=\"noopener\">Scheduler</a> 监听：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html\" target=\"_blank\" rel=\"noopener\">observeOn</a></li>\n</ul>\n<p><strong>我想要 <code>Observable</code> 发生某个事件时, 采取某个行动：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/do.html\" target=\"_blank\" rel=\"noopener\">do</a></strong></p>\n<p><strong>我想要 <code>Observable</code> 发出一个 <code>error</code> 事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/error.html\" target=\"_blank\" rel=\"noopener\">error</a></strong></p>\n<ul>\n<li>如果规定时间内没有产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html\" target=\"_blank\" rel=\"noopener\">timeout</a></li>\n</ul>\n<p><strong>我想要 <code>Observable</code> 发生错误时，优雅的恢复</strong></p>\n<ul>\n<li>如果规定时间内没有产生元素，就切换到备选 <code>Observable</code> ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html\" target=\"_blank\" rel=\"noopener\">timeout</a></li>\n<li>如果产生错误，将错误替换成某个元素 ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html\" target=\"_blank\" rel=\"noopener\">catchErrorJustReturn</a></li>\n<li>如果产生错误，就切换到备选 <code>Observable</code> ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html\" target=\"_blank\" rel=\"noopener\">catchError</a></li>\n<li>如果产生错误，就重试 ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/retry.html\" target=\"_blank\" rel=\"noopener\">retry</a></li>\n</ul>\n<p><strong>我创建一个 <code>Disposable</code> 资源，使它与 <code>Observable</code> 具有相同的寿命：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/using.html\" target=\"_blank\" rel=\"noopener\">using</a></strong></p>\n<p><strong>我创建一个 <code>Observable</code>，直到我通知它可以产生元素后，才能产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/publish.html\" target=\"_blank\" rel=\"noopener\">publish</a></strong></p>\n<ul>\n<li>并且，就算是在产生元素后订阅，也要发出全部元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/replay.html\" target=\"_blank\" rel=\"noopener\">replay</a></li>\n<li>并且，一旦所有观察者取消观察，他就被释放掉：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/refCount.html\" target=\"_blank\" rel=\"noopener\">refCount</a></li>\n<li>通知它可以产生元素了：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/connect.html\" target=\"_blank\" rel=\"noopener\">connect</a></li>\n</ul>\n<p>笨鸟先飞，执行合一。基本了解<code>RxSwift</code>后，就应该动手写一些BUG了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前列举了很多操作符的用法，还有很多我们没有列举的。其实写了那么多操作符有时候我还是会忘记选择哪一个。这个时候，我发现在<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html\" target=\"_blank\" rel=\"noopener\">RxSwift中文文档</a>有一篇关于选择操作符的文章。这一篇水文纯搬运。</p>\n<h3 id=\"决策树\"><a href=\"#决策树\" class=\"headerlink\" title=\"决策树\"></a>决策树</h3><p><strong>我想要创建一个 <code>Observable</code></strong></p>\n<ul>\n<li>产生特定的一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/just.html\" target=\"_blank\" rel=\"noopener\">just</a></li>\n<li>经过一段延时：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html\" target=\"_blank\" rel=\"noopener\">timer</a></li>\n<li>从一个序列拉取元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/from.html\" target=\"_blank\" rel=\"noopener\">from</a></li>\n<li>重复的产生某一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/repeatElement.html\" target=\"_blank\" rel=\"noopener\">repeatElement</a></li>\n<li>存在自定义逻辑：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/create.html\" target=\"_blank\" rel=\"noopener\">create</a></li>\n<li>每次订阅时产生：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/deferred.html\" target=\"_blank\" rel=\"noopener\">deferred</a></li>\n<li>每隔一段时间，发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/interval.html\" target=\"_blank\" rel=\"noopener\">interval</a></li>\n<li>在一段延时后：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timer.html\" target=\"_blank\" rel=\"noopener\">timer</a></li>\n<li>一个空序列，只有一个完成事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/empty.html\" target=\"_blank\" rel=\"noopener\">empty</a></li>\n<li>一个任何事件都没有产生的序列：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/never.html\" target=\"_blank\" rel=\"noopener\">never</a></li>\n</ul>\n<p><strong>我想要创建一个 <code>Observable</code> 通过组合其他的 <code>Observables</code></strong></p>\n<ul>\n<li>任意一个 <code>Observable</code> 产生了元素，就发出这个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/merge.html\" target=\"_blank\" rel=\"noopener\">merge</a></li>\n<li>让这些 <code>Observables</code> 一个接一个的发出元素，当上一个 <code>Observable</code> 元素发送完毕后，下一个<code>Observable</code> 才能开始发出元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concat.html\" target=\"_blank\" rel=\"noopener\">concat</a></li>\n<li>组合多个 <code>Observables</code> 的元素</li>\n<li>当每一个 <code>Observable</code> 都发出一个新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/zip.html\" target=\"_blank\" rel=\"noopener\">zip</a></li>\n<li>当任意一个 <code>Observable</code> 发出一个新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/combineLatest.html\" target=\"_blank\" rel=\"noopener\">combineLatest</a></li>\n</ul>\n<p><strong>我想要转换 <code>Observable</code> 的元素后，再将它们发出来</strong></p>\n<ul>\n<li>对每个元素直接转换：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/map.html\" target=\"_blank\" rel=\"noopener\">map</a></li>\n<li>转换到另一个 <code>Observable</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMap.html\" target=\"_blank\" rel=\"noopener\">flatMap</a></li>\n<li>只接收最新的元素转换的 <code>Observable</code> 所产生的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/flatMapLatest.html\" target=\"_blank\" rel=\"noopener\">flatMapLatest</a></li>\n<li>每一个元素转换的 <code>Observable</code> 按顺序产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/concatMap.html\" target=\"_blank\" rel=\"noopener\">concatMap</a></li>\n<li>基于所有遍历过的元素： <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html\" target=\"_blank\" rel=\"noopener\">scan</a></li>\n</ul>\n<p><strong>我想要将产生的每一个元素，拖延一段时间后再发出：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delay.html\" target=\"_blank\" rel=\"noopener\">delay</a></strong></p>\n<p><strong>我想要将产生的事件封装成元素发送出来</strong></p>\n<ul>\n<li>将他们封装成 <code>Event&lt;Element&gt;</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/materialize.html\" target=\"_blank\" rel=\"noopener\">materialize</a></li>\n<li>然后解封出来：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/dematerialize.html\" target=\"_blank\" rel=\"noopener\">dematerialize</a></li>\n</ul>\n<p><strong>我想要忽略掉所有的 <code>next</code> 事件，只接收 <code>completed</code> 和 <code>error</code> 事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/ignoreElements.html\" target=\"_blank\" rel=\"noopener\">ignoreElements</a></strong></p>\n<p><strong>我想创建一个新的 <code>Observable</code> 在原有的序列前面加入一些元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/startWith.html\" target=\"_blank\" rel=\"noopener\">startWith</a></strong></p>\n<p><strong>我想从 <code>Observable</code> 中收集元素，缓存这些元素之后在发出：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/buffer.html\" target=\"_blank\" rel=\"noopener\">buffer</a></strong></p>\n<p><strong>我想将 <code>Observable</code> 拆分成多个 <code>Observables</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/window.html\" target=\"_blank\" rel=\"noopener\">window</a></strong></p>\n<ul>\n<li>基于元素的共同特征：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/groupBy.html\" target=\"_blank\" rel=\"noopener\">groupBy</a></li>\n</ul>\n<p><strong>我想只接收 <code>Observable</code> 中特定的元素</strong></p>\n<ul>\n<li>发出唯一的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/single.html\" target=\"_blank\" rel=\"noopener\">single</a></li>\n</ul>\n<p><strong>我想重新从 <code>Observable</code> 中发出某些元素</strong></p>\n<ul>\n<li>通过判定条件过滤出一些元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/filter.html\" target=\"_blank\" rel=\"noopener\">filter</a></li>\n<li>仅仅发出头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html\" target=\"_blank\" rel=\"noopener\">take</a></li>\n<li>仅仅发出尾部的几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeLast.html\" target=\"_blank\" rel=\"noopener\">takeLast</a></li>\n<li>仅仅发出第 n 个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/elementAt.html\" target=\"_blank\" rel=\"noopener\">elementAt</a></li>\n<li>跳过头几个元素</li>\n<li>跳过头 n 个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html\" target=\"_blank\" rel=\"noopener\">skip</a></li>\n<li>跳过头几个满足判定的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html\" target=\"_blank\" rel=\"noopener\">skipWhile</a>，<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipWhile.html\" target=\"_blank\" rel=\"noopener\">skipWhileWithIndex</a></li>\n<li>跳过某段时间内产生的头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skip.html\" target=\"_blank\" rel=\"noopener\">skip</a></li>\n<li>跳过头几个元素直到另一个 <code>Observable</code> 发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/skipUntil.html\" target=\"_blank\" rel=\"noopener\">skipUntil</a></li>\n<li>只取头几个元素</li>\n<li>只取头几个满足判定的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html\" target=\"_blank\" rel=\"noopener\">takeWhile</a>，<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeWhile.html\" target=\"_blank\" rel=\"noopener\">takeWhileWithIndex</a></li>\n<li>只取某段时间内产生的头几个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/take.html\" target=\"_blank\" rel=\"noopener\">take</a></li>\n<li>只取头几个元素直到另一个 <code>Observable</code> 发出一个元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/takeUntil.html\" target=\"_blank\" rel=\"noopener\">takeUntil</a></li>\n<li>周期性的对 <code>Observable</code> 抽样：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/sample.html\" target=\"_blank\" rel=\"noopener\">sample</a></li>\n<li>发出那些元素，这些元素产生后的特定的时间内，没有新的元素产生：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/debounce.html\" target=\"_blank\" rel=\"noopener\">debounce</a></li>\n<li>直到元素的值发生变化，才发出新的元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html\" target=\"_blank\" rel=\"noopener\">distinctUntilChanged</a></li>\n<li>并提供元素是否相等的判定函数：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/distinctUntilChanged.html\" target=\"_blank\" rel=\"noopener\">distinctUntilChanged</a></li>\n<li>在开始发出元素时，延时后进行订阅：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/delaySubscription.html\" target=\"_blank\" rel=\"noopener\">delaySubscription</a></li>\n</ul>\n<p><strong>我想要从一些 <code>Observables</code> 中，只取第一个产生元素的 <code>Observable</code>：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/amb.html\" target=\"_blank\" rel=\"noopener\">amb</a></strong></p>\n<p><strong>我想评估 <code>Observable</code> 的全部元素</strong></p>\n<ul>\n<li>并且对每个元素应用聚合方法，待所有元素都应用聚合方法后，发出结果：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/reduce.html\" target=\"_blank\" rel=\"noopener\">reduce</a></li>\n<li>并且对每个元素应用聚合方法，每次应用聚合方法后，发出结果：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/scan.html\" target=\"_blank\" rel=\"noopener\">scan</a></li>\n</ul>\n<p><strong>我想把 <code>Observable</code> 转换为其他的数据结构：as…</strong></p>\n<p><strong>我想在某个 <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html\" target=\"_blank\" rel=\"noopener\">Scheduler</a> 应用操作符：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/subscribeOn.html\" target=\"_blank\" rel=\"noopener\">subscribeOn</a></strong></p>\n<ul>\n<li>在某个 <a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/schedulers.html\" target=\"_blank\" rel=\"noopener\">Scheduler</a> 监听：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/observeOn.html\" target=\"_blank\" rel=\"noopener\">observeOn</a></li>\n</ul>\n<p><strong>我想要 <code>Observable</code> 发生某个事件时, 采取某个行动：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/do.html\" target=\"_blank\" rel=\"noopener\">do</a></strong></p>\n<p><strong>我想要 <code>Observable</code> 发出一个 <code>error</code> 事件：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/error.html\" target=\"_blank\" rel=\"noopener\">error</a></strong></p>\n<ul>\n<li>如果规定时间内没有产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html\" target=\"_blank\" rel=\"noopener\">timeout</a></li>\n</ul>\n<p><strong>我想要 <code>Observable</code> 发生错误时，优雅的恢复</strong></p>\n<ul>\n<li>如果规定时间内没有产生元素，就切换到备选 <code>Observable</code> ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/timeout.html\" target=\"_blank\" rel=\"noopener\">timeout</a></li>\n<li>如果产生错误，将错误替换成某个元素 ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html\" target=\"_blank\" rel=\"noopener\">catchErrorJustReturn</a></li>\n<li>如果产生错误，就切换到备选 <code>Observable</code> ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/catchError.html\" target=\"_blank\" rel=\"noopener\">catchError</a></li>\n<li>如果产生错误，就重试 ：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/retry.html\" target=\"_blank\" rel=\"noopener\">retry</a></li>\n</ul>\n<p><strong>我创建一个 <code>Disposable</code> 资源，使它与 <code>Observable</code> 具有相同的寿命：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/using.html\" target=\"_blank\" rel=\"noopener\">using</a></strong></p>\n<p><strong>我创建一个 <code>Observable</code>，直到我通知它可以产生元素后，才能产生元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/publish.html\" target=\"_blank\" rel=\"noopener\">publish</a></strong></p>\n<ul>\n<li>并且，就算是在产生元素后订阅，也要发出全部元素：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/replay.html\" target=\"_blank\" rel=\"noopener\">replay</a></li>\n<li>并且，一旦所有观察者取消观察，他就被释放掉：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/refCount.html\" target=\"_blank\" rel=\"noopener\">refCount</a></li>\n<li>通知它可以产生元素了：<a href=\"https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree/connect.html\" target=\"_blank\" rel=\"noopener\">connect</a></li>\n</ul>\n<p>笨鸟先飞，执行合一。基本了解<code>RxSwift</code>后，就应该动手写一些BUG了。</p>\n"},{"title":"RxSwift Observable&Observer和辅助类型","date":"2018-09-22T15:49:42.000Z","_content":"在我们日常开发中，有一些既可是`Observable`又可是`Observer`。举个🌰：\n```\nlet observable = textField.rx.text\nobservable.subscribe(onNext: { text in show(text: text) })\n```\n在这行代码中，`textField`当前文本就是一个`Observable`，当用户在`textField`中输入时，就会`show`文本内容。\n再举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet observer = textField.rx.text\nlet observable = Observable<String>.just(\"A\")\nobservable.bind(to: observer)\n        .disposed(by: disposeBag)\n```\n这个时候，屏幕上就会显示：\n![textField.png](https://upload-images.jianshu.io/upload_images/2855070-a113479a0f2d92f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时，`textField`的当前文本就是`Observer`。\n此外，框架中还有一些辅助类型，既可是`Observable`又可是`Observer`。\n#### 1. AsyncSubject\n`AsyncSubject `将在`Observable`产生完成事件后，发出最后一个元素（仅仅只有最后一个元素）。如果`Observable`没有发出任何元素，只有一个完成事件，那`AsyncSubject`也只有一个完成事件。如果`Observable`因`error`中止，那么`AsyncSubject`只会将`error`发送出来，不会发出其它元素。\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建一个AsyncSubject\nlet subject = AsyncSubject<String>()\n//订阅subject\nsubject.subscribe{ print($0) }\n    .disposed(by: disposeBag)\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\nsubject.onCompleted()\n```\n这个时候输出：\n```\nnext(D)\ncompleted\n```\n\n此时我们再改造一下：\n```\nlet subject = AsyncSubject<String>()\nsubject.subscribe{ print($0) }\n    .disposed(by: disposeBag)\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\n//SubjectError 自己定义的enum Error\nsubject.onError(SubjectError.error)\n```\n就会输出：\n```\nerror(error)\n```\n#### 2. PublishSubject\n`PublishSubject`是将对观察者发送`订阅后产生的元素`，而在订阅前发出的元素将不会发送给观察者。\n- `PublishSubject`是最普通的`Subject`，它不需要初始值就能创建\n- `PublishSubject`的订阅者从他们开始订阅的时间点起，可以收到订阅后`Subject`发出的新`Event`，而不会收到他们在订阅前已发出的`Event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n//由于当前没有订阅，所以不输出\nsubject.onNext(\"🐶\")\n//第一次订阅\nsubject.subscribe(onNext: { (element) in\n    print(\"第一次订阅:\\(element)\")\n}, onCompleted: {\n    print(\"completed\")\n}).disposed(by: disposeBag)\n//当前有一个订阅，输出\nsubject.onNext(\"🐱\")\n\n//第二次订阅\nsubject.subscribe(onNext: { (element) in\n    print(\"第二次订阅:\\(element)\")\n}, onCompleted: {\n    print(\"completed\")\n}).disposed(by: disposeBag)\n//当前有两个订阅 输出\nsubject.onNext(\"🐹\")\n\n//结束subject\nsubject.onCompleted()\n//再次发出.next事件\nsubject.onNext(\"🐯\")\n```\n显示如下：\n```\n第一次订阅:🐱\n第一次订阅:🐹\n第二次订阅:🐹\n第一次订阅:completed\n第二次订阅:completed\n第三次订阅:completed\n```\n\n####  3. ReplaySubject\n`ReplaySubject`将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的`ReplaySubject`，有的只会将最新的n个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把`ReplaySubject`当作观察者来使用，注意不要在多个线程调用`onNext`,`onError`或`onCompleted`。这样会导致无序调用，将造成意想不到的结果。\n- `ReplaySubject`在创建时候需要设置一个`bufferSize`，表示它对于它发送过的`event`的缓存个数\n- 比如一个`ReplaySubject`的`bufferSize`设置为 2，它发出了 3 个`.next`的`event`，那么它会将后两个（最近的两个）`event`给缓存起来。此时如果有一个`subscriber`订阅了这个 `ReplaySubject`，那么这个`subscriber`就会立即收到前面缓存的两个`.next`的`event`\n- 如果一个`subscriber`订阅已经结束的`ReplaySubject`，除了会收到缓存的`.next`的`event`外，还会收到那个终结的`.error`或者`.complete`的`event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建\nlet subject = ReplaySubject<String>.create(bufferSize: 0)\n//第1次订阅subject\nsubject.subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\n//第二次订阅\nsubject.subscribe{ print(\"第二次订阅:\\($0)\" )}\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\n```\n输出结果：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n```\n当`bufferSize`改成1时，结果就变成了：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第二次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n\n```\n如果是2的话，结果就变成了：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第二次订阅:next(A)\n第二次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n```\n\n#### 4. BehaviorSubject\n`BehaviorSubject `会把`Observable `最新元素发出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果`Observable `因为`error`事件而中止，则不会发出任何元素，将`error`事件发出来。\n- `BehaviorSubject`需要通过一个默认初始值来创建\n- 当一个订阅者来订阅它的时候，这个订阅者会立即收到 `BehaviorSubjects`上一个发出的`event`。之后就跟正常的情况一样，它也会接收到`BehaviorSubject`之后发出的新的`event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建一个BehaviorSubject\nlet subject = BehaviorSubject.init(value: \"🐭\")\n//第一次订阅\nsubject.subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"🐯\")\n//发送error事件\nsubject.onError(NSError(domain: \"local\", code: 0, userInfo: nil))\n//第二次订阅\nsubject.subscribe{ print(\"第二次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n```\n输出结果：\n```\n第一次订阅:next(🐭)\n第一次订阅:next(🐯)\n第一次订阅:error(Error Domain=local Code=0 \"(null)\")\n第二次订阅:error(Error Domain=local Code=0 \"(null)\")\n```\n#### 4. Variable\n在`RxSwift`中，`Variable `相当于`Swift`中的`var`。\n- `Variable`其实就是对`BehaviorSubject`的封装，所以它也必须要通过一个默认的初始值进行创建。\n- `Variable`具有`BehaviorSubject`的功能，能够向它的订阅者发出上一个`event`以及之后新创建的`event`。\n- 不同的是，`Variable`还会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送`.complete`的`event`，不需要也不能手动给`Variables`发送`completed`或者`error`事件来结束它。\n- 简单地说就是`Variable`有一个`value`属性，我们改变这个`value`属性的值就相当于调用一般`Subjects`的`onNext()`方法，而这个最新的`onNext()`的值就被保存在`value`属性里了，直到我们再次修改它。\n- `Variables`本身没有`subscribe()`方法，但是所有`Subjects`都有一个`asObservable()`方法。我们可以使用这个方法返回这个`Variable`的`Observable`类型，拿到这个`Observable`类型我们就能订阅它了。\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet variable = Variable.init(\"A\")\nvariable.value = \"B\"\n//第一次订阅\nvariable.asObservable().subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//修改value\nvariable.value = \"C\"\n//第二次订阅\nvariable.asObservable().subscribe{ print(\"第二次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//修改value\nvariable.value = \"D\"\n```\n结果如下：\n```\n第一次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n第一次订阅:completed\n第二次订阅:completed\n```\n","source":"_posts/RxSwift-Observable-Observer和辅助类型.md","raw":"---\ntitle: RxSwift Observable&Observer和辅助类型\ndate: 2018-09-22 23:49:42\ntags: RxSwift\n---\n在我们日常开发中，有一些既可是`Observable`又可是`Observer`。举个🌰：\n```\nlet observable = textField.rx.text\nobservable.subscribe(onNext: { text in show(text: text) })\n```\n在这行代码中，`textField`当前文本就是一个`Observable`，当用户在`textField`中输入时，就会`show`文本内容。\n再举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet observer = textField.rx.text\nlet observable = Observable<String>.just(\"A\")\nobservable.bind(to: observer)\n        .disposed(by: disposeBag)\n```\n这个时候，屏幕上就会显示：\n![textField.png](https://upload-images.jianshu.io/upload_images/2855070-a113479a0f2d92f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这时，`textField`的当前文本就是`Observer`。\n此外，框架中还有一些辅助类型，既可是`Observable`又可是`Observer`。\n#### 1. AsyncSubject\n`AsyncSubject `将在`Observable`产生完成事件后，发出最后一个元素（仅仅只有最后一个元素）。如果`Observable`没有发出任何元素，只有一个完成事件，那`AsyncSubject`也只有一个完成事件。如果`Observable`因`error`中止，那么`AsyncSubject`只会将`error`发送出来，不会发出其它元素。\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建一个AsyncSubject\nlet subject = AsyncSubject<String>()\n//订阅subject\nsubject.subscribe{ print($0) }\n    .disposed(by: disposeBag)\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\nsubject.onCompleted()\n```\n这个时候输出：\n```\nnext(D)\ncompleted\n```\n\n此时我们再改造一下：\n```\nlet subject = AsyncSubject<String>()\nsubject.subscribe{ print($0) }\n    .disposed(by: disposeBag)\nsubject.onNext(\"B\")\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\n//SubjectError 自己定义的enum Error\nsubject.onError(SubjectError.error)\n```\n就会输出：\n```\nerror(error)\n```\n#### 2. PublishSubject\n`PublishSubject`是将对观察者发送`订阅后产生的元素`，而在订阅前发出的元素将不会发送给观察者。\n- `PublishSubject`是最普通的`Subject`，它不需要初始值就能创建\n- `PublishSubject`的订阅者从他们开始订阅的时间点起，可以收到订阅后`Subject`发出的新`Event`，而不会收到他们在订阅前已发出的`Event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet subject = PublishSubject<String>()\n//由于当前没有订阅，所以不输出\nsubject.onNext(\"🐶\")\n//第一次订阅\nsubject.subscribe(onNext: { (element) in\n    print(\"第一次订阅:\\(element)\")\n}, onCompleted: {\n    print(\"completed\")\n}).disposed(by: disposeBag)\n//当前有一个订阅，输出\nsubject.onNext(\"🐱\")\n\n//第二次订阅\nsubject.subscribe(onNext: { (element) in\n    print(\"第二次订阅:\\(element)\")\n}, onCompleted: {\n    print(\"completed\")\n}).disposed(by: disposeBag)\n//当前有两个订阅 输出\nsubject.onNext(\"🐹\")\n\n//结束subject\nsubject.onCompleted()\n//再次发出.next事件\nsubject.onNext(\"🐯\")\n```\n显示如下：\n```\n第一次订阅:🐱\n第一次订阅:🐹\n第二次订阅:🐹\n第一次订阅:completed\n第二次订阅:completed\n第三次订阅:completed\n```\n\n####  3. ReplaySubject\n`ReplaySubject`将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的`ReplaySubject`，有的只会将最新的n个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把`ReplaySubject`当作观察者来使用，注意不要在多个线程调用`onNext`,`onError`或`onCompleted`。这样会导致无序调用，将造成意想不到的结果。\n- `ReplaySubject`在创建时候需要设置一个`bufferSize`，表示它对于它发送过的`event`的缓存个数\n- 比如一个`ReplaySubject`的`bufferSize`设置为 2，它发出了 3 个`.next`的`event`，那么它会将后两个（最近的两个）`event`给缓存起来。此时如果有一个`subscriber`订阅了这个 `ReplaySubject`，那么这个`subscriber`就会立即收到前面缓存的两个`.next`的`event`\n- 如果一个`subscriber`订阅已经结束的`ReplaySubject`，除了会收到缓存的`.next`的`event`外，还会收到那个终结的`.error`或者`.complete`的`event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建\nlet subject = ReplaySubject<String>.create(bufferSize: 0)\n//第1次订阅subject\nsubject.subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"A\")\nsubject.onNext(\"B\")\n//第二次订阅\nsubject.subscribe{ print(\"第二次订阅:\\($0)\" )}\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"C\")\nsubject.onNext(\"D\")\n```\n输出结果：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n```\n当`bufferSize`改成1时，结果就变成了：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第二次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n\n```\n如果是2的话，结果就变成了：\n```\n第一次订阅:next(A)\n第一次订阅:next(B)\n第二次订阅:next(A)\n第二次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n```\n\n#### 4. BehaviorSubject\n`BehaviorSubject `会把`Observable `最新元素发出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果`Observable `因为`error`事件而中止，则不会发出任何元素，将`error`事件发出来。\n- `BehaviorSubject`需要通过一个默认初始值来创建\n- 当一个订阅者来订阅它的时候，这个订阅者会立即收到 `BehaviorSubjects`上一个发出的`event`。之后就跟正常的情况一样，它也会接收到`BehaviorSubject`之后发出的新的`event`\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\n//创建一个BehaviorSubject\nlet subject = BehaviorSubject.init(value: \"🐭\")\n//第一次订阅\nsubject.subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//发送.next事件\nsubject.onNext(\"🐯\")\n//发送error事件\nsubject.onError(NSError(domain: \"local\", code: 0, userInfo: nil))\n//第二次订阅\nsubject.subscribe{ print(\"第二次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n```\n输出结果：\n```\n第一次订阅:next(🐭)\n第一次订阅:next(🐯)\n第一次订阅:error(Error Domain=local Code=0 \"(null)\")\n第二次订阅:error(Error Domain=local Code=0 \"(null)\")\n```\n#### 4. Variable\n在`RxSwift`中，`Variable `相当于`Swift`中的`var`。\n- `Variable`其实就是对`BehaviorSubject`的封装，所以它也必须要通过一个默认的初始值进行创建。\n- `Variable`具有`BehaviorSubject`的功能，能够向它的订阅者发出上一个`event`以及之后新创建的`event`。\n- 不同的是，`Variable`还会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送`.complete`的`event`，不需要也不能手动给`Variables`发送`completed`或者`error`事件来结束它。\n- 简单地说就是`Variable`有一个`value`属性，我们改变这个`value`属性的值就相当于调用一般`Subjects`的`onNext()`方法，而这个最新的`onNext()`的值就被保存在`value`属性里了，直到我们再次修改它。\n- `Variables`本身没有`subscribe()`方法，但是所有`Subjects`都有一个`asObservable()`方法。我们可以使用这个方法返回这个`Variable`的`Observable`类型，拿到这个`Observable`类型我们就能订阅它了。\n\n举个🌰：\n```\nlet disposeBag = DisposeBag()\nlet variable = Variable.init(\"A\")\nvariable.value = \"B\"\n//第一次订阅\nvariable.asObservable().subscribe{ print(\"第一次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//修改value\nvariable.value = \"C\"\n//第二次订阅\nvariable.asObservable().subscribe{ print(\"第二次订阅:\\($0)\") }\n    .disposed(by: disposeBag)\n//修改value\nvariable.value = \"D\"\n```\n结果如下：\n```\n第一次订阅:next(B)\n第一次订阅:next(C)\n第二次订阅:next(C)\n第一次订阅:next(D)\n第二次订阅:next(D)\n第一次订阅:completed\n第二次订阅:completed\n```\n","slug":"RxSwift-Observable-Observer和辅助类型","published":1,"updated":"2018-10-19T07:16:01.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxy8000s2ycwel4gum3v","content":"<p>在我们日常开发中，有一些既可是<code>Observable</code>又可是<code>Observer</code>。举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = textField.rx.text</span><br><span class=\"line\">observable.subscribe(onNext: &#123; text in show(text: text) &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在这行代码中，<code>textField</code>当前文本就是一个<code>Observable</code>，当用户在<code>textField</code>中输入时，就会<code>show</code>文本内容。<br>再举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let observer = textField.rx.text</span><br><span class=\"line\">let observable = Observable&lt;String&gt;.just(&quot;A&quot;)</span><br><span class=\"line\">observable.bind(to: observer)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>这个时候，屏幕上就会显示：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-a113479a0f2d92f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"textField.png\"><br>这时，<code>textField</code>的当前文本就是<code>Observer</code>。<br>此外，框架中还有一些辅助类型，既可是<code>Observable</code>又可是<code>Observer</code>。</p>\n<h4 id=\"1-AsyncSubject\"><a href=\"#1-AsyncSubject\" class=\"headerlink\" title=\"1. AsyncSubject\"></a>1. AsyncSubject</h4><p><code>AsyncSubject</code>将在<code>Observable</code>产生完成事件后，发出最后一个元素（仅仅只有最后一个元素）。如果<code>Observable</code>没有发出任何元素，只有一个完成事件，那<code>AsyncSubject</code>也只有一个完成事件。如果<code>Observable</code>因<code>error</code>中止，那么<code>AsyncSubject</code>只会将<code>error</code>发送出来，不会发出其它元素。<br>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建一个AsyncSubject</span><br><span class=\"line\">let subject = AsyncSubject&lt;String&gt;()</span><br><span class=\"line\">//订阅subject</span><br><span class=\"line\">subject.subscribe&#123; print($0) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">subject.onCompleted()</span><br></pre></td></tr></table></figure></p>\n<p>这个时候输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(D)</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<p>此时我们再改造一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let subject = AsyncSubject&lt;String&gt;()</span><br><span class=\"line\">subject.subscribe&#123; print($0) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">//SubjectError 自己定义的enum Error</span><br><span class=\"line\">subject.onError(SubjectError.error)</span><br></pre></td></tr></table></figure></p>\n<p>就会输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error(error)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-PublishSubject\"><a href=\"#2-PublishSubject\" class=\"headerlink\" title=\"2. PublishSubject\"></a>2. PublishSubject</h4><p><code>PublishSubject</code>是将对观察者发送<code>订阅后产生的元素</code>，而在订阅前发出的元素将不会发送给观察者。</p>\n<ul>\n<li><code>PublishSubject</code>是最普通的<code>Subject</code>，它不需要初始值就能创建</li>\n<li><code>PublishSubject</code>的订阅者从他们开始订阅的时间点起，可以收到订阅后<code>Subject</code>发出的新<code>Event</code>，而不会收到他们在订阅前已发出的<code>Event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">//由于当前没有订阅，所以不输出</span><br><span class=\"line\">subject.onNext(&quot;🐶&quot;)</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">subject.subscribe(onNext: &#123; (element) in</span><br><span class=\"line\">    print(&quot;第一次订阅:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;).disposed(by: disposeBag)</span><br><span class=\"line\">//当前有一个订阅，输出</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe(onNext: &#123; (element) in</span><br><span class=\"line\">    print(&quot;第二次订阅:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;).disposed(by: disposeBag)</span><br><span class=\"line\">//当前有两个订阅 输出</span><br><span class=\"line\">subject.onNext(&quot;🐹&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//结束subject</span><br><span class=\"line\">subject.onCompleted()</span><br><span class=\"line\">//再次发出.next事件</span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>显示如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:🐱</span><br><span class=\"line\">第一次订阅:🐹</span><br><span class=\"line\">第二次订阅:🐹</span><br><span class=\"line\">第一次订阅:completed</span><br><span class=\"line\">第二次订阅:completed</span><br><span class=\"line\">第三次订阅:completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-ReplaySubject\"><a href=\"#3-ReplaySubject\" class=\"headerlink\" title=\"3. ReplaySubject\"></a>3. ReplaySubject</h4><p><code>ReplaySubject</code>将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的<code>ReplaySubject</code>，有的只会将最新的n个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把<code>ReplaySubject</code>当作观察者来使用，注意不要在多个线程调用<code>onNext</code>,<code>onError</code>或<code>onCompleted</code>。这样会导致无序调用，将造成意想不到的结果。</p>\n<ul>\n<li><code>ReplaySubject</code>在创建时候需要设置一个<code>bufferSize</code>，表示它对于它发送过的<code>event</code>的缓存个数</li>\n<li>比如一个<code>ReplaySubject</code>的<code>bufferSize</code>设置为 2，它发出了 3 个<code>.next</code>的<code>event</code>，那么它会将后两个（最近的两个）<code>event</code>给缓存起来。此时如果有一个<code>subscriber</code>订阅了这个 <code>ReplaySubject</code>，那么这个<code>subscriber</code>就会立即收到前面缓存的两个<code>.next</code>的<code>event</code></li>\n<li>如果一个<code>subscriber</code>订阅已经结束的<code>ReplaySubject</code>，除了会收到缓存的<code>.next</code>的<code>event</code>外，还会收到那个终结的<code>.error</code>或者<code>.complete</code>的<code>event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建</span><br><span class=\"line\">let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 0)</span><br><span class=\"line\">//第1次订阅subject</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第二次订阅:\\($0)&quot; )&#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<p>当<code>bufferSize</code>改成1时，结果就变成了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第二次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<p>如果是2的话，结果就变成了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第二次订阅:next(A)</span><br><span class=\"line\">第二次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-BehaviorSubject\"><a href=\"#4-BehaviorSubject\" class=\"headerlink\" title=\"4. BehaviorSubject\"></a>4. BehaviorSubject</h4><p><code>BehaviorSubject</code>会把<code>Observable</code>最新元素发出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果<code>Observable</code>因为<code>error</code>事件而中止，则不会发出任何元素，将<code>error</code>事件发出来。</p>\n<ul>\n<li><code>BehaviorSubject</code>需要通过一个默认初始值来创建</li>\n<li>当一个订阅者来订阅它的时候，这个订阅者会立即收到 <code>BehaviorSubjects</code>上一个发出的<code>event</code>。之后就跟正常的情况一样，它也会接收到<code>BehaviorSubject</code>之后发出的新的<code>event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建一个BehaviorSubject</span><br><span class=\"line\">let subject = BehaviorSubject.init(value: &quot;🐭&quot;)</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">//发送error事件</span><br><span class=\"line\">subject.onError(NSError(domain: &quot;local&quot;, code: 0, userInfo: nil))</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第二次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(🐭)</span><br><span class=\"line\">第一次订阅:next(🐯)</span><br><span class=\"line\">第一次订阅:error(Error Domain=local Code=0 &quot;(null)&quot;)</span><br><span class=\"line\">第二次订阅:error(Error Domain=local Code=0 &quot;(null)&quot;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-Variable\"><a href=\"#4-Variable\" class=\"headerlink\" title=\"4. Variable\"></a>4. Variable</h4><p>在<code>RxSwift</code>中，<code>Variable</code>相当于<code>Swift</code>中的<code>var</code>。</p>\n<ul>\n<li><code>Variable</code>其实就是对<code>BehaviorSubject</code>的封装，所以它也必须要通过一个默认的初始值进行创建。</li>\n<li><code>Variable</code>具有<code>BehaviorSubject</code>的功能，能够向它的订阅者发出上一个<code>event</code>以及之后新创建的<code>event</code>。</li>\n<li>不同的是，<code>Variable</code>还会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送<code>.complete</code>的<code>event</code>，不需要也不能手动给<code>Variables</code>发送<code>completed</code>或者<code>error</code>事件来结束它。</li>\n<li>简单地说就是<code>Variable</code>有一个<code>value</code>属性，我们改变这个<code>value</code>属性的值就相当于调用一般<code>Subjects</code>的<code>onNext()</code>方法，而这个最新的<code>onNext()</code>的值就被保存在<code>value</code>属性里了，直到我们再次修改它。</li>\n<li><code>Variables</code>本身没有<code>subscribe()</code>方法，但是所有<code>Subjects</code>都有一个<code>asObservable()</code>方法。我们可以使用这个方法返回这个<code>Variable</code>的<code>Observable</code>类型，拿到这个<code>Observable</code>类型我们就能订阅它了。</li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let variable = Variable.init(&quot;A&quot;)</span><br><span class=\"line\">variable.value = &quot;B&quot;</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">variable.asObservable().subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//修改value</span><br><span class=\"line\">variable.value = &quot;C&quot;</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">variable.asObservable().subscribe&#123; print(&quot;第二次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//修改value</span><br><span class=\"line\">variable.value = &quot;D&quot;</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br><span class=\"line\">第一次订阅:completed</span><br><span class=\"line\">第二次订阅:completed</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在我们日常开发中，有一些既可是<code>Observable</code>又可是<code>Observer</code>。举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let observable = textField.rx.text</span><br><span class=\"line\">observable.subscribe(onNext: &#123; text in show(text: text) &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在这行代码中，<code>textField</code>当前文本就是一个<code>Observable</code>，当用户在<code>textField</code>中输入时，就会<code>show</code>文本内容。<br>再举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let observer = textField.rx.text</span><br><span class=\"line\">let observable = Observable&lt;String&gt;.just(&quot;A&quot;)</span><br><span class=\"line\">observable.bind(to: observer)</span><br><span class=\"line\">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>这个时候，屏幕上就会显示：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-a113479a0f2d92f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"textField.png\"><br>这时，<code>textField</code>的当前文本就是<code>Observer</code>。<br>此外，框架中还有一些辅助类型，既可是<code>Observable</code>又可是<code>Observer</code>。</p>\n<h4 id=\"1-AsyncSubject\"><a href=\"#1-AsyncSubject\" class=\"headerlink\" title=\"1. AsyncSubject\"></a>1. AsyncSubject</h4><p><code>AsyncSubject</code>将在<code>Observable</code>产生完成事件后，发出最后一个元素（仅仅只有最后一个元素）。如果<code>Observable</code>没有发出任何元素，只有一个完成事件，那<code>AsyncSubject</code>也只有一个完成事件。如果<code>Observable</code>因<code>error</code>中止，那么<code>AsyncSubject</code>只会将<code>error</code>发送出来，不会发出其它元素。<br>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建一个AsyncSubject</span><br><span class=\"line\">let subject = AsyncSubject&lt;String&gt;()</span><br><span class=\"line\">//订阅subject</span><br><span class=\"line\">subject.subscribe&#123; print($0) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">subject.onCompleted()</span><br></pre></td></tr></table></figure></p>\n<p>这个时候输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">next(D)</span><br><span class=\"line\">completed</span><br></pre></td></tr></table></figure></p>\n<p>此时我们再改造一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let subject = AsyncSubject&lt;String&gt;()</span><br><span class=\"line\">subject.subscribe&#123; print($0) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br><span class=\"line\">//SubjectError 自己定义的enum Error</span><br><span class=\"line\">subject.onError(SubjectError.error)</span><br></pre></td></tr></table></figure></p>\n<p>就会输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error(error)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-PublishSubject\"><a href=\"#2-PublishSubject\" class=\"headerlink\" title=\"2. PublishSubject\"></a>2. PublishSubject</h4><p><code>PublishSubject</code>是将对观察者发送<code>订阅后产生的元素</code>，而在订阅前发出的元素将不会发送给观察者。</p>\n<ul>\n<li><code>PublishSubject</code>是最普通的<code>Subject</code>，它不需要初始值就能创建</li>\n<li><code>PublishSubject</code>的订阅者从他们开始订阅的时间点起，可以收到订阅后<code>Subject</code>发出的新<code>Event</code>，而不会收到他们在订阅前已发出的<code>Event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let subject = PublishSubject&lt;String&gt;()</span><br><span class=\"line\">//由于当前没有订阅，所以不输出</span><br><span class=\"line\">subject.onNext(&quot;🐶&quot;)</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">subject.subscribe(onNext: &#123; (element) in</span><br><span class=\"line\">    print(&quot;第一次订阅:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;).disposed(by: disposeBag)</span><br><span class=\"line\">//当前有一个订阅，输出</span><br><span class=\"line\">subject.onNext(&quot;🐱&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe(onNext: &#123; (element) in</span><br><span class=\"line\">    print(&quot;第二次订阅:\\(element)&quot;)</span><br><span class=\"line\">&#125;, onCompleted: &#123;</span><br><span class=\"line\">    print(&quot;completed&quot;)</span><br><span class=\"line\">&#125;).disposed(by: disposeBag)</span><br><span class=\"line\">//当前有两个订阅 输出</span><br><span class=\"line\">subject.onNext(&quot;🐹&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">//结束subject</span><br><span class=\"line\">subject.onCompleted()</span><br><span class=\"line\">//再次发出.next事件</span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>显示如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:🐱</span><br><span class=\"line\">第一次订阅:🐹</span><br><span class=\"line\">第二次订阅:🐹</span><br><span class=\"line\">第一次订阅:completed</span><br><span class=\"line\">第二次订阅:completed</span><br><span class=\"line\">第三次订阅:completed</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-ReplaySubject\"><a href=\"#3-ReplaySubject\" class=\"headerlink\" title=\"3. ReplaySubject\"></a>3. ReplaySubject</h4><p><code>ReplaySubject</code>将对观察者发送全部的元素，无论观察者是何时进行订阅的。这里存在多个版本的<code>ReplaySubject</code>，有的只会将最新的n个元素发送给观察者，有的只会将限制时间段内最新的元素发送给观察者。如果把<code>ReplaySubject</code>当作观察者来使用，注意不要在多个线程调用<code>onNext</code>,<code>onError</code>或<code>onCompleted</code>。这样会导致无序调用，将造成意想不到的结果。</p>\n<ul>\n<li><code>ReplaySubject</code>在创建时候需要设置一个<code>bufferSize</code>，表示它对于它发送过的<code>event</code>的缓存个数</li>\n<li>比如一个<code>ReplaySubject</code>的<code>bufferSize</code>设置为 2，它发出了 3 个<code>.next</code>的<code>event</code>，那么它会将后两个（最近的两个）<code>event</code>给缓存起来。此时如果有一个<code>subscriber</code>订阅了这个 <code>ReplaySubject</code>，那么这个<code>subscriber</code>就会立即收到前面缓存的两个<code>.next</code>的<code>event</code></li>\n<li>如果一个<code>subscriber</code>订阅已经结束的<code>ReplaySubject</code>，除了会收到缓存的<code>.next</code>的<code>event</code>外，还会收到那个终结的<code>.error</code>或者<code>.complete</code>的<code>event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建</span><br><span class=\"line\">let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 0)</span><br><span class=\"line\">//第1次订阅subject</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;A&quot;)</span><br><span class=\"line\">subject.onNext(&quot;B&quot;)</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第二次订阅:\\($0)&quot; )&#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;C&quot;)</span><br><span class=\"line\">subject.onNext(&quot;D&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<p>当<code>bufferSize</code>改成1时，结果就变成了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第二次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<p>如果是2的话，结果就变成了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(A)</span><br><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第二次订阅:next(A)</span><br><span class=\"line\">第二次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-BehaviorSubject\"><a href=\"#4-BehaviorSubject\" class=\"headerlink\" title=\"4. BehaviorSubject\"></a>4. BehaviorSubject</h4><p><code>BehaviorSubject</code>会把<code>Observable</code>最新元素发出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。如果<code>Observable</code>因为<code>error</code>事件而中止，则不会发出任何元素，将<code>error</code>事件发出来。</p>\n<ul>\n<li><code>BehaviorSubject</code>需要通过一个默认初始值来创建</li>\n<li>当一个订阅者来订阅它的时候，这个订阅者会立即收到 <code>BehaviorSubjects</code>上一个发出的<code>event</code>。之后就跟正常的情况一样，它也会接收到<code>BehaviorSubject</code>之后发出的新的<code>event</code></li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">//创建一个BehaviorSubject</span><br><span class=\"line\">let subject = BehaviorSubject.init(value: &quot;🐭&quot;)</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//发送.next事件</span><br><span class=\"line\">subject.onNext(&quot;🐯&quot;)</span><br><span class=\"line\">//发送error事件</span><br><span class=\"line\">subject.onError(NSError(domain: &quot;local&quot;, code: 0, userInfo: nil))</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">subject.subscribe&#123; print(&quot;第二次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(🐭)</span><br><span class=\"line\">第一次订阅:next(🐯)</span><br><span class=\"line\">第一次订阅:error(Error Domain=local Code=0 &quot;(null)&quot;)</span><br><span class=\"line\">第二次订阅:error(Error Domain=local Code=0 &quot;(null)&quot;)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"4-Variable\"><a href=\"#4-Variable\" class=\"headerlink\" title=\"4. Variable\"></a>4. Variable</h4><p>在<code>RxSwift</code>中，<code>Variable</code>相当于<code>Swift</code>中的<code>var</code>。</p>\n<ul>\n<li><code>Variable</code>其实就是对<code>BehaviorSubject</code>的封装，所以它也必须要通过一个默认的初始值进行创建。</li>\n<li><code>Variable</code>具有<code>BehaviorSubject</code>的功能，能够向它的订阅者发出上一个<code>event</code>以及之后新创建的<code>event</code>。</li>\n<li>不同的是，<code>Variable</code>还会把当前发出的值保存为自己的状态。同时它会在销毁时自动发送<code>.complete</code>的<code>event</code>，不需要也不能手动给<code>Variables</code>发送<code>completed</code>或者<code>error</code>事件来结束它。</li>\n<li>简单地说就是<code>Variable</code>有一个<code>value</code>属性，我们改变这个<code>value</code>属性的值就相当于调用一般<code>Subjects</code>的<code>onNext()</code>方法，而这个最新的<code>onNext()</code>的值就被保存在<code>value</code>属性里了，直到我们再次修改它。</li>\n<li><code>Variables</code>本身没有<code>subscribe()</code>方法，但是所有<code>Subjects</code>都有一个<code>asObservable()</code>方法。我们可以使用这个方法返回这个<code>Variable</code>的<code>Observable</code>类型，拿到这个<code>Observable</code>类型我们就能订阅它了。</li>\n</ul>\n<p>举个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let disposeBag = DisposeBag()</span><br><span class=\"line\">let variable = Variable.init(&quot;A&quot;)</span><br><span class=\"line\">variable.value = &quot;B&quot;</span><br><span class=\"line\">//第一次订阅</span><br><span class=\"line\">variable.asObservable().subscribe&#123; print(&quot;第一次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//修改value</span><br><span class=\"line\">variable.value = &quot;C&quot;</span><br><span class=\"line\">//第二次订阅</span><br><span class=\"line\">variable.asObservable().subscribe&#123; print(&quot;第二次订阅:\\($0)&quot;) &#125;</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br><span class=\"line\">//修改value</span><br><span class=\"line\">variable.value = &quot;D&quot;</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一次订阅:next(B)</span><br><span class=\"line\">第一次订阅:next(C)</span><br><span class=\"line\">第二次订阅:next(C)</span><br><span class=\"line\">第一次订阅:next(D)</span><br><span class=\"line\">第二次订阅:next(D)</span><br><span class=\"line\">第一次订阅:completed</span><br><span class=\"line\">第二次订阅:completed</span><br></pre></td></tr></table></figure></p>\n"},{"title":"源码阅读 Kingfisher","date":"2018-10-09T12:33:02.000Z","_content":"[Kingfisher](https://github.com/onevcat/Kingfisher)是一个用于图片下载和缓存的轻量级、纯swift库。通过[喵神](https://weibo.com/onevcat?profile_ftype=1&is_all=1#_rnd1539003449528)的介绍，可以得知`Kingfisher`有以下特点：\n\n- 实现了图片的异步下载和缓存\n- 基于`URLSession`的网络，提供基本图像处理器和过滤器。\n- 内存和磁盘的多层缓存。\n- 可取消下载和处理任务以提高性能。\n- 独立的组件，根据需要单独使用下载器或缓存系统。\n- 预览图像并在以后需要时从缓存中显示它们。\n- 对`UIImageView`,` NSImage`和`UIButton`的扩展，可以直接从`URL`设置图像。\n- 设置图像时内置过渡动画。\n- 加载图像时可自定义占位符。\n- 可扩展的图像处理和图像格式支持。\n\n## 目录结构\n在项目中，我们使用`CocoaPods `下载安装`Kingfisher `。\n我们查看`Kingfisher`的目录结构，如下\n```\nKingfisher\n    AnimatedImageView.swift    //动画控件   \n    Box.swift    //工具类\n    CacheSerializer.swift    //序列化类，读写文件时Data和Image互转\n    Filter.swift    //仅对CIImage有效\n    FormatIndicatedCacheSerializer.swift    //PNG/JPEG/GIF和Data互转\n    Image.swift    //图片格式转换\n    ImageCache.swift    //图片缓存\n    ImageDownloader.swift    //图片下载\n    ImageModifier.swift    //图片修改\n    ImagePrefetcher.swift    //图片下载管理类，对并发多个下载任务的处理\n    ImageProcessor.swift    //数据处理类，将Data转为Image\n    ImageTransition.swift    //动画效果\n    ImageView+Kingfisher.swift    //扩展ImageView添加下载图片的方法\n    Indicator.swift    //动画相关\n    Kingfisher.h    //版本号\n    Kingfisher.swift    //类，扩展ImageView添加属性kf\n    KingfisherManager.swift    //管理类，封装图片下载和缓存的逻辑\n    KingfisherOptionsInfo.swift    //枚举类\n    Placeholder.swift    //默认图片管理类\n    RequestModifier.swift    //协议，修改原始URLRequest参数\n    Resource.swift    //协议，声明下载链接和缓存key\n    String+MD5.swift    //MD5加密\n    ThreadHelper.swift    //工具类\n    UIButton+Kingfisher.swift    //扩展UIButton添加下载图片的方法\n```\n## 调用方法\n很简单的一句话：\n```\nself.imageV.kf.setImage(with: imgUrl)\n```\n如果想在图片加载的过程中添加默认图片，可以添加`placeholder`方法，监听加载的过程`progressBlock`，图片加载完成后的回调`completionHandler`。\n## 查看方法\n查看`kf.setImage`方法，我们会跳到*ImageView+Kingfisher.swift*文件里。这里我们对方法做一个简单的介绍\n```\n@discardableResult\npublic func setImage(with resource: Resource?,\n                     placeholder: Placeholder? = nil,\n                     options: KingfisherOptionsInfo? = nil,\n                     progressBlock: DownloadProgressBlock? = nil,\n                     completionHandler: CompletionHandler? = nil) -> RetrieveImageTask{...}\n```\n我们可以看到，在这个方法里面，包括了ImageView的资源、默认图片、作者封装的枚举类、加载进度的回调以及完成结果。\n`@discardableResult`方法是为了取消不使用返回值的警告。\n在这个方法里面(方法太长就不列举出来，捡主要的说)，\n- 首先判断参数合法性，当`resource `为`nil`时，展示默认图片。\n- 设置读取策略和启动动画。比如常见的一个问题：当用户头像改变但图片`URL`没有改变时，怎么去处理用户头像。一般有两种方法，一种是在缓存用户头像时保存当前时间。另一种就是设置读取策略，`KingfisherOptionsInfo`是一个枚举，设置它为`forceRefresh `时，可以强制刷新。\n- 从内存、文件或网络`URL`获取对应图片数据。\n- 获取图片完成后，在主线程刷新界面。\n\n我们查看一下这里面的参数：\n### Resource\nResource是一个协议，我们查看源码可以看到：\n```\npublic protocol Resource {\n    var cacheKey: String { get }\n    var downloadURL: URL { get }\n}\n```\n`cacheKey`是图片保存的key值，当`cacheKey`为`nil`时，取`downloadURL.absoluteString`(有兴趣的可以去了解一下`absoluteString`和`path`的区别)。`downloadURL`不言而喻，就是图片的`URL`。\n### Placeholder\n```\npublic protocol Placeholder {\n    func add(to imageView: ImageView)\n    func remove(from imageView: ImageView)\n}\n```\n`Placeholder`是一个协议，作者为它定义了`add`和`remove`方法，任何。默认实现了`Image`，如果想用`View`充当`Placeholder`，只要让`view`遵守协议即可\n```\nextension Placeholder where Self: View{}\n```\n### KingfisherOptionsInfo\n`KingfisherOptionsInfo`是一个类型别名，点击查看\n```\npublic typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]\n```\n所以我们关注的应该是`KingfisherOptionsInfoItem`是什么东西？那么它是什么呢？\n```\npublic enum KingfisherOptionsInfoItem {\n    case targetCache(ImageCache)    //系统缓存位置。可以设置的属性\n    case originalCache(ImageCache)    //系统缓存原始图像位置（只用于自己设置placeholder） \n    case downloader(ImageDownloader)    //获取更改session属性，设置请求\n    case transition(ImageTransition)    //自定义动画\n    case downloadPriority(Float)    //下载优先级（0-1）\n    case forceRefresh    //每次请求忽略缓存，直接下载\n    case fromMemoryCacheOrRefresh    //先取缓存再去文件，再去下载\n    case forceTransition    //强制移动\n    case cacheMemoryOnly     //只从缓存读取，不读取本机沙盒图片\n    case onlyFromCache    //从缓存、沙盒读取，没有也不下载网络，显示placeholder\n    case backgroundDecode    //设置后，显示前在后台线程解码\n    case callbackDispatchQueue(DispatchQueue?)    //自定义回调队列，默认主线程\n    case scaleFactor(CGFloat)    //自定义图片data -> Image缩放比例，不指定按屏幕2x\\3x缩放\n    case preloadAllAnimationData    //预先加载data成图片缓存\n    case requestModifier(ImageDownloadRequestModifier)    //改变请求\n    case processor(ImageProcessor)    //自定义Data转图片样式\n    case cacheSerializer(CacheSerializer)    //自定义缓存Data 转图像样式\n    case imageModifier(ImageModifier)    //修改图像\n    case keepCurrentImageWhileLoading     //包含这个意味着placeHolder设置无效，没有直接用默认\n    case onlyLoadFirstFrame    //如果返回结果是.gif图，只取第一帧显示\n    case cacheOriginalImage    //同时缓存原始图片和下载后的图片\n}\n```\n### DownloadProgressBlock\n```\npublic typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -> ())\n```\n`DownloadProgressBlock`里面有`receivedSize`和`totalSize`，可以根据这两个参数得知图片下载了多少和图片多大，也可以计算图片的下载进度。\n### CompletionHandler\n```\npublic typealias CompletionHandler = ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -> ())\n```\n`CompletionHandler`的回调里会有`image`、`error`、`cacheType`、`imageURL`四个参数。`image`、`error`、`imageURL`不做介绍，直接就能看出什么内容。\n主要看一下`cacheType`:\n```\npublic enum CacheType {\n    case none, memory, disk\n    public var cached: Bool {\n        switch self {\n        case .memory, .disk: return true\n        case .none: return false\n        }\n    }\n}\n```\n- `none`检索图片时，图片尚未缓存\n- `memory`图片缓存在内存中\n- `disk`图片缓存在磁盘中\n\n\n\n## 检索图片\nOK，让我们继续看这些代码。在`setImage`方法中，从内存、文件或网络`URL`获取对应图片数据是怎么实现的呢？这里，我们可以查看`KingfisherManager.shared.retrieveImage`方法。\n```\n@discardableResult\npublic func retrieveImage(with resource: Resource,\n    options: KingfisherOptionsInfo?,\n    progressBlock: DownloadProgressBlock?,\n    completionHandler: CompletionHandler?) -> RetrieveImageTask\n{\n    let task = RetrieveImageTask()\n    let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo)\n    if options.forceRefresh {\n        _ = downloadAndCacheImage(\n            with: resource.downloadURL,\n            forKey: resource.cacheKey,\n            retrieveImageTask: task,\n            progressBlock: progressBlock,\n            completionHandler: completionHandler,\n            options: options)\n    } else {    \n        tryToRetrieveImageFromCache(\n            forKey: resource.cacheKey,\n            with: resource.downloadURL, \n            retrieveImageTask: task,\n            progressBlock: progressBlock,\n            completionHandler: completionHandler,\n            options: options)\n    }\n    \n    return task\n}\n```\n可以看到，代码会通过`KingfisherOptionsInfo`进行判断是强制刷新，网络下载并执行缓存策略还是从内存或文件中获取对应的Image。\n### 图片下载\n```\n@discardableResult\nfunc downloadAndCacheImage(with url: URL,\n                         forKey key: String,\n                  retrieveImageTask: RetrieveImageTask,\n                      progressBlock: DownloadProgressBlock?,\n                  completionHandler: CompletionHandler?,\n                            options: KingfisherOptionsInfo) -> RetrieveImageDownloadTask?{...}\n```\n在`downloadAndCacheImage`方法中，会`return  downloader.downloadImage`方法，下载的主要逻辑在这里实现，对应的文件是*ImageDownloader.swift*。\n```\n@discardableResult\nopen func downloadImage(with url: URL,\n               retrieveImageTask: RetrieveImageTask? = nil,\n                         options: KingfisherOptionsInfo? = nil,\n                   progressBlock: ImageDownloaderProgressBlock? = nil,\n               completionHandler: ImageDownloaderCompletionHandler? = nil) -> RetrieveImageDownloadTask?{...}\n```\n`ImageDownloader.swift`文件中，主要参数：\n- `downloadTimeout` 超时时间，默认15秒\n- `trustedHosts ` 信任的请求地址，和自己实现请求代理设置冲突，二选一\n- `sessionConfiguration` session配置设置\n- `requestsUsePipelining` 请求是否管道类型，是否按顺序下载，默认`false`\n- `sessionHandler`单独设计出的一个`ImageDownloaderSessionHandler`，是为了解决之前出现的[内存泄漏](https://github.com/onevcat/Kingfisher/issues/235)\n- `delegate` 下载代理\n- `authenticationChallengeResponder` 信任请求代理，和trustedHosts冲突二选一\n- `fetchLoads` 下载完成每个URL可能有多个处理方式，优先取这里的\n- 此外还有三个`DispatchQueue`：`barrierQueue`、`processQueue`、`cancelQueue`\n\n下载完成后，在`completionHandler`回调中处理图片，如果下载失败：\n```\nif let error = error, error.code == KingfisherError.notModified.rawValue {\n    //从缓存中读取，不需保存，直接返回\n    targetCache.retrieveImage(forKey: key, options: options, completionHandler: { (cacheImage, cacheType) -> () in\n        completionHandler?(cacheImage, nil, cacheType, url)\n    })\n    return\n}\n```\n下载成功：\n```\nif let image = image, let originalData = originalData {\n    //存储图片\n    targetCache.store(image,\n                      original: originalData,\n                      forKey: key,\n                      processorIdentifier:options.processor.identifier,\n                      cacheSerializer: options.cacheSerializer,\n                      toDisk: !options.cacheMemoryOnly,\n                      completionHandler: nil)\n        if options.cacheOriginalImage && options.processor != DefaultImageProcessor.default {\n            let originalCache = options.originalCache\n            let defaultProcessor = DefaultImageProcessor.default\n            if let originalImage = defaultProcessor.process(item: .data(originalData), options: options) {\n                originalCache.store(originalImage,\n                        original: originalData,\n                        forKey: key,\n                        processorIdentifier: defaultProcessor.identifier,\n                        cacheSerializer: options.cacheSerializer,\n                        toDisk: !options.cacheMemoryOnly,\n                        completionHandler: nil)\n            }\n        }\n}\n```\n#### 存储图片\n我们先来看一下实现的代码：\n```\nopen func store(_ image: Image,\n                  original: Data? = nil,\n                  forKey key: String,\n                  processorIdentifier identifier: String = \"\",\n                  cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,\n                  toDisk: Bool = true,\n                  completionHandler: (() -> Void)? = nil){...}\n```\n代码中`memoryCache `是：\n```\nfileprivate let memoryCache = NSCache<NSString, AnyObject>()\n```\n可见图片存储首先是缓存在`NSCache`中，如果想存储在磁盘中(`if toDisk`)，利用串行队列异步的进行存储原图。\n#### 获取图片\n```\n@discardableResult\nopen func retrieveImage(forKey key: String,\n                           options: KingfisherOptionsInfo?,\n                 completionHandler: ((Image?, CacheType) -> ())?) -> RetrieveImageDiskTask?{...}\n```\n- 首先从内存中获取图片`if let image = self.retrieveImageInMemoryCache(forKey: key, options: options)`\n- 如果没有，在根据条件判断是否从磁盘上获取`if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options)`\n\n#### 删除图片\n```\nopen func removeImage(forKey key: String,\n                      processorIdentifier identifier: String = \"\",\n                      fromDisk: Bool = true,\n                      completionHandler: (() -> Void)? = nil){...}\n```\n\n```\n@objc public func clearMemoryCache() {...}\n```\n```\nopen func clearDiskCache(completion handler: (()->())? = nil) {...}\n```\n```\nopen func cleanExpiredDiskCache(completion handler: (()->())? = nil) {...}\n```\n```\n@objc public func backgroundCleanExpiredDiskCache() {...}\n```\n其中，一些方法是通过通知的方法来实现：\n```\n// 系统内存警告\nNotificationCenter.default.addObserver(self, selector: #selector(clearMemoryCache), name: .UIApplicationDidReceiveMemoryWarning, object: nil)    \n// 程序终止\nNotificationCenter.default.addObserver(self, selector: #selector(cleanExpiredDiskCache), name: .UIApplicationWillTerminate, object: nil)\n// 程序进入后台\nNotificationCenter.default.addObserver(self, selector: #selector(backgroundCleanExpiredDiskCache), name: .UIApplicationDidEnterBackground, object: nil)\n```\n此外，还有一些属性要注意:\n- `maxMemoryCost `最大缓存量，在收到内存警告时会被清空。\n- `pathExtension`沙盒后续拼接文件夹名称\n- `maxCachePeriodInSecond `默认清除一周前的图片\n- `maxDiskCacheSize `沙盒最大存储量，为0，默认无限制\n\n以上就是对Kingfisher的简单描述，它有很多方法值得我们去借鉴，比如`@discardableResult`、`where`、`typealias`、`if case let`、善于利用`guard`、扩展协议等等。\n\n\n\n\n\n","source":"_posts/源码阅读-Kingfisher.md","raw":"---\ntitle: 源码阅读 Kingfisher\ndate: 2018-10-09 20:33:02\ntags: 源码阅读\n---\n[Kingfisher](https://github.com/onevcat/Kingfisher)是一个用于图片下载和缓存的轻量级、纯swift库。通过[喵神](https://weibo.com/onevcat?profile_ftype=1&is_all=1#_rnd1539003449528)的介绍，可以得知`Kingfisher`有以下特点：\n\n- 实现了图片的异步下载和缓存\n- 基于`URLSession`的网络，提供基本图像处理器和过滤器。\n- 内存和磁盘的多层缓存。\n- 可取消下载和处理任务以提高性能。\n- 独立的组件，根据需要单独使用下载器或缓存系统。\n- 预览图像并在以后需要时从缓存中显示它们。\n- 对`UIImageView`,` NSImage`和`UIButton`的扩展，可以直接从`URL`设置图像。\n- 设置图像时内置过渡动画。\n- 加载图像时可自定义占位符。\n- 可扩展的图像处理和图像格式支持。\n\n## 目录结构\n在项目中，我们使用`CocoaPods `下载安装`Kingfisher `。\n我们查看`Kingfisher`的目录结构，如下\n```\nKingfisher\n    AnimatedImageView.swift    //动画控件   \n    Box.swift    //工具类\n    CacheSerializer.swift    //序列化类，读写文件时Data和Image互转\n    Filter.swift    //仅对CIImage有效\n    FormatIndicatedCacheSerializer.swift    //PNG/JPEG/GIF和Data互转\n    Image.swift    //图片格式转换\n    ImageCache.swift    //图片缓存\n    ImageDownloader.swift    //图片下载\n    ImageModifier.swift    //图片修改\n    ImagePrefetcher.swift    //图片下载管理类，对并发多个下载任务的处理\n    ImageProcessor.swift    //数据处理类，将Data转为Image\n    ImageTransition.swift    //动画效果\n    ImageView+Kingfisher.swift    //扩展ImageView添加下载图片的方法\n    Indicator.swift    //动画相关\n    Kingfisher.h    //版本号\n    Kingfisher.swift    //类，扩展ImageView添加属性kf\n    KingfisherManager.swift    //管理类，封装图片下载和缓存的逻辑\n    KingfisherOptionsInfo.swift    //枚举类\n    Placeholder.swift    //默认图片管理类\n    RequestModifier.swift    //协议，修改原始URLRequest参数\n    Resource.swift    //协议，声明下载链接和缓存key\n    String+MD5.swift    //MD5加密\n    ThreadHelper.swift    //工具类\n    UIButton+Kingfisher.swift    //扩展UIButton添加下载图片的方法\n```\n## 调用方法\n很简单的一句话：\n```\nself.imageV.kf.setImage(with: imgUrl)\n```\n如果想在图片加载的过程中添加默认图片，可以添加`placeholder`方法，监听加载的过程`progressBlock`，图片加载完成后的回调`completionHandler`。\n## 查看方法\n查看`kf.setImage`方法，我们会跳到*ImageView+Kingfisher.swift*文件里。这里我们对方法做一个简单的介绍\n```\n@discardableResult\npublic func setImage(with resource: Resource?,\n                     placeholder: Placeholder? = nil,\n                     options: KingfisherOptionsInfo? = nil,\n                     progressBlock: DownloadProgressBlock? = nil,\n                     completionHandler: CompletionHandler? = nil) -> RetrieveImageTask{...}\n```\n我们可以看到，在这个方法里面，包括了ImageView的资源、默认图片、作者封装的枚举类、加载进度的回调以及完成结果。\n`@discardableResult`方法是为了取消不使用返回值的警告。\n在这个方法里面(方法太长就不列举出来，捡主要的说)，\n- 首先判断参数合法性，当`resource `为`nil`时，展示默认图片。\n- 设置读取策略和启动动画。比如常见的一个问题：当用户头像改变但图片`URL`没有改变时，怎么去处理用户头像。一般有两种方法，一种是在缓存用户头像时保存当前时间。另一种就是设置读取策略，`KingfisherOptionsInfo`是一个枚举，设置它为`forceRefresh `时，可以强制刷新。\n- 从内存、文件或网络`URL`获取对应图片数据。\n- 获取图片完成后，在主线程刷新界面。\n\n我们查看一下这里面的参数：\n### Resource\nResource是一个协议，我们查看源码可以看到：\n```\npublic protocol Resource {\n    var cacheKey: String { get }\n    var downloadURL: URL { get }\n}\n```\n`cacheKey`是图片保存的key值，当`cacheKey`为`nil`时，取`downloadURL.absoluteString`(有兴趣的可以去了解一下`absoluteString`和`path`的区别)。`downloadURL`不言而喻，就是图片的`URL`。\n### Placeholder\n```\npublic protocol Placeholder {\n    func add(to imageView: ImageView)\n    func remove(from imageView: ImageView)\n}\n```\n`Placeholder`是一个协议，作者为它定义了`add`和`remove`方法，任何。默认实现了`Image`，如果想用`View`充当`Placeholder`，只要让`view`遵守协议即可\n```\nextension Placeholder where Self: View{}\n```\n### KingfisherOptionsInfo\n`KingfisherOptionsInfo`是一个类型别名，点击查看\n```\npublic typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]\n```\n所以我们关注的应该是`KingfisherOptionsInfoItem`是什么东西？那么它是什么呢？\n```\npublic enum KingfisherOptionsInfoItem {\n    case targetCache(ImageCache)    //系统缓存位置。可以设置的属性\n    case originalCache(ImageCache)    //系统缓存原始图像位置（只用于自己设置placeholder） \n    case downloader(ImageDownloader)    //获取更改session属性，设置请求\n    case transition(ImageTransition)    //自定义动画\n    case downloadPriority(Float)    //下载优先级（0-1）\n    case forceRefresh    //每次请求忽略缓存，直接下载\n    case fromMemoryCacheOrRefresh    //先取缓存再去文件，再去下载\n    case forceTransition    //强制移动\n    case cacheMemoryOnly     //只从缓存读取，不读取本机沙盒图片\n    case onlyFromCache    //从缓存、沙盒读取，没有也不下载网络，显示placeholder\n    case backgroundDecode    //设置后，显示前在后台线程解码\n    case callbackDispatchQueue(DispatchQueue?)    //自定义回调队列，默认主线程\n    case scaleFactor(CGFloat)    //自定义图片data -> Image缩放比例，不指定按屏幕2x\\3x缩放\n    case preloadAllAnimationData    //预先加载data成图片缓存\n    case requestModifier(ImageDownloadRequestModifier)    //改变请求\n    case processor(ImageProcessor)    //自定义Data转图片样式\n    case cacheSerializer(CacheSerializer)    //自定义缓存Data 转图像样式\n    case imageModifier(ImageModifier)    //修改图像\n    case keepCurrentImageWhileLoading     //包含这个意味着placeHolder设置无效，没有直接用默认\n    case onlyLoadFirstFrame    //如果返回结果是.gif图，只取第一帧显示\n    case cacheOriginalImage    //同时缓存原始图片和下载后的图片\n}\n```\n### DownloadProgressBlock\n```\npublic typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -> ())\n```\n`DownloadProgressBlock`里面有`receivedSize`和`totalSize`，可以根据这两个参数得知图片下载了多少和图片多大，也可以计算图片的下载进度。\n### CompletionHandler\n```\npublic typealias CompletionHandler = ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -> ())\n```\n`CompletionHandler`的回调里会有`image`、`error`、`cacheType`、`imageURL`四个参数。`image`、`error`、`imageURL`不做介绍，直接就能看出什么内容。\n主要看一下`cacheType`:\n```\npublic enum CacheType {\n    case none, memory, disk\n    public var cached: Bool {\n        switch self {\n        case .memory, .disk: return true\n        case .none: return false\n        }\n    }\n}\n```\n- `none`检索图片时，图片尚未缓存\n- `memory`图片缓存在内存中\n- `disk`图片缓存在磁盘中\n\n\n\n## 检索图片\nOK，让我们继续看这些代码。在`setImage`方法中，从内存、文件或网络`URL`获取对应图片数据是怎么实现的呢？这里，我们可以查看`KingfisherManager.shared.retrieveImage`方法。\n```\n@discardableResult\npublic func retrieveImage(with resource: Resource,\n    options: KingfisherOptionsInfo?,\n    progressBlock: DownloadProgressBlock?,\n    completionHandler: CompletionHandler?) -> RetrieveImageTask\n{\n    let task = RetrieveImageTask()\n    let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo)\n    if options.forceRefresh {\n        _ = downloadAndCacheImage(\n            with: resource.downloadURL,\n            forKey: resource.cacheKey,\n            retrieveImageTask: task,\n            progressBlock: progressBlock,\n            completionHandler: completionHandler,\n            options: options)\n    } else {    \n        tryToRetrieveImageFromCache(\n            forKey: resource.cacheKey,\n            with: resource.downloadURL, \n            retrieveImageTask: task,\n            progressBlock: progressBlock,\n            completionHandler: completionHandler,\n            options: options)\n    }\n    \n    return task\n}\n```\n可以看到，代码会通过`KingfisherOptionsInfo`进行判断是强制刷新，网络下载并执行缓存策略还是从内存或文件中获取对应的Image。\n### 图片下载\n```\n@discardableResult\nfunc downloadAndCacheImage(with url: URL,\n                         forKey key: String,\n                  retrieveImageTask: RetrieveImageTask,\n                      progressBlock: DownloadProgressBlock?,\n                  completionHandler: CompletionHandler?,\n                            options: KingfisherOptionsInfo) -> RetrieveImageDownloadTask?{...}\n```\n在`downloadAndCacheImage`方法中，会`return  downloader.downloadImage`方法，下载的主要逻辑在这里实现，对应的文件是*ImageDownloader.swift*。\n```\n@discardableResult\nopen func downloadImage(with url: URL,\n               retrieveImageTask: RetrieveImageTask? = nil,\n                         options: KingfisherOptionsInfo? = nil,\n                   progressBlock: ImageDownloaderProgressBlock? = nil,\n               completionHandler: ImageDownloaderCompletionHandler? = nil) -> RetrieveImageDownloadTask?{...}\n```\n`ImageDownloader.swift`文件中，主要参数：\n- `downloadTimeout` 超时时间，默认15秒\n- `trustedHosts ` 信任的请求地址，和自己实现请求代理设置冲突，二选一\n- `sessionConfiguration` session配置设置\n- `requestsUsePipelining` 请求是否管道类型，是否按顺序下载，默认`false`\n- `sessionHandler`单独设计出的一个`ImageDownloaderSessionHandler`，是为了解决之前出现的[内存泄漏](https://github.com/onevcat/Kingfisher/issues/235)\n- `delegate` 下载代理\n- `authenticationChallengeResponder` 信任请求代理，和trustedHosts冲突二选一\n- `fetchLoads` 下载完成每个URL可能有多个处理方式，优先取这里的\n- 此外还有三个`DispatchQueue`：`barrierQueue`、`processQueue`、`cancelQueue`\n\n下载完成后，在`completionHandler`回调中处理图片，如果下载失败：\n```\nif let error = error, error.code == KingfisherError.notModified.rawValue {\n    //从缓存中读取，不需保存，直接返回\n    targetCache.retrieveImage(forKey: key, options: options, completionHandler: { (cacheImage, cacheType) -> () in\n        completionHandler?(cacheImage, nil, cacheType, url)\n    })\n    return\n}\n```\n下载成功：\n```\nif let image = image, let originalData = originalData {\n    //存储图片\n    targetCache.store(image,\n                      original: originalData,\n                      forKey: key,\n                      processorIdentifier:options.processor.identifier,\n                      cacheSerializer: options.cacheSerializer,\n                      toDisk: !options.cacheMemoryOnly,\n                      completionHandler: nil)\n        if options.cacheOriginalImage && options.processor != DefaultImageProcessor.default {\n            let originalCache = options.originalCache\n            let defaultProcessor = DefaultImageProcessor.default\n            if let originalImage = defaultProcessor.process(item: .data(originalData), options: options) {\n                originalCache.store(originalImage,\n                        original: originalData,\n                        forKey: key,\n                        processorIdentifier: defaultProcessor.identifier,\n                        cacheSerializer: options.cacheSerializer,\n                        toDisk: !options.cacheMemoryOnly,\n                        completionHandler: nil)\n            }\n        }\n}\n```\n#### 存储图片\n我们先来看一下实现的代码：\n```\nopen func store(_ image: Image,\n                  original: Data? = nil,\n                  forKey key: String,\n                  processorIdentifier identifier: String = \"\",\n                  cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,\n                  toDisk: Bool = true,\n                  completionHandler: (() -> Void)? = nil){...}\n```\n代码中`memoryCache `是：\n```\nfileprivate let memoryCache = NSCache<NSString, AnyObject>()\n```\n可见图片存储首先是缓存在`NSCache`中，如果想存储在磁盘中(`if toDisk`)，利用串行队列异步的进行存储原图。\n#### 获取图片\n```\n@discardableResult\nopen func retrieveImage(forKey key: String,\n                           options: KingfisherOptionsInfo?,\n                 completionHandler: ((Image?, CacheType) -> ())?) -> RetrieveImageDiskTask?{...}\n```\n- 首先从内存中获取图片`if let image = self.retrieveImageInMemoryCache(forKey: key, options: options)`\n- 如果没有，在根据条件判断是否从磁盘上获取`if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options)`\n\n#### 删除图片\n```\nopen func removeImage(forKey key: String,\n                      processorIdentifier identifier: String = \"\",\n                      fromDisk: Bool = true,\n                      completionHandler: (() -> Void)? = nil){...}\n```\n\n```\n@objc public func clearMemoryCache() {...}\n```\n```\nopen func clearDiskCache(completion handler: (()->())? = nil) {...}\n```\n```\nopen func cleanExpiredDiskCache(completion handler: (()->())? = nil) {...}\n```\n```\n@objc public func backgroundCleanExpiredDiskCache() {...}\n```\n其中，一些方法是通过通知的方法来实现：\n```\n// 系统内存警告\nNotificationCenter.default.addObserver(self, selector: #selector(clearMemoryCache), name: .UIApplicationDidReceiveMemoryWarning, object: nil)    \n// 程序终止\nNotificationCenter.default.addObserver(self, selector: #selector(cleanExpiredDiskCache), name: .UIApplicationWillTerminate, object: nil)\n// 程序进入后台\nNotificationCenter.default.addObserver(self, selector: #selector(backgroundCleanExpiredDiskCache), name: .UIApplicationDidEnterBackground, object: nil)\n```\n此外，还有一些属性要注意:\n- `maxMemoryCost `最大缓存量，在收到内存警告时会被清空。\n- `pathExtension`沙盒后续拼接文件夹名称\n- `maxCachePeriodInSecond `默认清除一周前的图片\n- `maxDiskCacheSize `沙盒最大存储量，为0，默认无限制\n\n以上就是对Kingfisher的简单描述，它有很多方法值得我们去借鉴，比如`@discardableResult`、`where`、`typealias`、`if case let`、善于利用`guard`、扩展协议等等。\n\n\n\n\n\n","slug":"源码阅读-Kingfisher","published":1,"updated":"2018-10-19T07:16:01.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxya000u2ycw4bfwzo1m","content":"<p><a href=\"https://github.com/onevcat/Kingfisher\" target=\"_blank\" rel=\"noopener\">Kingfisher</a>是一个用于图片下载和缓存的轻量级、纯swift库。通过<a href=\"https://weibo.com/onevcat?profile_ftype=1&amp;is_all=1#_rnd1539003449528\" target=\"_blank\" rel=\"noopener\">喵神</a>的介绍，可以得知<code>Kingfisher</code>有以下特点：</p>\n<ul>\n<li>实现了图片的异步下载和缓存</li>\n<li>基于<code>URLSession</code>的网络，提供基本图像处理器和过滤器。</li>\n<li>内存和磁盘的多层缓存。</li>\n<li>可取消下载和处理任务以提高性能。</li>\n<li>独立的组件，根据需要单独使用下载器或缓存系统。</li>\n<li>预览图像并在以后需要时从缓存中显示它们。</li>\n<li>对<code>UIImageView</code>,<code>NSImage</code>和<code>UIButton</code>的扩展，可以直接从<code>URL</code>设置图像。</li>\n<li>设置图像时内置过渡动画。</li>\n<li>加载图像时可自定义占位符。</li>\n<li>可扩展的图像处理和图像格式支持。</li>\n</ul>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><p>在项目中，我们使用<code>CocoaPods</code>下载安装<code>Kingfisher</code>。<br>我们查看<code>Kingfisher</code>的目录结构，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kingfisher</span><br><span class=\"line\">    AnimatedImageView.swift    //动画控件   </span><br><span class=\"line\">    Box.swift    //工具类</span><br><span class=\"line\">    CacheSerializer.swift    //序列化类，读写文件时Data和Image互转</span><br><span class=\"line\">    Filter.swift    //仅对CIImage有效</span><br><span class=\"line\">    FormatIndicatedCacheSerializer.swift    //PNG/JPEG/GIF和Data互转</span><br><span class=\"line\">    Image.swift    //图片格式转换</span><br><span class=\"line\">    ImageCache.swift    //图片缓存</span><br><span class=\"line\">    ImageDownloader.swift    //图片下载</span><br><span class=\"line\">    ImageModifier.swift    //图片修改</span><br><span class=\"line\">    ImagePrefetcher.swift    //图片下载管理类，对并发多个下载任务的处理</span><br><span class=\"line\">    ImageProcessor.swift    //数据处理类，将Data转为Image</span><br><span class=\"line\">    ImageTransition.swift    //动画效果</span><br><span class=\"line\">    ImageView+Kingfisher.swift    //扩展ImageView添加下载图片的方法</span><br><span class=\"line\">    Indicator.swift    //动画相关</span><br><span class=\"line\">    Kingfisher.h    //版本号</span><br><span class=\"line\">    Kingfisher.swift    //类，扩展ImageView添加属性kf</span><br><span class=\"line\">    KingfisherManager.swift    //管理类，封装图片下载和缓存的逻辑</span><br><span class=\"line\">    KingfisherOptionsInfo.swift    //枚举类</span><br><span class=\"line\">    Placeholder.swift    //默认图片管理类</span><br><span class=\"line\">    RequestModifier.swift    //协议，修改原始URLRequest参数</span><br><span class=\"line\">    Resource.swift    //协议，声明下载链接和缓存key</span><br><span class=\"line\">    String+MD5.swift    //MD5加密</span><br><span class=\"line\">    ThreadHelper.swift    //工具类</span><br><span class=\"line\">    UIButton+Kingfisher.swift    //扩展UIButton添加下载图片的方法</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h2><p>很简单的一句话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.imageV.kf.setImage(with: imgUrl)</span><br></pre></td></tr></table></figure></p>\n<p>如果想在图片加载的过程中添加默认图片，可以添加<code>placeholder</code>方法，监听加载的过程<code>progressBlock</code>，图片加载完成后的回调<code>completionHandler</code>。</p>\n<h2 id=\"查看方法\"><a href=\"#查看方法\" class=\"headerlink\" title=\"查看方法\"></a>查看方法</h2><p>查看<code>kf.setImage</code>方法，我们会跳到<em>ImageView+Kingfisher.swift</em>文件里。这里我们对方法做一个简单的介绍<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">public func setImage(with resource: Resource?,</span><br><span class=\"line\">                     placeholder: Placeholder? = nil,</span><br><span class=\"line\">                     options: KingfisherOptionsInfo? = nil,</span><br><span class=\"line\">                     progressBlock: DownloadProgressBlock? = nil,</span><br><span class=\"line\">                     completionHandler: CompletionHandler? = nil) -&gt; RetrieveImageTask&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到，在这个方法里面，包括了ImageView的资源、默认图片、作者封装的枚举类、加载进度的回调以及完成结果。<br><code>@discardableResult</code>方法是为了取消不使用返回值的警告。<br>在这个方法里面(方法太长就不列举出来，捡主要的说)，</p>\n<ul>\n<li>首先判断参数合法性，当<code>resource</code>为<code>nil</code>时，展示默认图片。</li>\n<li>设置读取策略和启动动画。比如常见的一个问题：当用户头像改变但图片<code>URL</code>没有改变时，怎么去处理用户头像。一般有两种方法，一种是在缓存用户头像时保存当前时间。另一种就是设置读取策略，<code>KingfisherOptionsInfo</code>是一个枚举，设置它为<code>forceRefresh</code>时，可以强制刷新。</li>\n<li>从内存、文件或网络<code>URL</code>获取对应图片数据。</li>\n<li>获取图片完成后，在主线程刷新界面。</li>\n</ul>\n<p>我们查看一下这里面的参数：</p>\n<h3 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"Resource\"></a>Resource</h3><p>Resource是一个协议，我们查看源码可以看到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public protocol Resource &#123;</span><br><span class=\"line\">    var cacheKey: String &#123; get &#125;</span><br><span class=\"line\">    var downloadURL: URL &#123; get &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>cacheKey</code>是图片保存的key值，当<code>cacheKey</code>为<code>nil</code>时，取<code>downloadURL.absoluteString</code>(有兴趣的可以去了解一下<code>absoluteString</code>和<code>path</code>的区别)。<code>downloadURL</code>不言而喻，就是图片的<code>URL</code>。</p>\n<h3 id=\"Placeholder\"><a href=\"#Placeholder\" class=\"headerlink\" title=\"Placeholder\"></a>Placeholder</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public protocol Placeholder &#123;</span><br><span class=\"line\">    func add(to imageView: ImageView)</span><br><span class=\"line\">    func remove(from imageView: ImageView)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Placeholder</code>是一个协议，作者为它定义了<code>add</code>和<code>remove</code>方法，任何。默认实现了<code>Image</code>，如果想用<code>View</code>充当<code>Placeholder</code>，只要让<code>view</code>遵守协议即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Placeholder where Self: View&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"KingfisherOptionsInfo\"><a href=\"#KingfisherOptionsInfo\" class=\"headerlink\" title=\"KingfisherOptionsInfo\"></a>KingfisherOptionsInfo</h3><p><code>KingfisherOptionsInfo</code>是一个类型别名，点击查看<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]</span><br></pre></td></tr></table></figure></p>\n<p>所以我们关注的应该是<code>KingfisherOptionsInfoItem</code>是什么东西？那么它是什么呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum KingfisherOptionsInfoItem &#123;</span><br><span class=\"line\">    case targetCache(ImageCache)    //系统缓存位置。可以设置的属性</span><br><span class=\"line\">    case originalCache(ImageCache)    //系统缓存原始图像位置（只用于自己设置placeholder） </span><br><span class=\"line\">    case downloader(ImageDownloader)    //获取更改session属性，设置请求</span><br><span class=\"line\">    case transition(ImageTransition)    //自定义动画</span><br><span class=\"line\">    case downloadPriority(Float)    //下载优先级（0-1）</span><br><span class=\"line\">    case forceRefresh    //每次请求忽略缓存，直接下载</span><br><span class=\"line\">    case fromMemoryCacheOrRefresh    //先取缓存再去文件，再去下载</span><br><span class=\"line\">    case forceTransition    //强制移动</span><br><span class=\"line\">    case cacheMemoryOnly     //只从缓存读取，不读取本机沙盒图片</span><br><span class=\"line\">    case onlyFromCache    //从缓存、沙盒读取，没有也不下载网络，显示placeholder</span><br><span class=\"line\">    case backgroundDecode    //设置后，显示前在后台线程解码</span><br><span class=\"line\">    case callbackDispatchQueue(DispatchQueue?)    //自定义回调队列，默认主线程</span><br><span class=\"line\">    case scaleFactor(CGFloat)    //自定义图片data -&gt; Image缩放比例，不指定按屏幕2x\\3x缩放</span><br><span class=\"line\">    case preloadAllAnimationData    //预先加载data成图片缓存</span><br><span class=\"line\">    case requestModifier(ImageDownloadRequestModifier)    //改变请求</span><br><span class=\"line\">    case processor(ImageProcessor)    //自定义Data转图片样式</span><br><span class=\"line\">    case cacheSerializer(CacheSerializer)    //自定义缓存Data 转图像样式</span><br><span class=\"line\">    case imageModifier(ImageModifier)    //修改图像</span><br><span class=\"line\">    case keepCurrentImageWhileLoading     //包含这个意味着placeHolder设置无效，没有直接用默认</span><br><span class=\"line\">    case onlyLoadFirstFrame    //如果返回结果是.gif图，只取第一帧显示</span><br><span class=\"line\">    case cacheOriginalImage    //同时缓存原始图片和下载后的图片</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"DownloadProgressBlock\"><a href=\"#DownloadProgressBlock\" class=\"headerlink\" title=\"DownloadProgressBlock\"></a>DownloadProgressBlock</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -&gt; ())</span><br></pre></td></tr></table></figure>\n<p><code>DownloadProgressBlock</code>里面有<code>receivedSize</code>和<code>totalSize</code>，可以根据这两个参数得知图片下载了多少和图片多大，也可以计算图片的下载进度。</p>\n<h3 id=\"CompletionHandler\"><a href=\"#CompletionHandler\" class=\"headerlink\" title=\"CompletionHandler\"></a>CompletionHandler</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias CompletionHandler = ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -&gt; ())</span><br></pre></td></tr></table></figure>\n<p><code>CompletionHandler</code>的回调里会有<code>image</code>、<code>error</code>、<code>cacheType</code>、<code>imageURL</code>四个参数。<code>image</code>、<code>error</code>、<code>imageURL</code>不做介绍，直接就能看出什么内容。<br>主要看一下<code>cacheType</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum CacheType &#123;</span><br><span class=\"line\">    case none, memory, disk</span><br><span class=\"line\">    public var cached: Bool &#123;</span><br><span class=\"line\">        switch self &#123;</span><br><span class=\"line\">        case .memory, .disk: return true</span><br><span class=\"line\">        case .none: return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>none</code>检索图片时，图片尚未缓存</li>\n<li><code>memory</code>图片缓存在内存中</li>\n<li><code>disk</code>图片缓存在磁盘中</li>\n</ul>\n<h2 id=\"检索图片\"><a href=\"#检索图片\" class=\"headerlink\" title=\"检索图片\"></a>检索图片</h2><p>OK，让我们继续看这些代码。在<code>setImage</code>方法中，从内存、文件或网络<code>URL</code>获取对应图片数据是怎么实现的呢？这里，我们可以查看<code>KingfisherManager.shared.retrieveImage</code>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">public func retrieveImage(with resource: Resource,</span><br><span class=\"line\">    options: KingfisherOptionsInfo?,</span><br><span class=\"line\">    progressBlock: DownloadProgressBlock?,</span><br><span class=\"line\">    completionHandler: CompletionHandler?) -&gt; RetrieveImageTask</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let task = RetrieveImageTask()</span><br><span class=\"line\">    let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo)</span><br><span class=\"line\">    if options.forceRefresh &#123;</span><br><span class=\"line\">        _ = downloadAndCacheImage(</span><br><span class=\"line\">            with: resource.downloadURL,</span><br><span class=\"line\">            forKey: resource.cacheKey,</span><br><span class=\"line\">            retrieveImageTask: task,</span><br><span class=\"line\">            progressBlock: progressBlock,</span><br><span class=\"line\">            completionHandler: completionHandler,</span><br><span class=\"line\">            options: options)</span><br><span class=\"line\">    &#125; else &#123;    </span><br><span class=\"line\">        tryToRetrieveImageFromCache(</span><br><span class=\"line\">            forKey: resource.cacheKey,</span><br><span class=\"line\">            with: resource.downloadURL, </span><br><span class=\"line\">            retrieveImageTask: task,</span><br><span class=\"line\">            progressBlock: progressBlock,</span><br><span class=\"line\">            completionHandler: completionHandler,</span><br><span class=\"line\">            options: options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return task</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，代码会通过<code>KingfisherOptionsInfo</code>进行判断是强制刷新，网络下载并执行缓存策略还是从内存或文件中获取对应的Image。</p>\n<h3 id=\"图片下载\"><a href=\"#图片下载\" class=\"headerlink\" title=\"图片下载\"></a>图片下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">func downloadAndCacheImage(with url: URL,</span><br><span class=\"line\">                         forKey key: String,</span><br><span class=\"line\">                  retrieveImageTask: RetrieveImageTask,</span><br><span class=\"line\">                      progressBlock: DownloadProgressBlock?,</span><br><span class=\"line\">                  completionHandler: CompletionHandler?,</span><br><span class=\"line\">                            options: KingfisherOptionsInfo) -&gt; RetrieveImageDownloadTask?&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>downloadAndCacheImage</code>方法中，会<code>return  downloader.downloadImage</code>方法，下载的主要逻辑在这里实现，对应的文件是<em>ImageDownloader.swift</em>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">open func downloadImage(with url: URL,</span><br><span class=\"line\">               retrieveImageTask: RetrieveImageTask? = nil,</span><br><span class=\"line\">                         options: KingfisherOptionsInfo? = nil,</span><br><span class=\"line\">                   progressBlock: ImageDownloaderProgressBlock? = nil,</span><br><span class=\"line\">               completionHandler: ImageDownloaderCompletionHandler? = nil) -&gt; RetrieveImageDownloadTask?&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>ImageDownloader.swift</code>文件中，主要参数：</p>\n<ul>\n<li><code>downloadTimeout</code> 超时时间，默认15秒</li>\n<li><code>trustedHosts</code> 信任的请求地址，和自己实现请求代理设置冲突，二选一</li>\n<li><code>sessionConfiguration</code> session配置设置</li>\n<li><code>requestsUsePipelining</code> 请求是否管道类型，是否按顺序下载，默认<code>false</code></li>\n<li><code>sessionHandler</code>单独设计出的一个<code>ImageDownloaderSessionHandler</code>，是为了解决之前出现的<a href=\"https://github.com/onevcat/Kingfisher/issues/235\" target=\"_blank\" rel=\"noopener\">内存泄漏</a></li>\n<li><code>delegate</code> 下载代理</li>\n<li><code>authenticationChallengeResponder</code> 信任请求代理，和trustedHosts冲突二选一</li>\n<li><code>fetchLoads</code> 下载完成每个URL可能有多个处理方式，优先取这里的</li>\n<li>此外还有三个<code>DispatchQueue</code>：<code>barrierQueue</code>、<code>processQueue</code>、<code>cancelQueue</code></li>\n</ul>\n<p>下载完成后，在<code>completionHandler</code>回调中处理图片，如果下载失败：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if let error = error, error.code == KingfisherError.notModified.rawValue &#123;</span><br><span class=\"line\">    //从缓存中读取，不需保存，直接返回</span><br><span class=\"line\">    targetCache.retrieveImage(forKey: key, options: options, completionHandler: &#123; (cacheImage, cacheType) -&gt; () in</span><br><span class=\"line\">        completionHandler?(cacheImage, nil, cacheType, url)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下载成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if let image = image, let originalData = originalData &#123;</span><br><span class=\"line\">    //存储图片</span><br><span class=\"line\">    targetCache.store(image,</span><br><span class=\"line\">                      original: originalData,</span><br><span class=\"line\">                      forKey: key,</span><br><span class=\"line\">                      processorIdentifier:options.processor.identifier,</span><br><span class=\"line\">                      cacheSerializer: options.cacheSerializer,</span><br><span class=\"line\">                      toDisk: !options.cacheMemoryOnly,</span><br><span class=\"line\">                      completionHandler: nil)</span><br><span class=\"line\">        if options.cacheOriginalImage &amp;&amp; options.processor != DefaultImageProcessor.default &#123;</span><br><span class=\"line\">            let originalCache = options.originalCache</span><br><span class=\"line\">            let defaultProcessor = DefaultImageProcessor.default</span><br><span class=\"line\">            if let originalImage = defaultProcessor.process(item: .data(originalData), options: options) &#123;</span><br><span class=\"line\">                originalCache.store(originalImage,</span><br><span class=\"line\">                        original: originalData,</span><br><span class=\"line\">                        forKey: key,</span><br><span class=\"line\">                        processorIdentifier: defaultProcessor.identifier,</span><br><span class=\"line\">                        cacheSerializer: options.cacheSerializer,</span><br><span class=\"line\">                        toDisk: !options.cacheMemoryOnly,</span><br><span class=\"line\">                        completionHandler: nil)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"存储图片\"><a href=\"#存储图片\" class=\"headerlink\" title=\"存储图片\"></a>存储图片</h4><p>我们先来看一下实现的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func store(_ image: Image,</span><br><span class=\"line\">                  original: Data? = nil,</span><br><span class=\"line\">                  forKey key: String,</span><br><span class=\"line\">                  processorIdentifier identifier: String = &quot;&quot;,</span><br><span class=\"line\">                  cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,</span><br><span class=\"line\">                  toDisk: Bool = true,</span><br><span class=\"line\">                  completionHandler: (() -&gt; Void)? = nil)&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码中<code>memoryCache</code>是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fileprivate let memoryCache = NSCache&lt;NSString, AnyObject&gt;()</span><br></pre></td></tr></table></figure></p>\n<p>可见图片存储首先是缓存在<code>NSCache</code>中，如果想存储在磁盘中(<code>if toDisk</code>)，利用串行队列异步的进行存储原图。</p>\n<h4 id=\"获取图片\"><a href=\"#获取图片\" class=\"headerlink\" title=\"获取图片\"></a>获取图片</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">open func retrieveImage(forKey key: String,</span><br><span class=\"line\">                           options: KingfisherOptionsInfo?,</span><br><span class=\"line\">                 completionHandler: ((Image?, CacheType) -&gt; ())?) -&gt; RetrieveImageDiskTask?&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先从内存中获取图片<code>if let image = self.retrieveImageInMemoryCache(forKey: key, options: options)</code></li>\n<li>如果没有，在根据条件判断是否从磁盘上获取<code>if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options)</code></li>\n</ul>\n<h4 id=\"删除图片\"><a href=\"#删除图片\" class=\"headerlink\" title=\"删除图片\"></a>删除图片</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func removeImage(forKey key: String,</span><br><span class=\"line\">                      processorIdentifier identifier: String = &quot;&quot;,</span><br><span class=\"line\">                      fromDisk: Bool = true,</span><br><span class=\"line\">                      completionHandler: (() -&gt; Void)? = nil)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc public func clearMemoryCache() &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func clearDiskCache(completion handler: (()-&gt;())? = nil) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func cleanExpiredDiskCache(completion handler: (()-&gt;())? = nil) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc public func backgroundCleanExpiredDiskCache() &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，一些方法是通过通知的方法来实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 系统内存警告</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(clearMemoryCache), name: .UIApplicationDidReceiveMemoryWarning, object: nil)    </span><br><span class=\"line\">// 程序终止</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(cleanExpiredDiskCache), name: .UIApplicationWillTerminate, object: nil)</span><br><span class=\"line\">// 程序进入后台</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(backgroundCleanExpiredDiskCache), name: .UIApplicationDidEnterBackground, object: nil)</span><br></pre></td></tr></table></figure></p>\n<p>此外，还有一些属性要注意:</p>\n<ul>\n<li><code>maxMemoryCost</code>最大缓存量，在收到内存警告时会被清空。</li>\n<li><code>pathExtension</code>沙盒后续拼接文件夹名称</li>\n<li><code>maxCachePeriodInSecond</code>默认清除一周前的图片</li>\n<li><code>maxDiskCacheSize</code>沙盒最大存储量，为0，默认无限制</li>\n</ul>\n<p>以上就是对Kingfisher的简单描述，它有很多方法值得我们去借鉴，比如<code>@discardableResult</code>、<code>where</code>、<code>typealias</code>、<code>if case let</code>、善于利用<code>guard</code>、扩展协议等等。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://github.com/onevcat/Kingfisher\" target=\"_blank\" rel=\"noopener\">Kingfisher</a>是一个用于图片下载和缓存的轻量级、纯swift库。通过<a href=\"https://weibo.com/onevcat?profile_ftype=1&amp;is_all=1#_rnd1539003449528\" target=\"_blank\" rel=\"noopener\">喵神</a>的介绍，可以得知<code>Kingfisher</code>有以下特点：</p>\n<ul>\n<li>实现了图片的异步下载和缓存</li>\n<li>基于<code>URLSession</code>的网络，提供基本图像处理器和过滤器。</li>\n<li>内存和磁盘的多层缓存。</li>\n<li>可取消下载和处理任务以提高性能。</li>\n<li>独立的组件，根据需要单独使用下载器或缓存系统。</li>\n<li>预览图像并在以后需要时从缓存中显示它们。</li>\n<li>对<code>UIImageView</code>,<code>NSImage</code>和<code>UIButton</code>的扩展，可以直接从<code>URL</code>设置图像。</li>\n<li>设置图像时内置过渡动画。</li>\n<li>加载图像时可自定义占位符。</li>\n<li>可扩展的图像处理和图像格式支持。</li>\n</ul>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><p>在项目中，我们使用<code>CocoaPods</code>下载安装<code>Kingfisher</code>。<br>我们查看<code>Kingfisher</code>的目录结构，如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kingfisher</span><br><span class=\"line\">    AnimatedImageView.swift    //动画控件   </span><br><span class=\"line\">    Box.swift    //工具类</span><br><span class=\"line\">    CacheSerializer.swift    //序列化类，读写文件时Data和Image互转</span><br><span class=\"line\">    Filter.swift    //仅对CIImage有效</span><br><span class=\"line\">    FormatIndicatedCacheSerializer.swift    //PNG/JPEG/GIF和Data互转</span><br><span class=\"line\">    Image.swift    //图片格式转换</span><br><span class=\"line\">    ImageCache.swift    //图片缓存</span><br><span class=\"line\">    ImageDownloader.swift    //图片下载</span><br><span class=\"line\">    ImageModifier.swift    //图片修改</span><br><span class=\"line\">    ImagePrefetcher.swift    //图片下载管理类，对并发多个下载任务的处理</span><br><span class=\"line\">    ImageProcessor.swift    //数据处理类，将Data转为Image</span><br><span class=\"line\">    ImageTransition.swift    //动画效果</span><br><span class=\"line\">    ImageView+Kingfisher.swift    //扩展ImageView添加下载图片的方法</span><br><span class=\"line\">    Indicator.swift    //动画相关</span><br><span class=\"line\">    Kingfisher.h    //版本号</span><br><span class=\"line\">    Kingfisher.swift    //类，扩展ImageView添加属性kf</span><br><span class=\"line\">    KingfisherManager.swift    //管理类，封装图片下载和缓存的逻辑</span><br><span class=\"line\">    KingfisherOptionsInfo.swift    //枚举类</span><br><span class=\"line\">    Placeholder.swift    //默认图片管理类</span><br><span class=\"line\">    RequestModifier.swift    //协议，修改原始URLRequest参数</span><br><span class=\"line\">    Resource.swift    //协议，声明下载链接和缓存key</span><br><span class=\"line\">    String+MD5.swift    //MD5加密</span><br><span class=\"line\">    ThreadHelper.swift    //工具类</span><br><span class=\"line\">    UIButton+Kingfisher.swift    //扩展UIButton添加下载图片的方法</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h2><p>很简单的一句话：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.imageV.kf.setImage(with: imgUrl)</span><br></pre></td></tr></table></figure></p>\n<p>如果想在图片加载的过程中添加默认图片，可以添加<code>placeholder</code>方法，监听加载的过程<code>progressBlock</code>，图片加载完成后的回调<code>completionHandler</code>。</p>\n<h2 id=\"查看方法\"><a href=\"#查看方法\" class=\"headerlink\" title=\"查看方法\"></a>查看方法</h2><p>查看<code>kf.setImage</code>方法，我们会跳到<em>ImageView+Kingfisher.swift</em>文件里。这里我们对方法做一个简单的介绍<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">public func setImage(with resource: Resource?,</span><br><span class=\"line\">                     placeholder: Placeholder? = nil,</span><br><span class=\"line\">                     options: KingfisherOptionsInfo? = nil,</span><br><span class=\"line\">                     progressBlock: DownloadProgressBlock? = nil,</span><br><span class=\"line\">                     completionHandler: CompletionHandler? = nil) -&gt; RetrieveImageTask&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到，在这个方法里面，包括了ImageView的资源、默认图片、作者封装的枚举类、加载进度的回调以及完成结果。<br><code>@discardableResult</code>方法是为了取消不使用返回值的警告。<br>在这个方法里面(方法太长就不列举出来，捡主要的说)，</p>\n<ul>\n<li>首先判断参数合法性，当<code>resource</code>为<code>nil</code>时，展示默认图片。</li>\n<li>设置读取策略和启动动画。比如常见的一个问题：当用户头像改变但图片<code>URL</code>没有改变时，怎么去处理用户头像。一般有两种方法，一种是在缓存用户头像时保存当前时间。另一种就是设置读取策略，<code>KingfisherOptionsInfo</code>是一个枚举，设置它为<code>forceRefresh</code>时，可以强制刷新。</li>\n<li>从内存、文件或网络<code>URL</code>获取对应图片数据。</li>\n<li>获取图片完成后，在主线程刷新界面。</li>\n</ul>\n<p>我们查看一下这里面的参数：</p>\n<h3 id=\"Resource\"><a href=\"#Resource\" class=\"headerlink\" title=\"Resource\"></a>Resource</h3><p>Resource是一个协议，我们查看源码可以看到：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public protocol Resource &#123;</span><br><span class=\"line\">    var cacheKey: String &#123; get &#125;</span><br><span class=\"line\">    var downloadURL: URL &#123; get &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>cacheKey</code>是图片保存的key值，当<code>cacheKey</code>为<code>nil</code>时，取<code>downloadURL.absoluteString</code>(有兴趣的可以去了解一下<code>absoluteString</code>和<code>path</code>的区别)。<code>downloadURL</code>不言而喻，就是图片的<code>URL</code>。</p>\n<h3 id=\"Placeholder\"><a href=\"#Placeholder\" class=\"headerlink\" title=\"Placeholder\"></a>Placeholder</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public protocol Placeholder &#123;</span><br><span class=\"line\">    func add(to imageView: ImageView)</span><br><span class=\"line\">    func remove(from imageView: ImageView)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Placeholder</code>是一个协议，作者为它定义了<code>add</code>和<code>remove</code>方法，任何。默认实现了<code>Image</code>，如果想用<code>View</code>充当<code>Placeholder</code>，只要让<code>view</code>遵守协议即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extension Placeholder where Self: View&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"KingfisherOptionsInfo\"><a href=\"#KingfisherOptionsInfo\" class=\"headerlink\" title=\"KingfisherOptionsInfo\"></a>KingfisherOptionsInfo</h3><p><code>KingfisherOptionsInfo</code>是一个类型别名，点击查看<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]</span><br></pre></td></tr></table></figure></p>\n<p>所以我们关注的应该是<code>KingfisherOptionsInfoItem</code>是什么东西？那么它是什么呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum KingfisherOptionsInfoItem &#123;</span><br><span class=\"line\">    case targetCache(ImageCache)    //系统缓存位置。可以设置的属性</span><br><span class=\"line\">    case originalCache(ImageCache)    //系统缓存原始图像位置（只用于自己设置placeholder） </span><br><span class=\"line\">    case downloader(ImageDownloader)    //获取更改session属性，设置请求</span><br><span class=\"line\">    case transition(ImageTransition)    //自定义动画</span><br><span class=\"line\">    case downloadPriority(Float)    //下载优先级（0-1）</span><br><span class=\"line\">    case forceRefresh    //每次请求忽略缓存，直接下载</span><br><span class=\"line\">    case fromMemoryCacheOrRefresh    //先取缓存再去文件，再去下载</span><br><span class=\"line\">    case forceTransition    //强制移动</span><br><span class=\"line\">    case cacheMemoryOnly     //只从缓存读取，不读取本机沙盒图片</span><br><span class=\"line\">    case onlyFromCache    //从缓存、沙盒读取，没有也不下载网络，显示placeholder</span><br><span class=\"line\">    case backgroundDecode    //设置后，显示前在后台线程解码</span><br><span class=\"line\">    case callbackDispatchQueue(DispatchQueue?)    //自定义回调队列，默认主线程</span><br><span class=\"line\">    case scaleFactor(CGFloat)    //自定义图片data -&gt; Image缩放比例，不指定按屏幕2x\\3x缩放</span><br><span class=\"line\">    case preloadAllAnimationData    //预先加载data成图片缓存</span><br><span class=\"line\">    case requestModifier(ImageDownloadRequestModifier)    //改变请求</span><br><span class=\"line\">    case processor(ImageProcessor)    //自定义Data转图片样式</span><br><span class=\"line\">    case cacheSerializer(CacheSerializer)    //自定义缓存Data 转图像样式</span><br><span class=\"line\">    case imageModifier(ImageModifier)    //修改图像</span><br><span class=\"line\">    case keepCurrentImageWhileLoading     //包含这个意味着placeHolder设置无效，没有直接用默认</span><br><span class=\"line\">    case onlyLoadFirstFrame    //如果返回结果是.gif图，只取第一帧显示</span><br><span class=\"line\">    case cacheOriginalImage    //同时缓存原始图片和下载后的图片</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"DownloadProgressBlock\"><a href=\"#DownloadProgressBlock\" class=\"headerlink\" title=\"DownloadProgressBlock\"></a>DownloadProgressBlock</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -&gt; ())</span><br></pre></td></tr></table></figure>\n<p><code>DownloadProgressBlock</code>里面有<code>receivedSize</code>和<code>totalSize</code>，可以根据这两个参数得知图片下载了多少和图片多大，也可以计算图片的下载进度。</p>\n<h3 id=\"CompletionHandler\"><a href=\"#CompletionHandler\" class=\"headerlink\" title=\"CompletionHandler\"></a>CompletionHandler</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public typealias CompletionHandler = ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -&gt; ())</span><br></pre></td></tr></table></figure>\n<p><code>CompletionHandler</code>的回调里会有<code>image</code>、<code>error</code>、<code>cacheType</code>、<code>imageURL</code>四个参数。<code>image</code>、<code>error</code>、<code>imageURL</code>不做介绍，直接就能看出什么内容。<br>主要看一下<code>cacheType</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public enum CacheType &#123;</span><br><span class=\"line\">    case none, memory, disk</span><br><span class=\"line\">    public var cached: Bool &#123;</span><br><span class=\"line\">        switch self &#123;</span><br><span class=\"line\">        case .memory, .disk: return true</span><br><span class=\"line\">        case .none: return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>none</code>检索图片时，图片尚未缓存</li>\n<li><code>memory</code>图片缓存在内存中</li>\n<li><code>disk</code>图片缓存在磁盘中</li>\n</ul>\n<h2 id=\"检索图片\"><a href=\"#检索图片\" class=\"headerlink\" title=\"检索图片\"></a>检索图片</h2><p>OK，让我们继续看这些代码。在<code>setImage</code>方法中，从内存、文件或网络<code>URL</code>获取对应图片数据是怎么实现的呢？这里，我们可以查看<code>KingfisherManager.shared.retrieveImage</code>方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">public func retrieveImage(with resource: Resource,</span><br><span class=\"line\">    options: KingfisherOptionsInfo?,</span><br><span class=\"line\">    progressBlock: DownloadProgressBlock?,</span><br><span class=\"line\">    completionHandler: CompletionHandler?) -&gt; RetrieveImageTask</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    let task = RetrieveImageTask()</span><br><span class=\"line\">    let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo)</span><br><span class=\"line\">    if options.forceRefresh &#123;</span><br><span class=\"line\">        _ = downloadAndCacheImage(</span><br><span class=\"line\">            with: resource.downloadURL,</span><br><span class=\"line\">            forKey: resource.cacheKey,</span><br><span class=\"line\">            retrieveImageTask: task,</span><br><span class=\"line\">            progressBlock: progressBlock,</span><br><span class=\"line\">            completionHandler: completionHandler,</span><br><span class=\"line\">            options: options)</span><br><span class=\"line\">    &#125; else &#123;    </span><br><span class=\"line\">        tryToRetrieveImageFromCache(</span><br><span class=\"line\">            forKey: resource.cacheKey,</span><br><span class=\"line\">            with: resource.downloadURL, </span><br><span class=\"line\">            retrieveImageTask: task,</span><br><span class=\"line\">            progressBlock: progressBlock,</span><br><span class=\"line\">            completionHandler: completionHandler,</span><br><span class=\"line\">            options: options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return task</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，代码会通过<code>KingfisherOptionsInfo</code>进行判断是强制刷新，网络下载并执行缓存策略还是从内存或文件中获取对应的Image。</p>\n<h3 id=\"图片下载\"><a href=\"#图片下载\" class=\"headerlink\" title=\"图片下载\"></a>图片下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">func downloadAndCacheImage(with url: URL,</span><br><span class=\"line\">                         forKey key: String,</span><br><span class=\"line\">                  retrieveImageTask: RetrieveImageTask,</span><br><span class=\"line\">                      progressBlock: DownloadProgressBlock?,</span><br><span class=\"line\">                  completionHandler: CompletionHandler?,</span><br><span class=\"line\">                            options: KingfisherOptionsInfo) -&gt; RetrieveImageDownloadTask?&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>downloadAndCacheImage</code>方法中，会<code>return  downloader.downloadImage</code>方法，下载的主要逻辑在这里实现，对应的文件是<em>ImageDownloader.swift</em>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">open func downloadImage(with url: URL,</span><br><span class=\"line\">               retrieveImageTask: RetrieveImageTask? = nil,</span><br><span class=\"line\">                         options: KingfisherOptionsInfo? = nil,</span><br><span class=\"line\">                   progressBlock: ImageDownloaderProgressBlock? = nil,</span><br><span class=\"line\">               completionHandler: ImageDownloaderCompletionHandler? = nil) -&gt; RetrieveImageDownloadTask?&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>ImageDownloader.swift</code>文件中，主要参数：</p>\n<ul>\n<li><code>downloadTimeout</code> 超时时间，默认15秒</li>\n<li><code>trustedHosts</code> 信任的请求地址，和自己实现请求代理设置冲突，二选一</li>\n<li><code>sessionConfiguration</code> session配置设置</li>\n<li><code>requestsUsePipelining</code> 请求是否管道类型，是否按顺序下载，默认<code>false</code></li>\n<li><code>sessionHandler</code>单独设计出的一个<code>ImageDownloaderSessionHandler</code>，是为了解决之前出现的<a href=\"https://github.com/onevcat/Kingfisher/issues/235\" target=\"_blank\" rel=\"noopener\">内存泄漏</a></li>\n<li><code>delegate</code> 下载代理</li>\n<li><code>authenticationChallengeResponder</code> 信任请求代理，和trustedHosts冲突二选一</li>\n<li><code>fetchLoads</code> 下载完成每个URL可能有多个处理方式，优先取这里的</li>\n<li>此外还有三个<code>DispatchQueue</code>：<code>barrierQueue</code>、<code>processQueue</code>、<code>cancelQueue</code></li>\n</ul>\n<p>下载完成后，在<code>completionHandler</code>回调中处理图片，如果下载失败：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if let error = error, error.code == KingfisherError.notModified.rawValue &#123;</span><br><span class=\"line\">    //从缓存中读取，不需保存，直接返回</span><br><span class=\"line\">    targetCache.retrieveImage(forKey: key, options: options, completionHandler: &#123; (cacheImage, cacheType) -&gt; () in</span><br><span class=\"line\">        completionHandler?(cacheImage, nil, cacheType, url)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下载成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if let image = image, let originalData = originalData &#123;</span><br><span class=\"line\">    //存储图片</span><br><span class=\"line\">    targetCache.store(image,</span><br><span class=\"line\">                      original: originalData,</span><br><span class=\"line\">                      forKey: key,</span><br><span class=\"line\">                      processorIdentifier:options.processor.identifier,</span><br><span class=\"line\">                      cacheSerializer: options.cacheSerializer,</span><br><span class=\"line\">                      toDisk: !options.cacheMemoryOnly,</span><br><span class=\"line\">                      completionHandler: nil)</span><br><span class=\"line\">        if options.cacheOriginalImage &amp;&amp; options.processor != DefaultImageProcessor.default &#123;</span><br><span class=\"line\">            let originalCache = options.originalCache</span><br><span class=\"line\">            let defaultProcessor = DefaultImageProcessor.default</span><br><span class=\"line\">            if let originalImage = defaultProcessor.process(item: .data(originalData), options: options) &#123;</span><br><span class=\"line\">                originalCache.store(originalImage,</span><br><span class=\"line\">                        original: originalData,</span><br><span class=\"line\">                        forKey: key,</span><br><span class=\"line\">                        processorIdentifier: defaultProcessor.identifier,</span><br><span class=\"line\">                        cacheSerializer: options.cacheSerializer,</span><br><span class=\"line\">                        toDisk: !options.cacheMemoryOnly,</span><br><span class=\"line\">                        completionHandler: nil)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"存储图片\"><a href=\"#存储图片\" class=\"headerlink\" title=\"存储图片\"></a>存储图片</h4><p>我们先来看一下实现的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func store(_ image: Image,</span><br><span class=\"line\">                  original: Data? = nil,</span><br><span class=\"line\">                  forKey key: String,</span><br><span class=\"line\">                  processorIdentifier identifier: String = &quot;&quot;,</span><br><span class=\"line\">                  cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,</span><br><span class=\"line\">                  toDisk: Bool = true,</span><br><span class=\"line\">                  completionHandler: (() -&gt; Void)? = nil)&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码中<code>memoryCache</code>是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fileprivate let memoryCache = NSCache&lt;NSString, AnyObject&gt;()</span><br></pre></td></tr></table></figure></p>\n<p>可见图片存储首先是缓存在<code>NSCache</code>中，如果想存储在磁盘中(<code>if toDisk</code>)，利用串行队列异步的进行存储原图。</p>\n<h4 id=\"获取图片\"><a href=\"#获取图片\" class=\"headerlink\" title=\"获取图片\"></a>获取图片</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@discardableResult</span><br><span class=\"line\">open func retrieveImage(forKey key: String,</span><br><span class=\"line\">                           options: KingfisherOptionsInfo?,</span><br><span class=\"line\">                 completionHandler: ((Image?, CacheType) -&gt; ())?) -&gt; RetrieveImageDiskTask?&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先从内存中获取图片<code>if let image = self.retrieveImageInMemoryCache(forKey: key, options: options)</code></li>\n<li>如果没有，在根据条件判断是否从磁盘上获取<code>if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options)</code></li>\n</ul>\n<h4 id=\"删除图片\"><a href=\"#删除图片\" class=\"headerlink\" title=\"删除图片\"></a>删除图片</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func removeImage(forKey key: String,</span><br><span class=\"line\">                      processorIdentifier identifier: String = &quot;&quot;,</span><br><span class=\"line\">                      fromDisk: Bool = true,</span><br><span class=\"line\">                      completionHandler: (() -&gt; Void)? = nil)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc public func clearMemoryCache() &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func clearDiskCache(completion handler: (()-&gt;())? = nil) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open func cleanExpiredDiskCache(completion handler: (()-&gt;())? = nil) &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@objc public func backgroundCleanExpiredDiskCache() &#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，一些方法是通过通知的方法来实现：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 系统内存警告</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(clearMemoryCache), name: .UIApplicationDidReceiveMemoryWarning, object: nil)    </span><br><span class=\"line\">// 程序终止</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(cleanExpiredDiskCache), name: .UIApplicationWillTerminate, object: nil)</span><br><span class=\"line\">// 程序进入后台</span><br><span class=\"line\">NotificationCenter.default.addObserver(self, selector: #selector(backgroundCleanExpiredDiskCache), name: .UIApplicationDidEnterBackground, object: nil)</span><br></pre></td></tr></table></figure></p>\n<p>此外，还有一些属性要注意:</p>\n<ul>\n<li><code>maxMemoryCost</code>最大缓存量，在收到内存警告时会被清空。</li>\n<li><code>pathExtension</code>沙盒后续拼接文件夹名称</li>\n<li><code>maxCachePeriodInSecond</code>默认清除一周前的图片</li>\n<li><code>maxDiskCacheSize</code>沙盒最大存储量，为0，默认无限制</li>\n</ul>\n<p>以上就是对Kingfisher的简单描述，它有很多方法值得我们去借鉴，比如<code>@discardableResult</code>、<code>where</code>、<code>typealias</code>、<code>if case let</code>、善于利用<code>guard</code>、扩展协议等等。</p>\n"},{"title":"网络编程 - 概述","date":"2018-10-25T09:48:53.000Z","_content":"首先看一张经典的图：\n![网络七层、四层模型.png](https://upload-images.jianshu.io/upload_images/2855070-78758cae41145011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n说到网络编程一般都会说到OSI参考模型和TCP/IP模型，这篇文章主要从TCP/IP模型出发，谈谈我对网络编程的理解。\nTCP/IP模型分为四层，从下到上分别是网络接口层、网络层、传输层、应用层。越往下越靠近硬件，越往上越接近用户。每一层的分工不同，为了实现每一层的功能，制定了一些规则，这些规则就是**协议**。\n## 网络接口层\n### 以太网协议\n以太网协议确定了一系列的约定，让一股又一股的电流能够传递信息：0 或者 1。它规定一组信号组成一个数据包“帧”，每一帧有两部分组成：标头（Head）和数据（Data)。\n\n![以太网.jpg](https://upload-images.jianshu.io/upload_images/2855070-3b70a3bb7412e92d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- “标头”包括目的地址、源地址、类型，长度固定为18字节。\n- “数据”就是数据包的具体内容，最短为46字节，最长为1500字节，如果超出这个长度，就必须分割成多个帧进行发送。\n\n### MAC地址\n在“标头”里，我们如何标识目的地址和源地址？这时候就需要MAC地址了。\n以太网规定，连入网络的所有设备，都必须具有\"网卡\"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每一张网卡都有唯一的MAC地址，由厂商向 IEEE 购买，再预先烧录进芯片里，每个有线网卡、每台路由器、每个无线网卡甚至每个蓝牙芯片都有自己的唯一 MAC 地址。\nMAC地址长度是48个二进制位，通常用12个十六进制数表示，比如：AA:BB:CC:DD:EE:FF。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。\n### 类型\n类型具有两个意义，当这两个字节的值小于1518时，那么它就代表其后数据字段的长度；如果这两个字节的值大于1518，则表示该以太网帧中的数据属于哪个上层协议（例如0x800，代表IP数据包；0x806，代表ARP数据包等）。\n### 广播\n我们怎么把数据发送给对方呢？\n1. 我们要知道对方的地址\n2. 我们知道地址后把数据包准确的发送给对方\n\n怎么知道对方的MAC地址呢？这里通过ARP协议。这个放在IP协议里面说。那怎么发送数据呢？\n举个例子：A同学到一个班级里面想找B同学，但是不知道他是谁。于是他就在那个班级里面喊一句：B同学你们喊你回家吃饭。然后B同学就接收到这个信息了，B同学对此就可以做出回应。\n![timg.jpeg](https://upload-images.jianshu.io/upload_images/2855070-bb9d05c40e1c3a41.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n翻译一下就是：A计算机要向B计算发送数据包，但是在这个网络里还有C、D、E、F四台计算机。A发送数据包后，B、C、D、E、F都会收到这个包，他们读取这个包的“标头”，找到接收者的MAC地址，然后和自己的对比。如果相同，就做处理。如果不同，就弃包。这种发送方式就叫“广播”。至此，就可以在多台计算机之间传递信息了。\n## 网络层\n既然我们可以在多台计算机之间传递信息了，为什么还有网络层呢？\n我们知道，计算机通过“广播”的方式传递信息，它只局限于发送者所在的子网内，我们不能保证发送者和接收者都在一个子网内（如果没有这种子网设计，全世界的计算机都能接收到信息，这将是一场灾难）。\n所以，我们采取了一种方法：当发送者和接收者都在一个子网内，采取“广播”方式发送，不在一个子网内，采取“路由”方式发送。\n这就导致了\"网络层\"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做\"网络地址\"，简称\"网址\"。从此每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。通过网络地址，我们可以得出计算机所在的子网络。\n### IP协议\nIP协议：用来规定网络地址的协议。目前广泛采用的IP协议是第四版，简称IPv4，它有32个二进制组成（即32位）。目前IPv6正在推广，它是128位。\n![IP协议.jpg](https://upload-images.jianshu.io/upload_images/2855070-f8bca9920a27fb46.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 首部主要包括总长度、源地址、目的地址等信息。\n1.总长度界定了本次 ip 报文的长度，便于读取有效数据\n2.源地址指本次 ip 报文是由那个 ip 地址发出的\n3.目的地址指本次 ip 报文需要发给哪一台设备\n- 数据部分是IP数据包的具体内容。\n- 以太网数据包的数据部分就是整个IP数据\n\n在介绍以太网帧的时候，以太网帧也有数据部分，便是IP数据包。\nIP数据包的\"标头\"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的\"数据\"部分，最长为65,515字节。前面说过，以太网数据包的\"数据\"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。\n### ARP协议\nARP协议，即地址解析协议(Address Resolution Protoco)，它是通过IP地址获取MAC地址的协议。\n举个例子：\nA的IP地址是192.168.1.1，MAC地址是0A-11-22-33-44-01\nB的IP地址是192.168.1.2，MAC地址是0A-11-22-33-44-02\n当A要与B通信时，ARP协议将B的IP地址解析成MAC地址。流程如下：\n1. A确定自己要寻找的是192.168.1.2的IP地址，在本地ARP缓存中检查B的匹配MAC地址，如果找到，A向B进行IP通信。\n2. 如果A没有在ARP缓存中找到B的MAC地址，它将询问192.168.1.2的MAC地址，从而将ARP请求帧广播到本地网络上的所有主机。本地网络上的每台主机都会将收到ARP请求并与自己的IP地址匹配。如果发现请求的IP地址和自己的IP地址不一样，它将放弃ARP请求。\n3. B收到ARP请求后，发现请求的IP地址与自己的IP地址一样，将A的IP地址和MAC地址映射添加到本地ARP缓存中。\n4. B将包含MAC地址的ARP回复消息发送给A。\n5. A收到B的ARP回复消息后，将B的IP和MAC地址映射更新ARP缓存（ARP缓存有生命期，当生命期接收后，再次重复上面过程）。A确定B的MAC地址后，进行IP通信。\n![ARP.png](https://upload-images.jianshu.io/upload_images/2855070-5736df1c662b58e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n但是，ARP 只能用于 IPv4 ，不能用于 IPv6。在IPv6 中可以用 ICMPv6 替代 ARP。\n\n\n## 传输层\n有了MAC地址和IP地址，不管我们在不在一个子网内，我们都可以建立通信了。\n但是，我们怎么知道对方发来的数据包，是供哪个程序使用呢？比如说我现在一边浏览网页，一边聊天。我接收到的数据包，是网页的内容？还是聊天内容？\n这个时候我们就需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做\"端口\"，它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。\n传输层的功能，就是建立\"端口到端口\"的通信。相比之下，\"网络层\"的功能是建立\"主机到主机\"的通信。\n\n### TCP协议\n传输层不止TCP协议，还有UDP协议。这里我们简单介绍一下TCP协议，来了解传输层的做了什么。\n![TCP.jpg](https://upload-images.jianshu.io/upload_images/2855070-6b909534f1a54995.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nTPC协议里包含了首部和数据部分。\n- 首部最重要的是源端口和目的端口。\n- 数据部分就是具体的内容。\n- IP数据包的数据部分就是整个TCP数据。\n\n## 应用层\n应用层是在用户空间实现的，负责处理众多业务逻辑，如文件传输、网络管理。它规定了应用程序的数据格式。\n![all.jpg](https://upload-images.jianshu.io/upload_images/2855070-276d7c74a3257052.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n至此，我们就大概了解到TCP/IP模型，四层做了什么。如有错误之处，还望各位指出。\n\n参考：\n[软件工程师需要了解的网络知识系列](https://lvwenhan.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/485.html)\n[网络编程懒人入门](http://www.52im.net/thread-1095-1-1.html)\n\n\n\n\n\n","source":"_posts/网络编程-概述.md","raw":"---\ntitle: 网络编程 - 概述\ndate: 2018-10-25 17:48:53\ntags: 网络\n---\n首先看一张经典的图：\n![网络七层、四层模型.png](https://upload-images.jianshu.io/upload_images/2855070-78758cae41145011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n说到网络编程一般都会说到OSI参考模型和TCP/IP模型，这篇文章主要从TCP/IP模型出发，谈谈我对网络编程的理解。\nTCP/IP模型分为四层，从下到上分别是网络接口层、网络层、传输层、应用层。越往下越靠近硬件，越往上越接近用户。每一层的分工不同，为了实现每一层的功能，制定了一些规则，这些规则就是**协议**。\n## 网络接口层\n### 以太网协议\n以太网协议确定了一系列的约定，让一股又一股的电流能够传递信息：0 或者 1。它规定一组信号组成一个数据包“帧”，每一帧有两部分组成：标头（Head）和数据（Data)。\n\n![以太网.jpg](https://upload-images.jianshu.io/upload_images/2855070-3b70a3bb7412e92d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- “标头”包括目的地址、源地址、类型，长度固定为18字节。\n- “数据”就是数据包的具体内容，最短为46字节，最长为1500字节，如果超出这个长度，就必须分割成多个帧进行发送。\n\n### MAC地址\n在“标头”里，我们如何标识目的地址和源地址？这时候就需要MAC地址了。\n以太网规定，连入网络的所有设备，都必须具有\"网卡\"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每一张网卡都有唯一的MAC地址，由厂商向 IEEE 购买，再预先烧录进芯片里，每个有线网卡、每台路由器、每个无线网卡甚至每个蓝牙芯片都有自己的唯一 MAC 地址。\nMAC地址长度是48个二进制位，通常用12个十六进制数表示，比如：AA:BB:CC:DD:EE:FF。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。\n### 类型\n类型具有两个意义，当这两个字节的值小于1518时，那么它就代表其后数据字段的长度；如果这两个字节的值大于1518，则表示该以太网帧中的数据属于哪个上层协议（例如0x800，代表IP数据包；0x806，代表ARP数据包等）。\n### 广播\n我们怎么把数据发送给对方呢？\n1. 我们要知道对方的地址\n2. 我们知道地址后把数据包准确的发送给对方\n\n怎么知道对方的MAC地址呢？这里通过ARP协议。这个放在IP协议里面说。那怎么发送数据呢？\n举个例子：A同学到一个班级里面想找B同学，但是不知道他是谁。于是他就在那个班级里面喊一句：B同学你们喊你回家吃饭。然后B同学就接收到这个信息了，B同学对此就可以做出回应。\n![timg.jpeg](https://upload-images.jianshu.io/upload_images/2855070-bb9d05c40e1c3a41.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n翻译一下就是：A计算机要向B计算发送数据包，但是在这个网络里还有C、D、E、F四台计算机。A发送数据包后，B、C、D、E、F都会收到这个包，他们读取这个包的“标头”，找到接收者的MAC地址，然后和自己的对比。如果相同，就做处理。如果不同，就弃包。这种发送方式就叫“广播”。至此，就可以在多台计算机之间传递信息了。\n## 网络层\n既然我们可以在多台计算机之间传递信息了，为什么还有网络层呢？\n我们知道，计算机通过“广播”的方式传递信息，它只局限于发送者所在的子网内，我们不能保证发送者和接收者都在一个子网内（如果没有这种子网设计，全世界的计算机都能接收到信息，这将是一场灾难）。\n所以，我们采取了一种方法：当发送者和接收者都在一个子网内，采取“广播”方式发送，不在一个子网内，采取“路由”方式发送。\n这就导致了\"网络层\"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做\"网络地址\"，简称\"网址\"。从此每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。通过网络地址，我们可以得出计算机所在的子网络。\n### IP协议\nIP协议：用来规定网络地址的协议。目前广泛采用的IP协议是第四版，简称IPv4，它有32个二进制组成（即32位）。目前IPv6正在推广，它是128位。\n![IP协议.jpg](https://upload-images.jianshu.io/upload_images/2855070-f8bca9920a27fb46.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 首部主要包括总长度、源地址、目的地址等信息。\n1.总长度界定了本次 ip 报文的长度，便于读取有效数据\n2.源地址指本次 ip 报文是由那个 ip 地址发出的\n3.目的地址指本次 ip 报文需要发给哪一台设备\n- 数据部分是IP数据包的具体内容。\n- 以太网数据包的数据部分就是整个IP数据\n\n在介绍以太网帧的时候，以太网帧也有数据部分，便是IP数据包。\nIP数据包的\"标头\"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的\"数据\"部分，最长为65,515字节。前面说过，以太网数据包的\"数据\"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。\n### ARP协议\nARP协议，即地址解析协议(Address Resolution Protoco)，它是通过IP地址获取MAC地址的协议。\n举个例子：\nA的IP地址是192.168.1.1，MAC地址是0A-11-22-33-44-01\nB的IP地址是192.168.1.2，MAC地址是0A-11-22-33-44-02\n当A要与B通信时，ARP协议将B的IP地址解析成MAC地址。流程如下：\n1. A确定自己要寻找的是192.168.1.2的IP地址，在本地ARP缓存中检查B的匹配MAC地址，如果找到，A向B进行IP通信。\n2. 如果A没有在ARP缓存中找到B的MAC地址，它将询问192.168.1.2的MAC地址，从而将ARP请求帧广播到本地网络上的所有主机。本地网络上的每台主机都会将收到ARP请求并与自己的IP地址匹配。如果发现请求的IP地址和自己的IP地址不一样，它将放弃ARP请求。\n3. B收到ARP请求后，发现请求的IP地址与自己的IP地址一样，将A的IP地址和MAC地址映射添加到本地ARP缓存中。\n4. B将包含MAC地址的ARP回复消息发送给A。\n5. A收到B的ARP回复消息后，将B的IP和MAC地址映射更新ARP缓存（ARP缓存有生命期，当生命期接收后，再次重复上面过程）。A确定B的MAC地址后，进行IP通信。\n![ARP.png](https://upload-images.jianshu.io/upload_images/2855070-5736df1c662b58e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n但是，ARP 只能用于 IPv4 ，不能用于 IPv6。在IPv6 中可以用 ICMPv6 替代 ARP。\n\n\n## 传输层\n有了MAC地址和IP地址，不管我们在不在一个子网内，我们都可以建立通信了。\n但是，我们怎么知道对方发来的数据包，是供哪个程序使用呢？比如说我现在一边浏览网页，一边聊天。我接收到的数据包，是网页的内容？还是聊天内容？\n这个时候我们就需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做\"端口\"，它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。\n传输层的功能，就是建立\"端口到端口\"的通信。相比之下，\"网络层\"的功能是建立\"主机到主机\"的通信。\n\n### TCP协议\n传输层不止TCP协议，还有UDP协议。这里我们简单介绍一下TCP协议，来了解传输层的做了什么。\n![TCP.jpg](https://upload-images.jianshu.io/upload_images/2855070-6b909534f1a54995.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nTPC协议里包含了首部和数据部分。\n- 首部最重要的是源端口和目的端口。\n- 数据部分就是具体的内容。\n- IP数据包的数据部分就是整个TCP数据。\n\n## 应用层\n应用层是在用户空间实现的，负责处理众多业务逻辑，如文件传输、网络管理。它规定了应用程序的数据格式。\n![all.jpg](https://upload-images.jianshu.io/upload_images/2855070-276d7c74a3257052.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n至此，我们就大概了解到TCP/IP模型，四层做了什么。如有错误之处，还望各位指出。\n\n参考：\n[软件工程师需要了解的网络知识系列](https://lvwenhan.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/485.html)\n[网络编程懒人入门](http://www.52im.net/thread-1095-1-1.html)\n\n\n\n\n\n","slug":"网络编程-概述","published":1,"updated":"2018-11-05T06:53:11.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxyb000w2ycwqx2i23k5","content":"<p>首先看一张经典的图：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-78758cae41145011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网络七层、四层模型.png\"><br>说到网络编程一般都会说到OSI参考模型和TCP/IP模型，这篇文章主要从TCP/IP模型出发，谈谈我对网络编程的理解。<br>TCP/IP模型分为四层，从下到上分别是网络接口层、网络层、传输层、应用层。越往下越靠近硬件，越往上越接近用户。每一层的分工不同，为了实现每一层的功能，制定了一些规则，这些规则就是<strong>协议</strong>。</p>\n<h2 id=\"网络接口层\"><a href=\"#网络接口层\" class=\"headerlink\" title=\"网络接口层\"></a>网络接口层</h2><h3 id=\"以太网协议\"><a href=\"#以太网协议\" class=\"headerlink\" title=\"以太网协议\"></a>以太网协议</h3><p>以太网协议确定了一系列的约定，让一股又一股的电流能够传递信息：0 或者 1。它规定一组信号组成一个数据包“帧”，每一帧有两部分组成：标头（Head）和数据（Data)。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-3b70a3bb7412e92d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"以太网.jpg\"></p>\n<ul>\n<li>“标头”包括目的地址、源地址、类型，长度固定为18字节。</li>\n<li>“数据”就是数据包的具体内容，最短为46字节，最长为1500字节，如果超出这个长度，就必须分割成多个帧进行发送。</li>\n</ul>\n<h3 id=\"MAC地址\"><a href=\"#MAC地址\" class=\"headerlink\" title=\"MAC地址\"></a>MAC地址</h3><p>在“标头”里，我们如何标识目的地址和源地址？这时候就需要MAC地址了。<br>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每一张网卡都有唯一的MAC地址，由厂商向 IEEE 购买，再预先烧录进芯片里，每个有线网卡、每台路由器、每个无线网卡甚至每个蓝牙芯片都有自己的唯一 MAC 地址。<br>MAC地址长度是48个二进制位，通常用12个十六进制数表示，比如：AA:BB:CC:DD:EE:FF。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>类型具有两个意义，当这两个字节的值小于1518时，那么它就代表其后数据字段的长度；如果这两个字节的值大于1518，则表示该以太网帧中的数据属于哪个上层协议（例如0x800，代表IP数据包；0x806，代表ARP数据包等）。</p>\n<h3 id=\"广播\"><a href=\"#广播\" class=\"headerlink\" title=\"广播\"></a>广播</h3><p>我们怎么把数据发送给对方呢？</p>\n<ol>\n<li>我们要知道对方的地址</li>\n<li>我们知道地址后把数据包准确的发送给对方</li>\n</ol>\n<p>怎么知道对方的MAC地址呢？这里通过ARP协议。这个放在IP协议里面说。那怎么发送数据呢？<br>举个例子：A同学到一个班级里面想找B同学，但是不知道他是谁。于是他就在那个班级里面喊一句：B同学你们喊你回家吃饭。然后B同学就接收到这个信息了，B同学对此就可以做出回应。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bb9d05c40e1c3a41.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timg.jpeg\"><br>翻译一下就是：A计算机要向B计算发送数据包，但是在这个网络里还有C、D、E、F四台计算机。A发送数据包后，B、C、D、E、F都会收到这个包，他们读取这个包的“标头”，找到接收者的MAC地址，然后和自己的对比。如果相同，就做处理。如果不同，就弃包。这种发送方式就叫“广播”。至此，就可以在多台计算机之间传递信息了。</p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><p>既然我们可以在多台计算机之间传递信息了，为什么还有网络层呢？<br>我们知道，计算机通过“广播”的方式传递信息，它只局限于发送者所在的子网内，我们不能保证发送者和接收者都在一个子网内（如果没有这种子网设计，全世界的计算机都能接收到信息，这将是一场灾难）。<br>所以，我们采取了一种方法：当发送者和接收者都在一个子网内，采取“广播”方式发送，不在一个子网内，采取“路由”方式发送。<br>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。从此每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。通过网络地址，我们可以得出计算机所在的子网络。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>IP协议：用来规定网络地址的协议。目前广泛采用的IP协议是第四版，简称IPv4，它有32个二进制组成（即32位）。目前IPv6正在推广，它是128位。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-f8bca9920a27fb46.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"IP协议.jpg\"></p>\n<ul>\n<li>首部主要包括总长度、源地址、目的地址等信息。<br>1.总长度界定了本次 ip 报文的长度，便于读取有效数据<br>2.源地址指本次 ip 报文是由那个 ip 地址发出的<br>3.目的地址指本次 ip 报文需要发给哪一台设备</li>\n<li>数据部分是IP数据包的具体内容。</li>\n<li>以太网数据包的数据部分就是整个IP数据</li>\n</ul>\n<p>在介绍以太网帧的时候，以太网帧也有数据部分，便是IP数据包。<br>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>\n<h3 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h3><p>ARP协议，即地址解析协议(Address Resolution Protoco)，它是通过IP地址获取MAC地址的协议。<br>举个例子：<br>A的IP地址是192.168.1.1，MAC地址是0A-11-22-33-44-01<br>B的IP地址是192.168.1.2，MAC地址是0A-11-22-33-44-02<br>当A要与B通信时，ARP协议将B的IP地址解析成MAC地址。流程如下：</p>\n<ol>\n<li>A确定自己要寻找的是192.168.1.2的IP地址，在本地ARP缓存中检查B的匹配MAC地址，如果找到，A向B进行IP通信。</li>\n<li>如果A没有在ARP缓存中找到B的MAC地址，它将询问192.168.1.2的MAC地址，从而将ARP请求帧广播到本地网络上的所有主机。本地网络上的每台主机都会将收到ARP请求并与自己的IP地址匹配。如果发现请求的IP地址和自己的IP地址不一样，它将放弃ARP请求。</li>\n<li>B收到ARP请求后，发现请求的IP地址与自己的IP地址一样，将A的IP地址和MAC地址映射添加到本地ARP缓存中。</li>\n<li>B将包含MAC地址的ARP回复消息发送给A。</li>\n<li>A收到B的ARP回复消息后，将B的IP和MAC地址映射更新ARP缓存（ARP缓存有生命期，当生命期接收后，再次重复上面过程）。A确定B的MAC地址后，进行IP通信。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-5736df1c662b58e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ARP.png\"><br>但是，ARP 只能用于 IPv4 ，不能用于 IPv6。在IPv6 中可以用 ICMPv6 替代 ARP。</li>\n</ol>\n<h2 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><p>有了MAC地址和IP地址，不管我们在不在一个子网内，我们都可以建立通信了。<br>但是，我们怎么知道对方发来的数据包，是供哪个程序使用呢？比如说我现在一边浏览网页，一边聊天。我接收到的数据包，是网页的内容？还是聊天内容？<br>这个时候我们就需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”，它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。<br>传输层的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。</p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>传输层不止TCP协议，还有UDP协议。这里我们简单介绍一下TCP协议，来了解传输层的做了什么。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-6b909534f1a54995.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP.jpg\"><br>TPC协议里包含了首部和数据部分。</p>\n<ul>\n<li>首部最重要的是源端口和目的端口。</li>\n<li>数据部分就是具体的内容。</li>\n<li>IP数据包的数据部分就是整个TCP数据。</li>\n</ul>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><p>应用层是在用户空间实现的，负责处理众多业务逻辑，如文件传输、网络管理。它规定了应用程序的数据格式。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-276d7c74a3257052.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"all.jpg\"></p>\n<p>至此，我们就大概了解到TCP/IP模型，四层做了什么。如有错误之处，还望各位指出。</p>\n<p>参考：<br><a href=\"https://lvwenhan.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/485.html\" target=\"_blank\" rel=\"noopener\">软件工程师需要了解的网络知识系列</a><br><a href=\"http://www.52im.net/thread-1095-1-1.html\" target=\"_blank\" rel=\"noopener\">网络编程懒人入门</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先看一张经典的图：<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-78758cae41145011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网络七层、四层模型.png\"><br>说到网络编程一般都会说到OSI参考模型和TCP/IP模型，这篇文章主要从TCP/IP模型出发，谈谈我对网络编程的理解。<br>TCP/IP模型分为四层，从下到上分别是网络接口层、网络层、传输层、应用层。越往下越靠近硬件，越往上越接近用户。每一层的分工不同，为了实现每一层的功能，制定了一些规则，这些规则就是<strong>协议</strong>。</p>\n<h2 id=\"网络接口层\"><a href=\"#网络接口层\" class=\"headerlink\" title=\"网络接口层\"></a>网络接口层</h2><h3 id=\"以太网协议\"><a href=\"#以太网协议\" class=\"headerlink\" title=\"以太网协议\"></a>以太网协议</h3><p>以太网协议确定了一系列的约定，让一股又一股的电流能够传递信息：0 或者 1。它规定一组信号组成一个数据包“帧”，每一帧有两部分组成：标头（Head）和数据（Data)。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-3b70a3bb7412e92d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"以太网.jpg\"></p>\n<ul>\n<li>“标头”包括目的地址、源地址、类型，长度固定为18字节。</li>\n<li>“数据”就是数据包的具体内容，最短为46字节，最长为1500字节，如果超出这个长度，就必须分割成多个帧进行发送。</li>\n</ul>\n<h3 id=\"MAC地址\"><a href=\"#MAC地址\" class=\"headerlink\" title=\"MAC地址\"></a>MAC地址</h3><p>在“标头”里，我们如何标识目的地址和源地址？这时候就需要MAC地址了。<br>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。每一张网卡都有唯一的MAC地址，由厂商向 IEEE 购买，再预先烧录进芯片里，每个有线网卡、每台路由器、每个无线网卡甚至每个蓝牙芯片都有自己的唯一 MAC 地址。<br>MAC地址长度是48个二进制位，通常用12个十六进制数表示，比如：AA:BB:CC:DD:EE:FF。前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>\n<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><p>类型具有两个意义，当这两个字节的值小于1518时，那么它就代表其后数据字段的长度；如果这两个字节的值大于1518，则表示该以太网帧中的数据属于哪个上层协议（例如0x800，代表IP数据包；0x806，代表ARP数据包等）。</p>\n<h3 id=\"广播\"><a href=\"#广播\" class=\"headerlink\" title=\"广播\"></a>广播</h3><p>我们怎么把数据发送给对方呢？</p>\n<ol>\n<li>我们要知道对方的地址</li>\n<li>我们知道地址后把数据包准确的发送给对方</li>\n</ol>\n<p>怎么知道对方的MAC地址呢？这里通过ARP协议。这个放在IP协议里面说。那怎么发送数据呢？<br>举个例子：A同学到一个班级里面想找B同学，但是不知道他是谁。于是他就在那个班级里面喊一句：B同学你们喊你回家吃饭。然后B同学就接收到这个信息了，B同学对此就可以做出回应。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bb9d05c40e1c3a41.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"timg.jpeg\"><br>翻译一下就是：A计算机要向B计算发送数据包，但是在这个网络里还有C、D、E、F四台计算机。A发送数据包后，B、C、D、E、F都会收到这个包，他们读取这个包的“标头”，找到接收者的MAC地址，然后和自己的对比。如果相同，就做处理。如果不同，就弃包。这种发送方式就叫“广播”。至此，就可以在多台计算机之间传递信息了。</p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><p>既然我们可以在多台计算机之间传递信息了，为什么还有网络层呢？<br>我们知道，计算机通过“广播”的方式传递信息，它只局限于发送者所在的子网内，我们不能保证发送者和接收者都在一个子网内（如果没有这种子网设计，全世界的计算机都能接收到信息，这将是一场灾难）。<br>所以，我们采取了一种方法：当发送者和接收者都在一个子网内，采取“广播”方式发送，不在一个子网内，采取“路由”方式发送。<br>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。从此每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。通过网络地址，我们可以得出计算机所在的子网络。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>IP协议：用来规定网络地址的协议。目前广泛采用的IP协议是第四版，简称IPv4，它有32个二进制组成（即32位）。目前IPv6正在推广，它是128位。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-f8bca9920a27fb46.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"IP协议.jpg\"></p>\n<ul>\n<li>首部主要包括总长度、源地址、目的地址等信息。<br>1.总长度界定了本次 ip 报文的长度，便于读取有效数据<br>2.源地址指本次 ip 报文是由那个 ip 地址发出的<br>3.目的地址指本次 ip 报文需要发给哪一台设备</li>\n<li>数据部分是IP数据包的具体内容。</li>\n<li>以太网数据包的数据部分就是整个IP数据</li>\n</ul>\n<p>在介绍以太网帧的时候，以太网帧也有数据部分，便是IP数据包。<br>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>\n<h3 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h3><p>ARP协议，即地址解析协议(Address Resolution Protoco)，它是通过IP地址获取MAC地址的协议。<br>举个例子：<br>A的IP地址是192.168.1.1，MAC地址是0A-11-22-33-44-01<br>B的IP地址是192.168.1.2，MAC地址是0A-11-22-33-44-02<br>当A要与B通信时，ARP协议将B的IP地址解析成MAC地址。流程如下：</p>\n<ol>\n<li>A确定自己要寻找的是192.168.1.2的IP地址，在本地ARP缓存中检查B的匹配MAC地址，如果找到，A向B进行IP通信。</li>\n<li>如果A没有在ARP缓存中找到B的MAC地址，它将询问192.168.1.2的MAC地址，从而将ARP请求帧广播到本地网络上的所有主机。本地网络上的每台主机都会将收到ARP请求并与自己的IP地址匹配。如果发现请求的IP地址和自己的IP地址不一样，它将放弃ARP请求。</li>\n<li>B收到ARP请求后，发现请求的IP地址与自己的IP地址一样，将A的IP地址和MAC地址映射添加到本地ARP缓存中。</li>\n<li>B将包含MAC地址的ARP回复消息发送给A。</li>\n<li>A收到B的ARP回复消息后，将B的IP和MAC地址映射更新ARP缓存（ARP缓存有生命期，当生命期接收后，再次重复上面过程）。A确定B的MAC地址后，进行IP通信。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-5736df1c662b58e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ARP.png\"><br>但是，ARP 只能用于 IPv4 ，不能用于 IPv6。在IPv6 中可以用 ICMPv6 替代 ARP。</li>\n</ol>\n<h2 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><p>有了MAC地址和IP地址，不管我们在不在一个子网内，我们都可以建立通信了。<br>但是，我们怎么知道对方发来的数据包，是供哪个程序使用呢？比如说我现在一边浏览网页，一边聊天。我接收到的数据包，是网页的内容？还是聊天内容？<br>这个时候我们就需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”，它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。<br>传输层的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。</p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>传输层不止TCP协议，还有UDP协议。这里我们简单介绍一下TCP协议，来了解传输层的做了什么。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-6b909534f1a54995.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP.jpg\"><br>TPC协议里包含了首部和数据部分。</p>\n<ul>\n<li>首部最重要的是源端口和目的端口。</li>\n<li>数据部分就是具体的内容。</li>\n<li>IP数据包的数据部分就是整个TCP数据。</li>\n</ul>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><p>应用层是在用户空间实现的，负责处理众多业务逻辑，如文件传输、网络管理。它规定了应用程序的数据格式。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-276d7c74a3257052.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"all.jpg\"></p>\n<p>至此，我们就大概了解到TCP/IP模型，四层做了什么。如有错误之处，还望各位指出。</p>\n<p>参考：<br><a href=\"https://lvwenhan.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/485.html\" target=\"_blank\" rel=\"noopener\">软件工程师需要了解的网络知识系列</a><br><a href=\"http://www.52im.net/thread-1095-1-1.html\" target=\"_blank\" rel=\"noopener\">网络编程懒人入门</a></p>\n"},{"title":"网络编程 - TCP/IP协议","date":"2018-10-27T02:03:15.000Z","_content":"之前简单的通过[TCP/IP模型](https://darren1192.github.io/2018/10/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E6%A6%82%E8%BF%B0/)介绍了网络编程，这篇主要介绍TCP/IP协议。\nTCP/IP协议其实是一个协议簇，其中比较重要的有SLIP协议、PPP协议、IP协议、ICMP协议、ARP协议、TCP协议、UDP协议、FTP协议、DNS协议、SMTP协议等。这里我们主要介绍几个常见的协议。\n## IP协议\nIP协议(Internet Protocol)，又叫网际协议，它解决了多个局域网互通的问题，提供不可靠、无连接的数据报传送服务。\n- 不可靠：它不能保证IP数据报能成功到达目的地。IP协议会尽最大的努力，把数据包发送到目的地，但如果期间出现问题，则发送失败。比如路由器暂时用完了缓冲区。\n- 无连接：IP并不维护任何关于后续数据报的状态信息，可以不按发送顺序接收。比如先后发送A、B两条数据报。A、B是相互独立的，可能会有不同的路由选择，选择不同的路线，所以并不能判定A、B谁先到达。\n\n### IP首部\n![IP首部.png](https://upload-images.jianshu.io/upload_images/2855070-a0f12175f3f246dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n现在是看图说话时间（捡重要的说）。\n- 普通的IP首部长为20个字节，除非含有选项字段。最高位在左面，记0bit，最低位在右面，记31bit。传输次序是**大端序（Big Endian）**。先传0～7bit，其次8～15 bit，然后16～23 bit，最后是24~31 bit。\n关于大端序小端序可以看[这篇](https://blog.csdn.net/lisonglisonglisong/article/details/45421091)\n- 目前通用的版本号是4，所以也叫IPv4。\n- 首部长度指的是首部占32 bit字的数目，包括任何选项。\n-  总长度字段是指整个IP数据报的长度，最长可达65535字节。\n- 标识字段唯一地标识主机发送的每一份数据报。\n- 生存时间字段设置了数据报可以经过的最多路由器数，初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。\n- 通过首部中的协议确定接收数据的上层协议（TCP/UDP/ICMP等）。\n- 首部检验和字段是根据IP首部计算的[检验和](https://blog.csdn.net/dongfei2033/article/details/75172292)码。它可以判断首部在传输过程中有没有发生任何差错。如果发生差错就丢弃收到的数据报。\n- 源IP地址和目的IP地址在[上篇](https://www.jianshu.com/p/37122c626436)提到。\n- 选项，是数据报中的一个可变长的可选信息。\n\n## ICMP协议\nICMP(nternet Control Message Protocol)，Internet控制报文协议，从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。\n## TCP协议\nTCP协议(Transmission Control Protocol)，传输控制协议，位于传输层。它提供一种面向连接的、可靠的字节流服务。\n- 面向连接：两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。广播和多播不能用于TCP。\n- 可靠的：TCP协议将会通过以下几个方法提供可靠性\n1. 应用数据被分割成TCP认为最适合发送的数据块。\n2. 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。\n3. 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。\n4. TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。\n5. TCP数据是在IP数据包中传输，如果IP数据丢失，那么TCP数据也会丢失，进行重发。如有必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。\n6. TCP的接收端会丢弃重复的数据。\n7. TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。\n\n其实我觉得[Halfrost](https://github.com/halfrost)总结的很好：TCP就是通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。\n### TCP首部\n![TCP首部.png](https://upload-images.jianshu.io/upload_images/2855070-d2eb8abdcf1cf9bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果不计任选字段，它通常是20个字节。\n依然进入看图说话环节：\n- 每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。\n- 序号，即Sequence Number，用来解决网络包乱序问题。\n- 确认序号，即Acknowledgement Number，就是ACK——用于确认收到，用来解决不丢包的问题。\n- 首部长度，或叫数据偏移，该字段表示 TCP 所传输的数据部分应该从 TCP 包的哪个位开始计算。\n- 保留，该字段主要是为了以后扩展使用。\n- 窗口控制，TCP的流量控制由连接的每一端通过声明的窗口大小来提供。\n- 检验和，它覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。\n- 紧急指针，只有当URG标志置1时紧急指针才有效\n\n### TCP三次握手、四次挥手\n#### 三次握手\n![TCP三次握手.png](https://upload-images.jianshu.io/upload_images/2855070-bf96793d9b37dcc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n简单来说过程就是这样的：\n1. 客户端首先向服务端发送一个SYN包和一个随机序列号 J\n2. 服务端收到后会回复客户端一个 SYN-ACK 包以及一个确认号（用于确认收到 SYN）J+1，同时再发送一个随机序列号 K\n3. 客户端收到后会发送一个 ACK 包和确定号 K+1 给服务端\n\n我们看一个例子：\n```\n% sudo tcpdump -c 3 -i en3 -nS host 23.63.125.15\n18:31:29.140787 IP 10.0.1.6.52181 > 23.63.125.15.80: Flags [S], seq 1721092979, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol], length 0\n18:31:29.150866 IP 23.63.125.15.80 > 10.0.1.6.52181: Flags [S.], seq 673593777, ack 1721092980, win 14480, options [mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1], length 0\n18:31:29.150908 IP 10.0.1.6.52181 > 23.63.125.15.80: Flags [.], ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 0\n```\n**第一行**：\nclient -> server\n左面是发送时间`18:31`，`IP`代表的是这些都是 IP 协议数据包。\n`10.0.1.6.52181 > 23.63.125.15.80`，代表源和目标端的 IP 地址＋端口。比如`10.0.1.6.52181`，`10.0.1.6`是IP地址，`52181`是端口号。\n`Flags`表示 TCP 报文段 header 信息中的一些缩写标识。`S`代表 `SYN`，`.` 代表`ACK`，`P`代表`PUSH`，`F`是`FIN`。\n`1721092979`是随机号`seq`\n**第二行**\nserver -> client  \n前面几个就不多做说明，`Flags [S.]`，表示报文段 header中带有`SYN`和`ACK`。\n`ack `为`1721092980 `，即`第一行的seq+1`，`seq `为`673593777 `\n**第三行**\nclient -> server\n客户端接收到信息后，发送`Flags [.]`，报文段 header中`ACK`。\n`ack`为`673593778 `，即`第二行的seq+1`。\n\n#### 四次挥手\n\n![TCP四次分手.png](https://upload-images.jianshu.io/upload_images/2855070-a03b215b3ce31fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n1. 客户端要断开连接了，向服务器发送`FIN`信号，告诉它我的数据发送完了，但是如果你有数据，我还可以接受，然后进入`FIN_WAIT_1 `状态\n2. 服务器接确认`FIN`包后，发送一个`ack`确认包，告诉客户端我已接收到信息，但还没有做好关闭准备。发送完毕后，服务器端进入 `CLOSE_WAIT`状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2`状态，等待服务器端关闭连接。\n3. 服务器端准备好关闭连接时，向客户端发送`FIN`包，要断开连接。然后进入服务器进入`LAST_ACK `状态。\n4. 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的`ACK`包。服务器端接收到这个确认包之后，关闭连接，进入`CLOSED`状态。等过了一定时间后，客户端没有收到服务器的`ACK`包，就知道已经断开连接，进入`CLOSED `状态。\n\n#### 为什么要进行三次握手？\n通常我们会觉得，客户端告诉服务器，我要和你握手了，然后服务器告诉客户端，我知道了，这样就可以了。为什么要多客户端再给服务器确认一遍呢？\n这是因为我们现实生活中的网络是复杂的，TCP数据在传输的过程中，很有可能会出现延迟到达或者重发的情况。我们在之前谈到TCP的可靠性时，说到当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。这个时候TCP首部的序列号是相同的。\n如果因为网络问题，第二个`SYN`包提前到达，在连接结束后第一个`SYN`包才到，服务器又会发一次`ACK`建立连接。此时服务器建立了连接，客户端没有连接，从而导致服务端建立了一个空的连接，浪费资源。\n如果是三次握手，客户端再次收到相同的`ACK`时，会丢弃这个包，不向服务端发送`ACK`和`ack`，从而避免了空连接。\n#### 为什么进行四次挥手\n因为TCP是双全工模式，即可以同时发送和接收数据，两条通道是完全独立的。客户端向服务器挥手关闭的时候，服务器会继续传送之前没有传完的数据。在二三挥手之间，多了一个数据传送的过程，这也是为什么`ACK`和`FIN`不能同时发送的原因。\n### SYN攻击\n#### SYN攻击是什么\n在三次握手过程中，服务器发送`SYN-ACK`之后，收到客户端的`ACK`之前的TCP连接成为半连接(half-open connect)。此时服务器处于`SYN_RCVD `状态。当收到`ACK `之后，服务器才能转入`ESTABLISHED  `状态。\nSYN攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断发送`SYN`包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断地重发直至超时，这些伪造的`SYN`包将长时间占用未连接队列，正常的`SYN`请求被丢弃，导致目标系统运行缓慢，严重会造成网络堵塞甚至系统瘫痪。\nSYN攻击是一种典型的`DoS/DDoS`攻击。\n#### 如何检测SYN攻击\n检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的`netstats`命令来检测 SYN 攻击。\n####  如何防御SYN攻击\nSYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：\n- 缩短超时（SYN Timeout）时间\n- 增加最大半连接数\n- 过滤网关防护\n- SYN cookies技术\n\n### TCP KeepAlive\nTCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。交互双方出现死机、异常重启等情况都不会使TCP连接及时正常释放，造成端系统资源的消耗和浪费。为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。\nTCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。\n但TCP KeepAlive 是有局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。\n\n## UDP协议\nUDP协议(User Datagram Protocol)，用户数据报协议。UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。传输途中即使出现丢包，UDP 也不负责重发，甚至当出现包的到达顺序乱掉时也没有纠正的功能。UDP 面向无连接，它可以随时发送数据。\n- 面向无连接：通信双方不需要事先建立一条连接，而是把每个带有目的地址的包送到线路上，由系统自主选定路线进行传输。\n- 不可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的。\n\n### UDP首部\n\n![UDP首部.png](https://upload-images.jianshu.io/upload_images/2855070-7ad5cbcf7a6bccf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 端口号不在说明了，和TCP一样，只不过TCP端口号由TCP来查看，而UDP端口号由UDP来查看，这是根据IP数据报里面的协议来区分的。\n- UDP长度字段指的是UDP首部和UDP数据的字节长度\n- UDP检验和覆盖UDP首部和UDP数据。和TCP区别是，TCP检验和是必需的，而UDP的检验和是可选的。\n\n### TCP和UDP区别\n- 数据发送方式区别：TCP是建立在两端连接之上的协议，UDP本身发送的就是一份份数据报。\n- 数据大小的区别：TCP理论上发送的数据流没有上限，但是由于缓冲区有大小限制，但如果TCP数据过大，会被截为好几段，接收方依次接收。UDP报文长度不能超过2^16=65536(如果想具体了解UDP包长限制，可以看[这篇](http://www.52im.net/thread-29-1-1.html)).\n- 数据有序性的区别：TCP本身有着超时重传、错误重传、还有等等一系列复杂的算法保证了 TCP 的数据是有序的。UDP并不具备数据纠正功能。\n- 数据可靠性的区别：TCP 的超时重传、错误重传、TCP 的流量控制、阻塞控制、慢热启动算法、拥塞避免算法、快速恢复算法等方法都使得TCP在保持连接的过程中是可靠的。UDP是一个面向非连接的协议，UDP 发送的每个数据报带有自己的 IP 地址和接收方的 IP 地址，它本身对这个数据报是否出错，是否到达不关心，只要发出去了就好了。\n- 使用场景区别：UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信，比如：流媒体、物联网、实时游戏等。其他就可以考虑使用TCP（只是考虑，具体问题具体分析），比如QQ文件传输。\n\n## DNS协议\n通常我们去请求一个网址输入的是`https://github.com`这种形式，但这并不是IP地址。那我们怎么去寻找他的地址呢？这时候就需要DNS。\nDNS域名系统是一种用于TCP/IP应用程序的分布式数据库。我们向DNS服务器发送一个DNS数据包，然后DNS服务器做出响应告诉我们github的IP地址是`192.30.253.113`。\n目前有很多DNS服务器，比如google的`8.8.8.8`，阿里的`223.5.5.0`，百度的`180.76.76.76`。\n有时候我们会遇到DNS被污染的情况，这个时候我们就没办法去请求某一个网页。一个小技巧：在使用MAC的情况下，在跳转路径输入：`/private/etc/`，找到hosts文件，添加内容即可。\n![hosts文件.png](https://upload-images.jianshu.io/upload_images/2855070-acb13583bdfe3b0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n以上便是我对TCP/IP协议的理解，如果不当之处还望指出。\n参考：[《TCP/IP详解 卷1：协议》](http://www.52im.net/topic-tcpipvol1.html?mobile=no)\n[TCP/IP基础概述](https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TCP:IP.md)\n[IP，TCP 和 HTTP](https://objccn.io/issue-10-6/)\n","source":"_posts/网络编程-TCP-IP协议.md","raw":"---\ntitle: 网络编程 - TCP/IP协议\ndate: 2018-10-27 10:03:15\ntags: 网络\n---\n之前简单的通过[TCP/IP模型](https://darren1192.github.io/2018/10/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E6%A6%82%E8%BF%B0/)介绍了网络编程，这篇主要介绍TCP/IP协议。\nTCP/IP协议其实是一个协议簇，其中比较重要的有SLIP协议、PPP协议、IP协议、ICMP协议、ARP协议、TCP协议、UDP协议、FTP协议、DNS协议、SMTP协议等。这里我们主要介绍几个常见的协议。\n## IP协议\nIP协议(Internet Protocol)，又叫网际协议，它解决了多个局域网互通的问题，提供不可靠、无连接的数据报传送服务。\n- 不可靠：它不能保证IP数据报能成功到达目的地。IP协议会尽最大的努力，把数据包发送到目的地，但如果期间出现问题，则发送失败。比如路由器暂时用完了缓冲区。\n- 无连接：IP并不维护任何关于后续数据报的状态信息，可以不按发送顺序接收。比如先后发送A、B两条数据报。A、B是相互独立的，可能会有不同的路由选择，选择不同的路线，所以并不能判定A、B谁先到达。\n\n### IP首部\n![IP首部.png](https://upload-images.jianshu.io/upload_images/2855070-a0f12175f3f246dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n现在是看图说话时间（捡重要的说）。\n- 普通的IP首部长为20个字节，除非含有选项字段。最高位在左面，记0bit，最低位在右面，记31bit。传输次序是**大端序（Big Endian）**。先传0～7bit，其次8～15 bit，然后16～23 bit，最后是24~31 bit。\n关于大端序小端序可以看[这篇](https://blog.csdn.net/lisonglisonglisong/article/details/45421091)\n- 目前通用的版本号是4，所以也叫IPv4。\n- 首部长度指的是首部占32 bit字的数目，包括任何选项。\n-  总长度字段是指整个IP数据报的长度，最长可达65535字节。\n- 标识字段唯一地标识主机发送的每一份数据报。\n- 生存时间字段设置了数据报可以经过的最多路由器数，初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。\n- 通过首部中的协议确定接收数据的上层协议（TCP/UDP/ICMP等）。\n- 首部检验和字段是根据IP首部计算的[检验和](https://blog.csdn.net/dongfei2033/article/details/75172292)码。它可以判断首部在传输过程中有没有发生任何差错。如果发生差错就丢弃收到的数据报。\n- 源IP地址和目的IP地址在[上篇](https://www.jianshu.com/p/37122c626436)提到。\n- 选项，是数据报中的一个可变长的可选信息。\n\n## ICMP协议\nICMP(nternet Control Message Protocol)，Internet控制报文协议，从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。\n## TCP协议\nTCP协议(Transmission Control Protocol)，传输控制协议，位于传输层。它提供一种面向连接的、可靠的字节流服务。\n- 面向连接：两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。广播和多播不能用于TCP。\n- 可靠的：TCP协议将会通过以下几个方法提供可靠性\n1. 应用数据被分割成TCP认为最适合发送的数据块。\n2. 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。\n3. 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。\n4. TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。\n5. TCP数据是在IP数据包中传输，如果IP数据丢失，那么TCP数据也会丢失，进行重发。如有必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。\n6. TCP的接收端会丢弃重复的数据。\n7. TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。\n\n其实我觉得[Halfrost](https://github.com/halfrost)总结的很好：TCP就是通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。\n### TCP首部\n![TCP首部.png](https://upload-images.jianshu.io/upload_images/2855070-d2eb8abdcf1cf9bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果不计任选字段，它通常是20个字节。\n依然进入看图说话环节：\n- 每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。\n- 序号，即Sequence Number，用来解决网络包乱序问题。\n- 确认序号，即Acknowledgement Number，就是ACK——用于确认收到，用来解决不丢包的问题。\n- 首部长度，或叫数据偏移，该字段表示 TCP 所传输的数据部分应该从 TCP 包的哪个位开始计算。\n- 保留，该字段主要是为了以后扩展使用。\n- 窗口控制，TCP的流量控制由连接的每一端通过声明的窗口大小来提供。\n- 检验和，它覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。\n- 紧急指针，只有当URG标志置1时紧急指针才有效\n\n### TCP三次握手、四次挥手\n#### 三次握手\n![TCP三次握手.png](https://upload-images.jianshu.io/upload_images/2855070-bf96793d9b37dcc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n简单来说过程就是这样的：\n1. 客户端首先向服务端发送一个SYN包和一个随机序列号 J\n2. 服务端收到后会回复客户端一个 SYN-ACK 包以及一个确认号（用于确认收到 SYN）J+1，同时再发送一个随机序列号 K\n3. 客户端收到后会发送一个 ACK 包和确定号 K+1 给服务端\n\n我们看一个例子：\n```\n% sudo tcpdump -c 3 -i en3 -nS host 23.63.125.15\n18:31:29.140787 IP 10.0.1.6.52181 > 23.63.125.15.80: Flags [S], seq 1721092979, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol], length 0\n18:31:29.150866 IP 23.63.125.15.80 > 10.0.1.6.52181: Flags [S.], seq 673593777, ack 1721092980, win 14480, options [mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1], length 0\n18:31:29.150908 IP 10.0.1.6.52181 > 23.63.125.15.80: Flags [.], ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 0\n```\n**第一行**：\nclient -> server\n左面是发送时间`18:31`，`IP`代表的是这些都是 IP 协议数据包。\n`10.0.1.6.52181 > 23.63.125.15.80`，代表源和目标端的 IP 地址＋端口。比如`10.0.1.6.52181`，`10.0.1.6`是IP地址，`52181`是端口号。\n`Flags`表示 TCP 报文段 header 信息中的一些缩写标识。`S`代表 `SYN`，`.` 代表`ACK`，`P`代表`PUSH`，`F`是`FIN`。\n`1721092979`是随机号`seq`\n**第二行**\nserver -> client  \n前面几个就不多做说明，`Flags [S.]`，表示报文段 header中带有`SYN`和`ACK`。\n`ack `为`1721092980 `，即`第一行的seq+1`，`seq `为`673593777 `\n**第三行**\nclient -> server\n客户端接收到信息后，发送`Flags [.]`，报文段 header中`ACK`。\n`ack`为`673593778 `，即`第二行的seq+1`。\n\n#### 四次挥手\n\n![TCP四次分手.png](https://upload-images.jianshu.io/upload_images/2855070-a03b215b3ce31fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n1. 客户端要断开连接了，向服务器发送`FIN`信号，告诉它我的数据发送完了，但是如果你有数据，我还可以接受，然后进入`FIN_WAIT_1 `状态\n2. 服务器接确认`FIN`包后，发送一个`ack`确认包，告诉客户端我已接收到信息，但还没有做好关闭准备。发送完毕后，服务器端进入 `CLOSE_WAIT`状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2`状态，等待服务器端关闭连接。\n3. 服务器端准备好关闭连接时，向客户端发送`FIN`包，要断开连接。然后进入服务器进入`LAST_ACK `状态。\n4. 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的`ACK`包。服务器端接收到这个确认包之后，关闭连接，进入`CLOSED`状态。等过了一定时间后，客户端没有收到服务器的`ACK`包，就知道已经断开连接，进入`CLOSED `状态。\n\n#### 为什么要进行三次握手？\n通常我们会觉得，客户端告诉服务器，我要和你握手了，然后服务器告诉客户端，我知道了，这样就可以了。为什么要多客户端再给服务器确认一遍呢？\n这是因为我们现实生活中的网络是复杂的，TCP数据在传输的过程中，很有可能会出现延迟到达或者重发的情况。我们在之前谈到TCP的可靠性时，说到当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。这个时候TCP首部的序列号是相同的。\n如果因为网络问题，第二个`SYN`包提前到达，在连接结束后第一个`SYN`包才到，服务器又会发一次`ACK`建立连接。此时服务器建立了连接，客户端没有连接，从而导致服务端建立了一个空的连接，浪费资源。\n如果是三次握手，客户端再次收到相同的`ACK`时，会丢弃这个包，不向服务端发送`ACK`和`ack`，从而避免了空连接。\n#### 为什么进行四次挥手\n因为TCP是双全工模式，即可以同时发送和接收数据，两条通道是完全独立的。客户端向服务器挥手关闭的时候，服务器会继续传送之前没有传完的数据。在二三挥手之间，多了一个数据传送的过程，这也是为什么`ACK`和`FIN`不能同时发送的原因。\n### SYN攻击\n#### SYN攻击是什么\n在三次握手过程中，服务器发送`SYN-ACK`之后，收到客户端的`ACK`之前的TCP连接成为半连接(half-open connect)。此时服务器处于`SYN_RCVD `状态。当收到`ACK `之后，服务器才能转入`ESTABLISHED  `状态。\nSYN攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断发送`SYN`包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断地重发直至超时，这些伪造的`SYN`包将长时间占用未连接队列，正常的`SYN`请求被丢弃，导致目标系统运行缓慢，严重会造成网络堵塞甚至系统瘫痪。\nSYN攻击是一种典型的`DoS/DDoS`攻击。\n#### 如何检测SYN攻击\n检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的`netstats`命令来检测 SYN 攻击。\n####  如何防御SYN攻击\nSYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：\n- 缩短超时（SYN Timeout）时间\n- 增加最大半连接数\n- 过滤网关防护\n- SYN cookies技术\n\n### TCP KeepAlive\nTCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。交互双方出现死机、异常重启等情况都不会使TCP连接及时正常释放，造成端系统资源的消耗和浪费。为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。\nTCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。\n但TCP KeepAlive 是有局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。\n\n## UDP协议\nUDP协议(User Datagram Protocol)，用户数据报协议。UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。传输途中即使出现丢包，UDP 也不负责重发，甚至当出现包的到达顺序乱掉时也没有纠正的功能。UDP 面向无连接，它可以随时发送数据。\n- 面向无连接：通信双方不需要事先建立一条连接，而是把每个带有目的地址的包送到线路上，由系统自主选定路线进行传输。\n- 不可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的。\n\n### UDP首部\n\n![UDP首部.png](https://upload-images.jianshu.io/upload_images/2855070-7ad5cbcf7a6bccf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 端口号不在说明了，和TCP一样，只不过TCP端口号由TCP来查看，而UDP端口号由UDP来查看，这是根据IP数据报里面的协议来区分的。\n- UDP长度字段指的是UDP首部和UDP数据的字节长度\n- UDP检验和覆盖UDP首部和UDP数据。和TCP区别是，TCP检验和是必需的，而UDP的检验和是可选的。\n\n### TCP和UDP区别\n- 数据发送方式区别：TCP是建立在两端连接之上的协议，UDP本身发送的就是一份份数据报。\n- 数据大小的区别：TCP理论上发送的数据流没有上限，但是由于缓冲区有大小限制，但如果TCP数据过大，会被截为好几段，接收方依次接收。UDP报文长度不能超过2^16=65536(如果想具体了解UDP包长限制，可以看[这篇](http://www.52im.net/thread-29-1-1.html)).\n- 数据有序性的区别：TCP本身有着超时重传、错误重传、还有等等一系列复杂的算法保证了 TCP 的数据是有序的。UDP并不具备数据纠正功能。\n- 数据可靠性的区别：TCP 的超时重传、错误重传、TCP 的流量控制、阻塞控制、慢热启动算法、拥塞避免算法、快速恢复算法等方法都使得TCP在保持连接的过程中是可靠的。UDP是一个面向非连接的协议，UDP 发送的每个数据报带有自己的 IP 地址和接收方的 IP 地址，它本身对这个数据报是否出错，是否到达不关心，只要发出去了就好了。\n- 使用场景区别：UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信，比如：流媒体、物联网、实时游戏等。其他就可以考虑使用TCP（只是考虑，具体问题具体分析），比如QQ文件传输。\n\n## DNS协议\n通常我们去请求一个网址输入的是`https://github.com`这种形式，但这并不是IP地址。那我们怎么去寻找他的地址呢？这时候就需要DNS。\nDNS域名系统是一种用于TCP/IP应用程序的分布式数据库。我们向DNS服务器发送一个DNS数据包，然后DNS服务器做出响应告诉我们github的IP地址是`192.30.253.113`。\n目前有很多DNS服务器，比如google的`8.8.8.8`，阿里的`223.5.5.0`，百度的`180.76.76.76`。\n有时候我们会遇到DNS被污染的情况，这个时候我们就没办法去请求某一个网页。一个小技巧：在使用MAC的情况下，在跳转路径输入：`/private/etc/`，找到hosts文件，添加内容即可。\n![hosts文件.png](https://upload-images.jianshu.io/upload_images/2855070-acb13583bdfe3b0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n以上便是我对TCP/IP协议的理解，如果不当之处还望指出。\n参考：[《TCP/IP详解 卷1：协议》](http://www.52im.net/topic-tcpipvol1.html?mobile=no)\n[TCP/IP基础概述](https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TCP:IP.md)\n[IP，TCP 和 HTTP](https://objccn.io/issue-10-6/)\n","slug":"网络编程-TCP-IP协议","published":1,"updated":"2018-11-05T06:52:05.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxzo00112ycw8oqi09sh","content":"<p>之前简单的通过<a href=\"https://darren1192.github.io/2018/10/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E6%A6%82%E8%BF%B0/\" target=\"_blank\" rel=\"noopener\">TCP/IP模型</a>介绍了网络编程，这篇主要介绍TCP/IP协议。<br>TCP/IP协议其实是一个协议簇，其中比较重要的有SLIP协议、PPP协议、IP协议、ICMP协议、ARP协议、TCP协议、UDP协议、FTP协议、DNS协议、SMTP协议等。这里我们主要介绍几个常见的协议。</p>\n<h2 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h2><p>IP协议(Internet Protocol)，又叫网际协议，它解决了多个局域网互通的问题，提供不可靠、无连接的数据报传送服务。</p>\n<ul>\n<li>不可靠：它不能保证IP数据报能成功到达目的地。IP协议会尽最大的努力，把数据包发送到目的地，但如果期间出现问题，则发送失败。比如路由器暂时用完了缓冲区。</li>\n<li>无连接：IP并不维护任何关于后续数据报的状态信息，可以不按发送顺序接收。比如先后发送A、B两条数据报。A、B是相互独立的，可能会有不同的路由选择，选择不同的路线，所以并不能判定A、B谁先到达。</li>\n</ul>\n<h3 id=\"IP首部\"><a href=\"#IP首部\" class=\"headerlink\" title=\"IP首部\"></a>IP首部</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-a0f12175f3f246dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"IP首部.png\"><br>现在是看图说话时间（捡重要的说）。</p>\n<ul>\n<li>普通的IP首部长为20个字节，除非含有选项字段。最高位在左面，记0bit，最低位在右面，记31bit。传输次序是<strong>大端序（Big Endian）</strong>。先传0～7bit，其次8～15 bit，然后16～23 bit，最后是24~31 bit。<br>关于大端序小端序可以看<a href=\"https://blog.csdn.net/lisonglisonglisong/article/details/45421091\" target=\"_blank\" rel=\"noopener\">这篇</a></li>\n<li>目前通用的版本号是4，所以也叫IPv4。</li>\n<li>首部长度指的是首部占32 bit字的数目，包括任何选项。</li>\n<li>总长度字段是指整个IP数据报的长度，最长可达65535字节。</li>\n<li>标识字段唯一地标识主机发送的每一份数据报。</li>\n<li>生存时间字段设置了数据报可以经过的最多路由器数，初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li>\n<li>通过首部中的协议确定接收数据的上层协议（TCP/UDP/ICMP等）。</li>\n<li>首部检验和字段是根据IP首部计算的<a href=\"https://blog.csdn.net/dongfei2033/article/details/75172292\" target=\"_blank\" rel=\"noopener\">检验和</a>码。它可以判断首部在传输过程中有没有发生任何差错。如果发生差错就丢弃收到的数据报。</li>\n<li>源IP地址和目的IP地址在<a href=\"https://www.jianshu.com/p/37122c626436\" target=\"_blank\" rel=\"noopener\">上篇</a>提到。</li>\n<li>选项，是数据报中的一个可变长的可选信息。</li>\n</ul>\n<h2 id=\"ICMP协议\"><a href=\"#ICMP协议\" class=\"headerlink\" title=\"ICMP协议\"></a>ICMP协议</h2><p>ICMP(nternet Control Message Protocol)，Internet控制报文协议，从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</p>\n<h2 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h2><p>TCP协议(Transmission Control Protocol)，传输控制协议，位于传输层。它提供一种面向连接的、可靠的字节流服务。</p>\n<ul>\n<li>面向连接：两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。广播和多播不能用于TCP。</li>\n<li>可靠的：TCP协议将会通过以下几个方法提供可靠性</li>\n</ul>\n<ol>\n<li>应用数据被分割成TCP认为最适合发送的数据块。</li>\n<li>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>\n<li>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</li>\n<li>TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</li>\n<li>TCP数据是在IP数据包中传输，如果IP数据丢失，那么TCP数据也会丢失，进行重发。如有必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</li>\n<li>TCP的接收端会丢弃重复的数据。</li>\n<li>TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li>\n</ol>\n<p>其实我觉得<a href=\"https://github.com/halfrost\" target=\"_blank\" rel=\"noopener\">Halfrost</a>总结的很好：TCP就是通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>\n<h3 id=\"TCP首部\"><a href=\"#TCP首部\" class=\"headerlink\" title=\"TCP首部\"></a>TCP首部</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-d2eb8abdcf1cf9bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP首部.png\"></p>\n<p>如果不计任选字段，它通常是20个字节。<br>依然进入看图说话环节：</p>\n<ul>\n<li>每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。</li>\n<li>序号，即Sequence Number，用来解决网络包乱序问题。</li>\n<li>确认序号，即Acknowledgement Number，就是ACK——用于确认收到，用来解决不丢包的问题。</li>\n<li>首部长度，或叫数据偏移，该字段表示 TCP 所传输的数据部分应该从 TCP 包的哪个位开始计算。</li>\n<li>保留，该字段主要是为了以后扩展使用。</li>\n<li>窗口控制，TCP的流量控制由连接的每一端通过声明的窗口大小来提供。</li>\n<li>检验和，它覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</li>\n<li>紧急指针，只有当URG标志置1时紧急指针才有效</li>\n</ul>\n<h3 id=\"TCP三次握手、四次挥手\"><a href=\"#TCP三次握手、四次挥手\" class=\"headerlink\" title=\"TCP三次握手、四次挥手\"></a>TCP三次握手、四次挥手</h3><h4 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bf96793d9b37dcc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP三次握手.png\"><br>简单来说过程就是这样的：</p>\n<ol>\n<li>客户端首先向服务端发送一个SYN包和一个随机序列号 J</li>\n<li>服务端收到后会回复客户端一个 SYN-ACK 包以及一个确认号（用于确认收到 SYN）J+1，同时再发送一个随机序列号 K</li>\n<li>客户端收到后会发送一个 ACK 包和确定号 K+1 给服务端</li>\n</ol>\n<p>我们看一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% sudo tcpdump -c 3 -i en3 -nS host 23.63.125.15</span><br><span class=\"line\">18:31:29.140787 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [S], seq 1721092979, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol], length 0</span><br><span class=\"line\">18:31:29.150866 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [S.], seq 673593777, ack 1721092980, win 14480, options [mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1], length 0</span><br><span class=\"line\">18:31:29.150908 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 0</span><br></pre></td></tr></table></figure></p>\n<p><strong>第一行</strong>：<br>client -&gt; server<br>左面是发送时间<code>18:31</code>，<code>IP</code>代表的是这些都是 IP 协议数据包。<br><code>10.0.1.6.52181 &gt; 23.63.125.15.80</code>，代表源和目标端的 IP 地址＋端口。比如<code>10.0.1.6.52181</code>，<code>10.0.1.6</code>是IP地址，<code>52181</code>是端口号。<br><code>Flags</code>表示 TCP 报文段 header 信息中的一些缩写标识。<code>S</code>代表 <code>SYN</code>，<code>.</code> 代表<code>ACK</code>，<code>P</code>代表<code>PUSH</code>，<code>F</code>是<code>FIN</code>。<br><code>1721092979</code>是随机号<code>seq</code><br><strong>第二行</strong><br>server -&gt; client<br>前面几个就不多做说明，<code>Flags [S.]</code>，表示报文段 header中带有<code>SYN</code>和<code>ACK</code>。<br><code>ack</code>为<code>1721092980</code>，即<code>第一行的seq+1</code>，<code>seq</code>为<code>673593777</code><br><strong>第三行</strong><br>client -&gt; server<br>客户端接收到信息后，发送<code>Flags [.]</code>，报文段 header中<code>ACK</code>。<br><code>ack</code>为<code>673593778</code>，即<code>第二行的seq+1</code>。</p>\n<h4 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-a03b215b3ce31fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP四次分手.png\"></p>\n<ol>\n<li>客户端要断开连接了，向服务器发送<code>FIN</code>信号，告诉它我的数据发送完了，但是如果你有数据，我还可以接受，然后进入<code>FIN_WAIT_1</code>状态</li>\n<li>服务器接确认<code>FIN</code>包后，发送一个<code>ack</code>确认包，告诉客户端我已接收到信息，但还没有做好关闭准备。发送完毕后，服务器端进入 <code>CLOSE_WAIT</code>状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code>状态，等待服务器端关闭连接。</li>\n<li>服务器端准备好关闭连接时，向客户端发送<code>FIN</code>包，要断开连接。然后进入服务器进入<code>LAST_ACK</code>状态。</li>\n<li>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的<code>ACK</code>包。服务器端接收到这个确认包之后，关闭连接，进入<code>CLOSED</code>状态。等过了一定时间后，客户端没有收到服务器的<code>ACK</code>包，就知道已经断开连接，进入<code>CLOSED</code>状态。</li>\n</ol>\n<h4 id=\"为什么要进行三次握手？\"><a href=\"#为什么要进行三次握手？\" class=\"headerlink\" title=\"为什么要进行三次握手？\"></a>为什么要进行三次握手？</h4><p>通常我们会觉得，客户端告诉服务器，我要和你握手了，然后服务器告诉客户端，我知道了，这样就可以了。为什么要多客户端再给服务器确认一遍呢？<br>这是因为我们现实生活中的网络是复杂的，TCP数据在传输的过程中，很有可能会出现延迟到达或者重发的情况。我们在之前谈到TCP的可靠性时，说到当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。这个时候TCP首部的序列号是相同的。<br>如果因为网络问题，第二个<code>SYN</code>包提前到达，在连接结束后第一个<code>SYN</code>包才到，服务器又会发一次<code>ACK</code>建立连接。此时服务器建立了连接，客户端没有连接，从而导致服务端建立了一个空的连接，浪费资源。<br>如果是三次握手，客户端再次收到相同的<code>ACK</code>时，会丢弃这个包，不向服务端发送<code>ACK</code>和<code>ack</code>，从而避免了空连接。</p>\n<h4 id=\"为什么进行四次挥手\"><a href=\"#为什么进行四次挥手\" class=\"headerlink\" title=\"为什么进行四次挥手\"></a>为什么进行四次挥手</h4><p>因为TCP是双全工模式，即可以同时发送和接收数据，两条通道是完全独立的。客户端向服务器挥手关闭的时候，服务器会继续传送之前没有传完的数据。在二三挥手之间，多了一个数据传送的过程，这也是为什么<code>ACK</code>和<code>FIN</code>不能同时发送的原因。</p>\n<h3 id=\"SYN攻击\"><a href=\"#SYN攻击\" class=\"headerlink\" title=\"SYN攻击\"></a>SYN攻击</h3><h4 id=\"SYN攻击是什么\"><a href=\"#SYN攻击是什么\" class=\"headerlink\" title=\"SYN攻击是什么\"></a>SYN攻击是什么</h4><p>在三次握手过程中，服务器发送<code>SYN-ACK</code>之后，收到客户端的<code>ACK</code>之前的TCP连接成为半连接(half-open connect)。此时服务器处于<code>SYN_RCVD</code>状态。当收到<code>ACK</code>之后，服务器才能转入<code>ESTABLISHED</code>状态。<br>SYN攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断发送<code>SYN</code>包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断地重发直至超时，这些伪造的<code>SYN</code>包将长时间占用未连接队列，正常的<code>SYN</code>请求被丢弃，导致目标系统运行缓慢，严重会造成网络堵塞甚至系统瘫痪。<br>SYN攻击是一种典型的<code>DoS/DDoS</code>攻击。</p>\n<h4 id=\"如何检测SYN攻击\"><a href=\"#如何检测SYN攻击\" class=\"headerlink\" title=\"如何检测SYN攻击\"></a>如何检测SYN攻击</h4><p>检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的<code>netstats</code>命令来检测 SYN 攻击。</p>\n<h4 id=\"如何防御SYN攻击\"><a href=\"#如何防御SYN攻击\" class=\"headerlink\" title=\"如何防御SYN攻击\"></a>如何防御SYN攻击</h4><p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p>\n<ul>\n<li>缩短超时（SYN Timeout）时间</li>\n<li>增加最大半连接数</li>\n<li>过滤网关防护</li>\n<li>SYN cookies技术</li>\n</ul>\n<h3 id=\"TCP-KeepAlive\"><a href=\"#TCP-KeepAlive\" class=\"headerlink\" title=\"TCP KeepAlive\"></a>TCP KeepAlive</h3><p>TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。交互双方出现死机、异常重启等情况都不会使TCP连接及时正常释放，造成端系统资源的消耗和浪费。为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。<br>TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。<br>但TCP KeepAlive 是有局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。</p>\n<h2 id=\"UDP协议\"><a href=\"#UDP协议\" class=\"headerlink\" title=\"UDP协议\"></a>UDP协议</h2><p>UDP协议(User Datagram Protocol)，用户数据报协议。UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。传输途中即使出现丢包，UDP 也不负责重发，甚至当出现包的到达顺序乱掉时也没有纠正的功能。UDP 面向无连接，它可以随时发送数据。</p>\n<ul>\n<li>面向无连接：通信双方不需要事先建立一条连接，而是把每个带有目的地址的包送到线路上，由系统自主选定路线进行传输。</li>\n<li>不可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的。</li>\n</ul>\n<h3 id=\"UDP首部\"><a href=\"#UDP首部\" class=\"headerlink\" title=\"UDP首部\"></a>UDP首部</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-7ad5cbcf7a6bccf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"UDP首部.png\"></p>\n<ul>\n<li>端口号不在说明了，和TCP一样，只不过TCP端口号由TCP来查看，而UDP端口号由UDP来查看，这是根据IP数据报里面的协议来区分的。</li>\n<li>UDP长度字段指的是UDP首部和UDP数据的字节长度</li>\n<li>UDP检验和覆盖UDP首部和UDP数据。和TCP区别是，TCP检验和是必需的，而UDP的检验和是可选的。</li>\n</ul>\n<h3 id=\"TCP和UDP区别\"><a href=\"#TCP和UDP区别\" class=\"headerlink\" title=\"TCP和UDP区别\"></a>TCP和UDP区别</h3><ul>\n<li>数据发送方式区别：TCP是建立在两端连接之上的协议，UDP本身发送的就是一份份数据报。</li>\n<li>数据大小的区别：TCP理论上发送的数据流没有上限，但是由于缓冲区有大小限制，但如果TCP数据过大，会被截为好几段，接收方依次接收。UDP报文长度不能超过2^16=65536(如果想具体了解UDP包长限制，可以看<a href=\"http://www.52im.net/thread-29-1-1.html\" target=\"_blank\" rel=\"noopener\">这篇</a>).</li>\n<li>数据有序性的区别：TCP本身有着超时重传、错误重传、还有等等一系列复杂的算法保证了 TCP 的数据是有序的。UDP并不具备数据纠正功能。</li>\n<li>数据可靠性的区别：TCP 的超时重传、错误重传、TCP 的流量控制、阻塞控制、慢热启动算法、拥塞避免算法、快速恢复算法等方法都使得TCP在保持连接的过程中是可靠的。UDP是一个面向非连接的协议，UDP 发送的每个数据报带有自己的 IP 地址和接收方的 IP 地址，它本身对这个数据报是否出错，是否到达不关心，只要发出去了就好了。</li>\n<li>使用场景区别：UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信，比如：流媒体、物联网、实时游戏等。其他就可以考虑使用TCP（只是考虑，具体问题具体分析），比如QQ文件传输。</li>\n</ul>\n<h2 id=\"DNS协议\"><a href=\"#DNS协议\" class=\"headerlink\" title=\"DNS协议\"></a>DNS协议</h2><p>通常我们去请求一个网址输入的是<code>https://github.com</code>这种形式，但这并不是IP地址。那我们怎么去寻找他的地址呢？这时候就需要DNS。<br>DNS域名系统是一种用于TCP/IP应用程序的分布式数据库。我们向DNS服务器发送一个DNS数据包，然后DNS服务器做出响应告诉我们github的IP地址是<code>192.30.253.113</code>。<br>目前有很多DNS服务器，比如google的<code>8.8.8.8</code>，阿里的<code>223.5.5.0</code>，百度的<code>180.76.76.76</code>。<br>有时候我们会遇到DNS被污染的情况，这个时候我们就没办法去请求某一个网页。一个小技巧：在使用MAC的情况下，在跳转路径输入：<code>/private/etc/</code>，找到hosts文件，添加内容即可。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-acb13583bdfe3b0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"hosts文件.png\"></p>\n<p>以上便是我对TCP/IP协议的理解，如果不当之处还望指出。<br>参考：<a href=\"http://www.52im.net/topic-tcpipvol1.html?mobile=no\" target=\"_blank\" rel=\"noopener\">《TCP/IP详解 卷1：协议》</a><br><a href=\"https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TCP:IP.md\" target=\"_blank\" rel=\"noopener\">TCP/IP基础概述</a><br><a href=\"https://objccn.io/issue-10-6/\" target=\"_blank\" rel=\"noopener\">IP，TCP 和 HTTP</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前简单的通过<a href=\"https://darren1192.github.io/2018/10/25/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E6%A6%82%E8%BF%B0/\" target=\"_blank\" rel=\"noopener\">TCP/IP模型</a>介绍了网络编程，这篇主要介绍TCP/IP协议。<br>TCP/IP协议其实是一个协议簇，其中比较重要的有SLIP协议、PPP协议、IP协议、ICMP协议、ARP协议、TCP协议、UDP协议、FTP协议、DNS协议、SMTP协议等。这里我们主要介绍几个常见的协议。</p>\n<h2 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h2><p>IP协议(Internet Protocol)，又叫网际协议，它解决了多个局域网互通的问题，提供不可靠、无连接的数据报传送服务。</p>\n<ul>\n<li>不可靠：它不能保证IP数据报能成功到达目的地。IP协议会尽最大的努力，把数据包发送到目的地，但如果期间出现问题，则发送失败。比如路由器暂时用完了缓冲区。</li>\n<li>无连接：IP并不维护任何关于后续数据报的状态信息，可以不按发送顺序接收。比如先后发送A、B两条数据报。A、B是相互独立的，可能会有不同的路由选择，选择不同的路线，所以并不能判定A、B谁先到达。</li>\n</ul>\n<h3 id=\"IP首部\"><a href=\"#IP首部\" class=\"headerlink\" title=\"IP首部\"></a>IP首部</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-a0f12175f3f246dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"IP首部.png\"><br>现在是看图说话时间（捡重要的说）。</p>\n<ul>\n<li>普通的IP首部长为20个字节，除非含有选项字段。最高位在左面，记0bit，最低位在右面，记31bit。传输次序是<strong>大端序（Big Endian）</strong>。先传0～7bit，其次8～15 bit，然后16～23 bit，最后是24~31 bit。<br>关于大端序小端序可以看<a href=\"https://blog.csdn.net/lisonglisonglisong/article/details/45421091\" target=\"_blank\" rel=\"noopener\">这篇</a></li>\n<li>目前通用的版本号是4，所以也叫IPv4。</li>\n<li>首部长度指的是首部占32 bit字的数目，包括任何选项。</li>\n<li>总长度字段是指整个IP数据报的长度，最长可达65535字节。</li>\n<li>标识字段唯一地标识主机发送的每一份数据报。</li>\n<li>生存时间字段设置了数据报可以经过的最多路由器数，初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</li>\n<li>通过首部中的协议确定接收数据的上层协议（TCP/UDP/ICMP等）。</li>\n<li>首部检验和字段是根据IP首部计算的<a href=\"https://blog.csdn.net/dongfei2033/article/details/75172292\" target=\"_blank\" rel=\"noopener\">检验和</a>码。它可以判断首部在传输过程中有没有发生任何差错。如果发生差错就丢弃收到的数据报。</li>\n<li>源IP地址和目的IP地址在<a href=\"https://www.jianshu.com/p/37122c626436\" target=\"_blank\" rel=\"noopener\">上篇</a>提到。</li>\n<li>选项，是数据报中的一个可变长的可选信息。</li>\n</ul>\n<h2 id=\"ICMP协议\"><a href=\"#ICMP协议\" class=\"headerlink\" title=\"ICMP协议\"></a>ICMP协议</h2><p>ICMP(nternet Control Message Protocol)，Internet控制报文协议，从技术角度来说，ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性﹐其主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</p>\n<h2 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h2><p>TCP协议(Transmission Control Protocol)，传输控制协议，位于传输层。它提供一种面向连接的、可靠的字节流服务。</p>\n<ul>\n<li>面向连接：两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。广播和多播不能用于TCP。</li>\n<li>可靠的：TCP协议将会通过以下几个方法提供可靠性</li>\n</ul>\n<ol>\n<li>应用数据被分割成TCP认为最适合发送的数据块。</li>\n<li>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>\n<li>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</li>\n<li>TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</li>\n<li>TCP数据是在IP数据包中传输，如果IP数据丢失，那么TCP数据也会丢失，进行重发。如有必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</li>\n<li>TCP的接收端会丢弃重复的数据。</li>\n<li>TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li>\n</ol>\n<p>其实我觉得<a href=\"https://github.com/halfrost\" target=\"_blank\" rel=\"noopener\">Halfrost</a>总结的很好：TCP就是通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>\n<h3 id=\"TCP首部\"><a href=\"#TCP首部\" class=\"headerlink\" title=\"TCP首部\"></a>TCP首部</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-d2eb8abdcf1cf9bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP首部.png\"></p>\n<p>如果不计任选字段，它通常是20个字节。<br>依然进入看图说话环节：</p>\n<ul>\n<li>每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程。</li>\n<li>序号，即Sequence Number，用来解决网络包乱序问题。</li>\n<li>确认序号，即Acknowledgement Number，就是ACK——用于确认收到，用来解决不丢包的问题。</li>\n<li>首部长度，或叫数据偏移，该字段表示 TCP 所传输的数据部分应该从 TCP 包的哪个位开始计算。</li>\n<li>保留，该字段主要是为了以后扩展使用。</li>\n<li>窗口控制，TCP的流量控制由连接的每一端通过声明的窗口大小来提供。</li>\n<li>检验和，它覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</li>\n<li>紧急指针，只有当URG标志置1时紧急指针才有效</li>\n</ul>\n<h3 id=\"TCP三次握手、四次挥手\"><a href=\"#TCP三次握手、四次挥手\" class=\"headerlink\" title=\"TCP三次握手、四次挥手\"></a>TCP三次握手、四次挥手</h3><h4 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-bf96793d9b37dcc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP三次握手.png\"><br>简单来说过程就是这样的：</p>\n<ol>\n<li>客户端首先向服务端发送一个SYN包和一个随机序列号 J</li>\n<li>服务端收到后会回复客户端一个 SYN-ACK 包以及一个确认号（用于确认收到 SYN）J+1，同时再发送一个随机序列号 K</li>\n<li>客户端收到后会发送一个 ACK 包和确定号 K+1 给服务端</li>\n</ol>\n<p>我们看一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">% sudo tcpdump -c 3 -i en3 -nS host 23.63.125.15</span><br><span class=\"line\">18:31:29.140787 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [S], seq 1721092979, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 743929763 ecr 0,sackOK,eol], length 0</span><br><span class=\"line\">18:31:29.150866 IP 23.63.125.15.80 &gt; 10.0.1.6.52181: Flags [S.], seq 673593777, ack 1721092980, win 14480, options [mss 1460,sackOK,TS val 1433256622 ecr 743929763,nop,wscale 1], length 0</span><br><span class=\"line\">18:31:29.150908 IP 10.0.1.6.52181 &gt; 23.63.125.15.80: Flags [.], ack 673593778, win 8235, options [nop,nop,TS val 743929773 ecr 1433256622], length 0</span><br></pre></td></tr></table></figure></p>\n<p><strong>第一行</strong>：<br>client -&gt; server<br>左面是发送时间<code>18:31</code>，<code>IP</code>代表的是这些都是 IP 协议数据包。<br><code>10.0.1.6.52181 &gt; 23.63.125.15.80</code>，代表源和目标端的 IP 地址＋端口。比如<code>10.0.1.6.52181</code>，<code>10.0.1.6</code>是IP地址，<code>52181</code>是端口号。<br><code>Flags</code>表示 TCP 报文段 header 信息中的一些缩写标识。<code>S</code>代表 <code>SYN</code>，<code>.</code> 代表<code>ACK</code>，<code>P</code>代表<code>PUSH</code>，<code>F</code>是<code>FIN</code>。<br><code>1721092979</code>是随机号<code>seq</code><br><strong>第二行</strong><br>server -&gt; client<br>前面几个就不多做说明，<code>Flags [S.]</code>，表示报文段 header中带有<code>SYN</code>和<code>ACK</code>。<br><code>ack</code>为<code>1721092980</code>，即<code>第一行的seq+1</code>，<code>seq</code>为<code>673593777</code><br><strong>第三行</strong><br>client -&gt; server<br>客户端接收到信息后，发送<code>Flags [.]</code>，报文段 header中<code>ACK</code>。<br><code>ack</code>为<code>673593778</code>，即<code>第二行的seq+1</code>。</p>\n<h4 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-a03b215b3ce31fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP四次分手.png\"></p>\n<ol>\n<li>客户端要断开连接了，向服务器发送<code>FIN</code>信号，告诉它我的数据发送完了，但是如果你有数据，我还可以接受，然后进入<code>FIN_WAIT_1</code>状态</li>\n<li>服务器接确认<code>FIN</code>包后，发送一个<code>ack</code>确认包，告诉客户端我已接收到信息，但还没有做好关闭准备。发送完毕后，服务器端进入 <code>CLOSE_WAIT</code>状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code>状态，等待服务器端关闭连接。</li>\n<li>服务器端准备好关闭连接时，向客户端发送<code>FIN</code>包，要断开连接。然后进入服务器进入<code>LAST_ACK</code>状态。</li>\n<li>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的<code>ACK</code>包。服务器端接收到这个确认包之后，关闭连接，进入<code>CLOSED</code>状态。等过了一定时间后，客户端没有收到服务器的<code>ACK</code>包，就知道已经断开连接，进入<code>CLOSED</code>状态。</li>\n</ol>\n<h4 id=\"为什么要进行三次握手？\"><a href=\"#为什么要进行三次握手？\" class=\"headerlink\" title=\"为什么要进行三次握手？\"></a>为什么要进行三次握手？</h4><p>通常我们会觉得，客户端告诉服务器，我要和你握手了，然后服务器告诉客户端，我知道了，这样就可以了。为什么要多客户端再给服务器确认一遍呢？<br>这是因为我们现实生活中的网络是复杂的，TCP数据在传输的过程中，很有可能会出现延迟到达或者重发的情况。我们在之前谈到TCP的可靠性时，说到当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。这个时候TCP首部的序列号是相同的。<br>如果因为网络问题，第二个<code>SYN</code>包提前到达，在连接结束后第一个<code>SYN</code>包才到，服务器又会发一次<code>ACK</code>建立连接。此时服务器建立了连接，客户端没有连接，从而导致服务端建立了一个空的连接，浪费资源。<br>如果是三次握手，客户端再次收到相同的<code>ACK</code>时，会丢弃这个包，不向服务端发送<code>ACK</code>和<code>ack</code>，从而避免了空连接。</p>\n<h4 id=\"为什么进行四次挥手\"><a href=\"#为什么进行四次挥手\" class=\"headerlink\" title=\"为什么进行四次挥手\"></a>为什么进行四次挥手</h4><p>因为TCP是双全工模式，即可以同时发送和接收数据，两条通道是完全独立的。客户端向服务器挥手关闭的时候，服务器会继续传送之前没有传完的数据。在二三挥手之间，多了一个数据传送的过程，这也是为什么<code>ACK</code>和<code>FIN</code>不能同时发送的原因。</p>\n<h3 id=\"SYN攻击\"><a href=\"#SYN攻击\" class=\"headerlink\" title=\"SYN攻击\"></a>SYN攻击</h3><h4 id=\"SYN攻击是什么\"><a href=\"#SYN攻击是什么\" class=\"headerlink\" title=\"SYN攻击是什么\"></a>SYN攻击是什么</h4><p>在三次握手过程中，服务器发送<code>SYN-ACK</code>之后，收到客户端的<code>ACK</code>之前的TCP连接成为半连接(half-open connect)。此时服务器处于<code>SYN_RCVD</code>状态。当收到<code>ACK</code>之后，服务器才能转入<code>ESTABLISHED</code>状态。<br>SYN攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断发送<code>SYN</code>包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断地重发直至超时，这些伪造的<code>SYN</code>包将长时间占用未连接队列，正常的<code>SYN</code>请求被丢弃，导致目标系统运行缓慢，严重会造成网络堵塞甚至系统瘫痪。<br>SYN攻击是一种典型的<code>DoS/DDoS</code>攻击。</p>\n<h4 id=\"如何检测SYN攻击\"><a href=\"#如何检测SYN攻击\" class=\"headerlink\" title=\"如何检测SYN攻击\"></a>如何检测SYN攻击</h4><p>检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的<code>netstats</code>命令来检测 SYN 攻击。</p>\n<h4 id=\"如何防御SYN攻击\"><a href=\"#如何防御SYN攻击\" class=\"headerlink\" title=\"如何防御SYN攻击\"></a>如何防御SYN攻击</h4><p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p>\n<ul>\n<li>缩短超时（SYN Timeout）时间</li>\n<li>增加最大半连接数</li>\n<li>过滤网关防护</li>\n<li>SYN cookies技术</li>\n</ul>\n<h3 id=\"TCP-KeepAlive\"><a href=\"#TCP-KeepAlive\" class=\"headerlink\" title=\"TCP KeepAlive\"></a>TCP KeepAlive</h3><p>TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。交互双方出现死机、异常重启等情况都不会使TCP连接及时正常释放，造成端系统资源的消耗和浪费。为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。<br>TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。<br>但TCP KeepAlive 是有局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。</p>\n<h2 id=\"UDP协议\"><a href=\"#UDP协议\" class=\"headerlink\" title=\"UDP协议\"></a>UDP协议</h2><p>UDP协议(User Datagram Protocol)，用户数据报协议。UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。传输途中即使出现丢包，UDP 也不负责重发，甚至当出现包的到达顺序乱掉时也没有纠正的功能。UDP 面向无连接，它可以随时发送数据。</p>\n<ul>\n<li>面向无连接：通信双方不需要事先建立一条连接，而是把每个带有目的地址的包送到线路上，由系统自主选定路线进行传输。</li>\n<li>不可靠性：它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的。</li>\n</ul>\n<h3 id=\"UDP首部\"><a href=\"#UDP首部\" class=\"headerlink\" title=\"UDP首部\"></a>UDP首部</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-7ad5cbcf7a6bccf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"UDP首部.png\"></p>\n<ul>\n<li>端口号不在说明了，和TCP一样，只不过TCP端口号由TCP来查看，而UDP端口号由UDP来查看，这是根据IP数据报里面的协议来区分的。</li>\n<li>UDP长度字段指的是UDP首部和UDP数据的字节长度</li>\n<li>UDP检验和覆盖UDP首部和UDP数据。和TCP区别是，TCP检验和是必需的，而UDP的检验和是可选的。</li>\n</ul>\n<h3 id=\"TCP和UDP区别\"><a href=\"#TCP和UDP区别\" class=\"headerlink\" title=\"TCP和UDP区别\"></a>TCP和UDP区别</h3><ul>\n<li>数据发送方式区别：TCP是建立在两端连接之上的协议，UDP本身发送的就是一份份数据报。</li>\n<li>数据大小的区别：TCP理论上发送的数据流没有上限，但是由于缓冲区有大小限制，但如果TCP数据过大，会被截为好几段，接收方依次接收。UDP报文长度不能超过2^16=65536(如果想具体了解UDP包长限制，可以看<a href=\"http://www.52im.net/thread-29-1-1.html\" target=\"_blank\" rel=\"noopener\">这篇</a>).</li>\n<li>数据有序性的区别：TCP本身有着超时重传、错误重传、还有等等一系列复杂的算法保证了 TCP 的数据是有序的。UDP并不具备数据纠正功能。</li>\n<li>数据可靠性的区别：TCP 的超时重传、错误重传、TCP 的流量控制、阻塞控制、慢热启动算法、拥塞避免算法、快速恢复算法等方法都使得TCP在保持连接的过程中是可靠的。UDP是一个面向非连接的协议，UDP 发送的每个数据报带有自己的 IP 地址和接收方的 IP 地址，它本身对这个数据报是否出错，是否到达不关心，只要发出去了就好了。</li>\n<li>使用场景区别：UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信，比如：流媒体、物联网、实时游戏等。其他就可以考虑使用TCP（只是考虑，具体问题具体分析），比如QQ文件传输。</li>\n</ul>\n<h2 id=\"DNS协议\"><a href=\"#DNS协议\" class=\"headerlink\" title=\"DNS协议\"></a>DNS协议</h2><p>通常我们去请求一个网址输入的是<code>https://github.com</code>这种形式，但这并不是IP地址。那我们怎么去寻找他的地址呢？这时候就需要DNS。<br>DNS域名系统是一种用于TCP/IP应用程序的分布式数据库。我们向DNS服务器发送一个DNS数据包，然后DNS服务器做出响应告诉我们github的IP地址是<code>192.30.253.113</code>。<br>目前有很多DNS服务器，比如google的<code>8.8.8.8</code>，阿里的<code>223.5.5.0</code>，百度的<code>180.76.76.76</code>。<br>有时候我们会遇到DNS被污染的情况，这个时候我们就没办法去请求某一个网页。一个小技巧：在使用MAC的情况下，在跳转路径输入：<code>/private/etc/</code>，找到hosts文件，添加内容即可。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-acb13583bdfe3b0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"hosts文件.png\"></p>\n<p>以上便是我对TCP/IP协议的理解，如果不当之处还望指出。<br>参考：<a href=\"http://www.52im.net/topic-tcpipvol1.html?mobile=no\" target=\"_blank\" rel=\"noopener\">《TCP/IP详解 卷1：协议》</a><br><a href=\"https://github.com/halfrost/Halfrost-Field/blob/master/contents/Protocol/TCP:IP.md\" target=\"_blank\" rel=\"noopener\">TCP/IP基础概述</a><br><a href=\"https://objccn.io/issue-10-6/\" target=\"_blank\" rel=\"noopener\">IP，TCP 和 HTTP</a></p>\n"},{"title":"网络编程 - HTTP协议","date":"2018-11-05T06:54:08.000Z","_content":"HTTP协议，全称超文本传输协议(HyperText Transfer Protocol)，是目前互联网上应用最为广泛的一种网络协议，位于应用层。\n##  HTTP基础\n### HTTP协议用于客户端和服务端之间的通信\n两台计算机之间使用HTTP协议通信时，必有一端是客户端，另外一端是服务器端。其中请求访问资源的一端为客户端，提供资源响应的一端称为服务器端。有时候两台计算机的角色可能会互换，但是仅从一条通信路线来说，客户端和服务器端的角色是确定的。\n### 通过请求和响应的交换达成通信\nHTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。\n### HTTP是不保存状态的协议\nHTTP是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。\n### 请求URI定位资源\nHTTP协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。\n### 告知服务器意图的 HTTP 方法\n|方法名|说明|描述|支持版本|\n--|--|--|--|\n|GET|获取资源|GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容|1.0 1.1|\n|POST|传输实体主体|POST 方法用来传输实体的主体。虽然 GET 也可以传输实体的主体，但一般不用 GET 而用 POST，POST 的主要目的并不是获取响应的主体内容|1.0 1.1|\n|PUT|传输文件|PUT方法用来传输文件，要求再请求报文的主体中包含文件内容，然后保存到请求URI指定的位置|1.0 1.1|\n| HEAD |获取报文首部|HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等等|1.0 1.1|\n| DELETE |删除文件|与 PUT 相反的方法，DELETE 方法按请求 URI 删除指定资源|1.0 1.1|\n| OPTIONS |询问支持的方法|OPTIONS 用来查询针对请求 URI 指定的资源支持的方法|1.1|\n| TRACE |追踪路径|TRACE 方法是让 Web 服务器将之前的请求通信返回给客户端的方法，TRACE 方法不常用，并且容易引发 XST ( Cross-Site-Tracing ，跨站追踪)攻击，所以通常更不会用到了|1.1|\n| CONNECT |要求用隧道协议连接代理|CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信，主要使用 SSL （ Secure Sockets Layers ，安全套接层）和 TLS （ Transport Layer Security ，传输层安全）协议把通信内容加密后经网络隧道传输|1.1|\n| PATCH |更新部分文件内容|当资源存在的时候，PATCH 用于资源的部分内容的更新，例如更新某一个字段。具体比如说只更新用户信息的电话号码字段，而 PUT 用于更新某个资源较完整的内容，比如说用户要重填完整表单更新所有信息，后台处理更新时可能只是保留内部记录 ID 不变。  当资源不存在的时候，PATCH 是修改原来的内容，也可能会产生一个新的版本。比如当资源不存在的时候，PATCH 可能会去创建一个新的资源，这个意义上像是 saveOrUpdate 操作。而 PUT 只对已有资源进行更新操作，所以是 update 操作|1.1|\n### 持久链接节省通信量\nHTTP协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。\n#### 持久链接\n为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。它的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。\n#### 管线化(pipelining)\n持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。\n### 使用Cookie的状态管理\nCookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。\n\n## HTTP工作流程\n###  TCP/IP通信传输流\nHTTP协议是站在在TCP/IP协议肩膀上的，从HTTP往下看，是TCP协议保证了运输的可靠性，是IP协议保证了数据可以达到目标地址，是以太网协议在局域网内传递信息。所以说HTTP工作流程，先谈TCP/IP通信传输流。\n![TCP:IP通信传输流.png](https://upload-images.jianshu.io/upload_images/2855070-57fc5e699c7be51f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。\n- 首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。\n- 为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。\n- 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。\n- 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。\n### HTTP请求流程\n![HTTP请求流程.png](https://upload-images.jianshu.io/upload_images/2855070-f5023e4b1746cd1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 发送端在层与层之间传输数据时，每经过一层时必会被打上该层所属的头部信息。\n- 接收端在层与层之间传输数据时，每经过一层时会把对应的头部消去。\n\n具体介绍如下：\n1. 地址解析\n比如我们用百度搜索**swift**\n```\nhttp://www.baidu.com/baidu?wd=swift\n```\n协议名：http。这里指要发出的是什么协议。\n主机名：www.baidu.com。通过DNS解析，我们可以把主机名解析成服务器的IP地址。\n请求文件名：baidu。当我们访问到服务器后，就可以通过文件名请求指定的文件。\n请求参数：wd=swift。即使同一个网页，可能针对不同的用户，服务器要返回给客户端的信息也是不一样的 。而服务器就是通过URL中“?”后面携带的参数不同来响应不同的用户或者同一个用户的不同请求的。\n2. 封装HTTP 请求\n这一步把上面写的 URL 以及本机的一些信息封装成一个 HTTP 请求数据包\n3.  封装 TCP 包\n第三步就是封装 TCP 包 , 建立 TCP 连接 , 也就是常说的\"三次握手\"。\n4. 客户端发送请求命令\n在连接建立之后 , 客户端发送 HTTP 请求到服务端与请求相关的信息都会包含在请求头和请求体中发送给服务器端 。\n5. 服务器端响应\n服务器端在收到请求之后 , 根据客户端的请求发送给客户端相应的信息 , 相关的响应信息都会放在响应头和响应体中。\n6. 关闭连接\n服务器端在发送完响应之后 , 就会关闭连接 , 如果过客户端的请求的头部信息中有 Connection-alive , 那么客户端在响应完这个请求之后不会关闭连接 , 知道客户端的所有请求都响应完毕 , 才会关闭连接 , 这样大大节省了带宽和 IO 资源。\n\n## HTTP协议报文结构\n### 报文\n用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。\n### 报文结构\nHTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。\n报文结构如下：\n\n![HTTP报文结构.png](https://upload-images.jianshu.io/upload_images/2855070-8e774f70956a66cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 请求报文及响应报文的结构\n![请求报文及响应报文的结构.png](https://upload-images.jianshu.io/upload_images/2855070-b6b3c129a6e8e93a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n上面是请求报文，下面是响应报文。\n![请求报文和响应报文实例.png](https://upload-images.jianshu.io/upload_images/2855070-91c78683682246a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n上面是请求报文实例，下面是响应报文实例。\n请求报文和响应报文的首部内容由以下数据组成。\n- 请求行：包含用户请求的方法，请求URI和HTTP版本。\n- 状态行：包含表明响应结果的状态码，原因短语和HTTP版本。\n- 首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有四种首部，分别是：通用首部、请求首部、响应首部和实体首部。\n- 其他：可能包含HTTP的RFC里未定义的首部(Cookie等)。\n\n举个例子：\n我们用**Chrome**浏览器打开百度，然后对当前网页进行检查，右键选择**检查**。然后刷新当前页面，选择`Netword`选项，就可以看到当前页面网络活动情况。查看`www.baidu.com`:\n![例子.png](https://upload-images.jianshu.io/upload_images/2855070-2079c62c209e84ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我们来看一下，这里有什么：\n```\nGeneral：\nRequest URL: https://www.baidu.com/\nRequest Method: GET\nStatus Code: 200 OK\nRemote Address: 180.97.33.108:443\nReferrer Policy: no-referrer-when-downgrade\n````\nResponse Headers：\n```\nHTTP/1.1 200 OK\nBdpagetype: 1\nBdqid: 0xa9952ef000020d8a\nCache-Control: private\nConnection: Keep-Alive\nContent-Encoding: gzip\nContent-Type: text/html\nCxy_all: baidu+9cadcdf18d354de5e0816c739f51f361\nDate: Tue, 30 Oct 2018 08:50:53 GMT\nExpires: Tue, 30 Oct 2018 08:50:27 GMT\nServer: BWS/1.1\nSet-Cookie: delPer=0; path=/; domain=.baidu.com\nSet-Cookie: BDSVRTM=0; path=/\nSet-Cookie: BD_HOME=0; path=/\nSet-Cookie: H_PS_PSSID=26524_1420_21093_27400_26350; path=/; domain=.baidu.com\nStrict-Transport-Security: max-age=172800\nVary: Accept-Encoding\nX-Ua-Compatible: IE=Edge,chrome=1\nTransfer-Encoding: chunked\n```\nRequest Headers:\n```\nGET / HTTP/1.1\nHost: www.baidu.com\nConnection: keep-alive\nPragma: no-cache\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,zh-TW;q=0.8\nCookie: BAIDUID=0A51A4710C9C0407204028C7D18379A0:FG=1; BIDUPSID=0A51A4710C9C0407204028C7D18379A0; PSTM=1529891328; BD_UPN=123253; MCITY=-315%3A; ispeed_lsm=3; delPer=0; BD_HOME=0; H_PS_PSSID=26524_1420_21093_27400_26350; BD_CK_SAM=1; PSINO=3\n```\n## HTTP 报文首部字段具体分析\nHTTP首部字段是构成HTTP报文的要素之一。在客户端与服务端之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。比如给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。\n### HTTP首部字段结构\nHTTP首部字段是由首部字段名和字段值构成，中间用冒号“：”分开。比如上面我们看到的：\n```\nHost: www.baidu.com\nConnection: keep-alive\nPragma: no-cache\n```\n### 4种HTTP首部字段类型\nHTTP首部字段根据实际用途可以分为以下4种：\n- 通用首部字段：请求报文和响应报文两方都会使用的 首部。\n- 请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。\n- 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。\n- 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。\n\n### 通用首部字段\n|首部字段名|说明|\n|--|--|\n| Cache-Control |控制缓存的行为，用于随报文传送缓存的指示|\n| Connection |允许客户端和服务器指定与请求/响应连接有关的选项|\n| Date |提供日期和时间标志，说明报文是什么时间创建的\n|\n| Pragma |报文指令，另一种随报文传送指示的方式，但并不专用于缓存|\n| MIME-Version |给出了发送端使用的 MIME 版本|\n| Trailer |如果报文采用了分块传输编码（chunked transfer encoding）方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合|\n| Transfer- Encoding |告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式|\n| Update |给出了发送端可能想要 “升级” 使用的新版本或协议|\n| Via |显示了报文经过的中间节点（代理、网关）|\n| Warning |错误通知|\n####  Cache-Control\n通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。\n指令的参数是可选的，多个指令之间通过“，”分隔。\n**缓存请求指令**\n|指令|参数|说明|\n|--|--|--|\n| no-cache |无|强制向资源服务器再次验证|\n| no-store |无|不缓存请求或响应的任何内容|\n| max-age = [秒] |必需|响应的最大Age值|\n| max-stale ( = [秒]) |可忽略|接收已过期的响应|\n| min-fresh = [秒] |必需|期望在指定时间内的响应仍有效|\n| no-transform |无|代理不可更改媒体类型|\n| only-if-cached |无|从缓存获取资源|\n| cache-extension |-|新指令标记（token）|\n\n**缓存响应指令**\n|指令|参数|说明|\n|--|--|--|\n| public |无|可向任意方提供响应的缓存|\n| private |可省略|仅向特定用户返回响应|\n| no-cache |可省略|缓存前必须先确认其有效性|\n| no-store |无|不缓存请求或响应的任何内容|\n| no-transform |无|代理不可更改媒体类型|\n| must-revalidate |无|可缓存但必须再向源服务器进行确认|\n| proxy-revalidate |无|要求中间缓存服务器对缓存的响应有效性再进行确认|\n| max-age = [秒] |必需|响应的最大Age值|\n| s-max-age = [秒] |必须|公共缓存服务器响应的最大Age值|\n| cache-extension |-|新指令标记（token）|\n\n### 请求首部字段\n\n|首部字段名|说明|\n|--|--|\n|Accept|用户可处理的媒体类型|\n|Accept- Charset|优先的字符集|\n|Accept- Encoding|优先的编码内容|\n|Accept- Language|优先的语言|\n| TE |传输编码的优先级|\n| Expect |期待服务器的特定行为|\n|If-Match|比较实体标记(ETAG)|\n|If-Modified-Since|比较资源的更新时间|\n|If-None-Match|比较实体标记(与If-Match相反)|\n|If-Range|资源未更新时发送实体Btye的范围请求|\n|If-Unmodified-Since|比较资源的更新时间(与If-Modified-Since相反)|\n| Range |实体的字节范围请求|\n| Authorization |WEB认证信息|\n| Cookie |客户端用它向服务器传送一个令牌|\n| Cookie2 |用来说明请求端支持的 cookie 版本|\n|Max-Forward|在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数|\n|Proxy-Authorization    |代理服务器要求客户端的认证信息|\n### 响应首部字段\n|首部字段名|说明|\n|--|--|\n| Age |推算资源创建经过时间|\n| Public |服务器为其资源支持的请求方法列表|\n|Retry-After    |对再次发起请求的时机要求|\n|Title|对 HTML 文档来说，就是 HTML 文档 的源端给出的标题|\n|Warning|比原因短语中更详细一些的警告报文|\n|Accept-Ranges|服务器可接受的范围类型|\n| Vary |代理服务器的安装信息|\n|Proxy-Authenticate|代理服务器对客户端的认证信息|\n|Set-Cookie|在客户端设置，以便服务器对客户端进行标识|\n|WWW-Authenticate    |服务器对客户端的认证信息|\n### 5. 实体首部字段\n|首部字段名|说明|\n|--|--|\n| Allow |资源可支持的HTTP方法|\n| Location |告知客户端实体实际上位于何处|\n|Content-Base16    |解析主体中的相对 URL 时使用的基础 URL|\n|Content-Encoding|实体主体适用的编码方式|\n|Content-Language|实体主体的自然语言|\n|Content-Length|实体主体的大小(单位：字节)|\n|Content-Location|替代对应资源的URI|\n|Content-MD5|实体主体的报文摘要|\n|Content-Range|实体主体的位置范围|\n| ETag |与此实体相关的实体标记|\n| Expires |实体主体的过期时间|\n|Last-Modified|资源的最后修改日期时间|\n\n### 其他首部字段\nHTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。以下是最为常用的首部字段：\n#### X-Frame-Options\nX-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：\n- DENY：拒绝\n- SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可\n\n####  X-XSS-Protection\nX-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:\n- 0：将 XSS 过滤设置成无效状态\n- 1：将 XSS 过滤设置成有效状态\n\n####  DNT\nDNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：\n- 0：同意被追踪 \n- 1：拒绝被追踪 \n\n####  P3P\nP3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。要进行 P3P 的设定，需按以下操作步骤进行：\n1. 创建 P3P 隐私\n2. 创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml\n3. 从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中\n\n## HTTP响应状态吗\n状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。\n### 状态码类别\n||类别|原因|\n|--|--|--|\n|1XX|nformational（信息性状态码）|接收的请求正在处理|\n|2XX|Success（成功状态码）|请求正常处理完毕|\n|3XX|Redirection（重定向状态码）|需要进行附加操作以完成请求|\n|4XX|Client Error（客户端错误状态码）|服务器无法处理请求|\n|5XX|Server Error（服务器错误状态码|服务器处理请求出错|\n### 状态具体描述\n在 RFC2616 中定义了 40 种 HTTP 状态码，webDAV ( Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制)在 RFC4918 和 RFC5842 中，定义了一些特殊的状态码，在 RFC2518、RFC2817、RFC2295、RFC2774、RFC6585 中还额外定义了一些附加的 HTTP 状态码。总共有 60+ 种。具体链接可以见 [HTTP状态码 (wikipedia)](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)。虽然状态种类繁多，但实际上经常使用的大概有14种，我们简单介绍一下这14种。\n|消息|描述|\n|--|--|\n|200 OK|请求成功（其后是对GET和POST请求的应答文档）|\n|204 No Content|没有新文档。浏览器应该继续显示原来的文档|\n|206 Partial Content|客户发送了一个带有Range头的GET请求，服务器完成了它|\n|301 Moved Permanently|所请求的页面已经转移至新的url|\n|302 Found|所请求的页面已经临时转移至新的url|\n|303 See Other|所请求的页面可在别的url下被找到|\n|304 Not Modified|未按预期修改文档|\n|307 Temporary Redirect|被请求的页面已经临时移至新的url|\n|400 Bad Request|服务器未能理解请求|\n|401 Unauthorized|被请求的页面需要用户名和密码|\n|403 Forbidden|对被请求页面的访问被禁止|\n|404 Not Found|服务器无法找到被请求的页面|\n|500 Internal Server Error|请求未完成，服务器遇到不可预知的情况|\n|503 Service Unavailable|请求未完成，服务器临时过载或当机|\n\n","source":"_posts/网络编程-HTTP协议.md","raw":"---\ntitle: 网络编程 - HTTP协议\ndate: 2018-11-05 14:54:08\ntags: 网络\n---\nHTTP协议，全称超文本传输协议(HyperText Transfer Protocol)，是目前互联网上应用最为广泛的一种网络协议，位于应用层。\n##  HTTP基础\n### HTTP协议用于客户端和服务端之间的通信\n两台计算机之间使用HTTP协议通信时，必有一端是客户端，另外一端是服务器端。其中请求访问资源的一端为客户端，提供资源响应的一端称为服务器端。有时候两台计算机的角色可能会互换，但是仅从一条通信路线来说，客户端和服务器端的角色是确定的。\n### 通过请求和响应的交换达成通信\nHTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。\n### HTTP是不保存状态的协议\nHTTP是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。\n### 请求URI定位资源\nHTTP协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。\n### 告知服务器意图的 HTTP 方法\n|方法名|说明|描述|支持版本|\n--|--|--|--|\n|GET|获取资源|GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容|1.0 1.1|\n|POST|传输实体主体|POST 方法用来传输实体的主体。虽然 GET 也可以传输实体的主体，但一般不用 GET 而用 POST，POST 的主要目的并不是获取响应的主体内容|1.0 1.1|\n|PUT|传输文件|PUT方法用来传输文件，要求再请求报文的主体中包含文件内容，然后保存到请求URI指定的位置|1.0 1.1|\n| HEAD |获取报文首部|HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等等|1.0 1.1|\n| DELETE |删除文件|与 PUT 相反的方法，DELETE 方法按请求 URI 删除指定资源|1.0 1.1|\n| OPTIONS |询问支持的方法|OPTIONS 用来查询针对请求 URI 指定的资源支持的方法|1.1|\n| TRACE |追踪路径|TRACE 方法是让 Web 服务器将之前的请求通信返回给客户端的方法，TRACE 方法不常用，并且容易引发 XST ( Cross-Site-Tracing ，跨站追踪)攻击，所以通常更不会用到了|1.1|\n| CONNECT |要求用隧道协议连接代理|CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信，主要使用 SSL （ Secure Sockets Layers ，安全套接层）和 TLS （ Transport Layer Security ，传输层安全）协议把通信内容加密后经网络隧道传输|1.1|\n| PATCH |更新部分文件内容|当资源存在的时候，PATCH 用于资源的部分内容的更新，例如更新某一个字段。具体比如说只更新用户信息的电话号码字段，而 PUT 用于更新某个资源较完整的内容，比如说用户要重填完整表单更新所有信息，后台处理更新时可能只是保留内部记录 ID 不变。  当资源不存在的时候，PATCH 是修改原来的内容，也可能会产生一个新的版本。比如当资源不存在的时候，PATCH 可能会去创建一个新的资源，这个意义上像是 saveOrUpdate 操作。而 PUT 只对已有资源进行更新操作，所以是 update 操作|1.1|\n### 持久链接节省通信量\nHTTP协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。\n#### 持久链接\n为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。它的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。\n#### 管线化(pipelining)\n持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。\n### 使用Cookie的状态管理\nCookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。\n\n## HTTP工作流程\n###  TCP/IP通信传输流\nHTTP协议是站在在TCP/IP协议肩膀上的，从HTTP往下看，是TCP协议保证了运输的可靠性，是IP协议保证了数据可以达到目标地址，是以太网协议在局域网内传递信息。所以说HTTP工作流程，先谈TCP/IP通信传输流。\n![TCP:IP通信传输流.png](https://upload-images.jianshu.io/upload_images/2855070-57fc5e699c7be51f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。\n- 首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。\n- 为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。\n- 在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。\n- 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。\n### HTTP请求流程\n![HTTP请求流程.png](https://upload-images.jianshu.io/upload_images/2855070-f5023e4b1746cd1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- 发送端在层与层之间传输数据时，每经过一层时必会被打上该层所属的头部信息。\n- 接收端在层与层之间传输数据时，每经过一层时会把对应的头部消去。\n\n具体介绍如下：\n1. 地址解析\n比如我们用百度搜索**swift**\n```\nhttp://www.baidu.com/baidu?wd=swift\n```\n协议名：http。这里指要发出的是什么协议。\n主机名：www.baidu.com。通过DNS解析，我们可以把主机名解析成服务器的IP地址。\n请求文件名：baidu。当我们访问到服务器后，就可以通过文件名请求指定的文件。\n请求参数：wd=swift。即使同一个网页，可能针对不同的用户，服务器要返回给客户端的信息也是不一样的 。而服务器就是通过URL中“?”后面携带的参数不同来响应不同的用户或者同一个用户的不同请求的。\n2. 封装HTTP 请求\n这一步把上面写的 URL 以及本机的一些信息封装成一个 HTTP 请求数据包\n3.  封装 TCP 包\n第三步就是封装 TCP 包 , 建立 TCP 连接 , 也就是常说的\"三次握手\"。\n4. 客户端发送请求命令\n在连接建立之后 , 客户端发送 HTTP 请求到服务端与请求相关的信息都会包含在请求头和请求体中发送给服务器端 。\n5. 服务器端响应\n服务器端在收到请求之后 , 根据客户端的请求发送给客户端相应的信息 , 相关的响应信息都会放在响应头和响应体中。\n6. 关闭连接\n服务器端在发送完响应之后 , 就会关闭连接 , 如果过客户端的请求的头部信息中有 Connection-alive , 那么客户端在响应完这个请求之后不会关闭连接 , 知道客户端的所有请求都响应完毕 , 才会关闭连接 , 这样大大节省了带宽和 IO 资源。\n\n## HTTP协议报文结构\n### 报文\n用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。\n### 报文结构\nHTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。\n报文结构如下：\n\n![HTTP报文结构.png](https://upload-images.jianshu.io/upload_images/2855070-8e774f70956a66cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 请求报文及响应报文的结构\n![请求报文及响应报文的结构.png](https://upload-images.jianshu.io/upload_images/2855070-b6b3c129a6e8e93a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n上面是请求报文，下面是响应报文。\n![请求报文和响应报文实例.png](https://upload-images.jianshu.io/upload_images/2855070-91c78683682246a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n上面是请求报文实例，下面是响应报文实例。\n请求报文和响应报文的首部内容由以下数据组成。\n- 请求行：包含用户请求的方法，请求URI和HTTP版本。\n- 状态行：包含表明响应结果的状态码，原因短语和HTTP版本。\n- 首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有四种首部，分别是：通用首部、请求首部、响应首部和实体首部。\n- 其他：可能包含HTTP的RFC里未定义的首部(Cookie等)。\n\n举个例子：\n我们用**Chrome**浏览器打开百度，然后对当前网页进行检查，右键选择**检查**。然后刷新当前页面，选择`Netword`选项，就可以看到当前页面网络活动情况。查看`www.baidu.com`:\n![例子.png](https://upload-images.jianshu.io/upload_images/2855070-2079c62c209e84ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我们来看一下，这里有什么：\n```\nGeneral：\nRequest URL: https://www.baidu.com/\nRequest Method: GET\nStatus Code: 200 OK\nRemote Address: 180.97.33.108:443\nReferrer Policy: no-referrer-when-downgrade\n````\nResponse Headers：\n```\nHTTP/1.1 200 OK\nBdpagetype: 1\nBdqid: 0xa9952ef000020d8a\nCache-Control: private\nConnection: Keep-Alive\nContent-Encoding: gzip\nContent-Type: text/html\nCxy_all: baidu+9cadcdf18d354de5e0816c739f51f361\nDate: Tue, 30 Oct 2018 08:50:53 GMT\nExpires: Tue, 30 Oct 2018 08:50:27 GMT\nServer: BWS/1.1\nSet-Cookie: delPer=0; path=/; domain=.baidu.com\nSet-Cookie: BDSVRTM=0; path=/\nSet-Cookie: BD_HOME=0; path=/\nSet-Cookie: H_PS_PSSID=26524_1420_21093_27400_26350; path=/; domain=.baidu.com\nStrict-Transport-Security: max-age=172800\nVary: Accept-Encoding\nX-Ua-Compatible: IE=Edge,chrome=1\nTransfer-Encoding: chunked\n```\nRequest Headers:\n```\nGET / HTTP/1.1\nHost: www.baidu.com\nConnection: keep-alive\nPragma: no-cache\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,zh-TW;q=0.8\nCookie: BAIDUID=0A51A4710C9C0407204028C7D18379A0:FG=1; BIDUPSID=0A51A4710C9C0407204028C7D18379A0; PSTM=1529891328; BD_UPN=123253; MCITY=-315%3A; ispeed_lsm=3; delPer=0; BD_HOME=0; H_PS_PSSID=26524_1420_21093_27400_26350; BD_CK_SAM=1; PSINO=3\n```\n## HTTP 报文首部字段具体分析\nHTTP首部字段是构成HTTP报文的要素之一。在客户端与服务端之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。比如给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。\n### HTTP首部字段结构\nHTTP首部字段是由首部字段名和字段值构成，中间用冒号“：”分开。比如上面我们看到的：\n```\nHost: www.baidu.com\nConnection: keep-alive\nPragma: no-cache\n```\n### 4种HTTP首部字段类型\nHTTP首部字段根据实际用途可以分为以下4种：\n- 通用首部字段：请求报文和响应报文两方都会使用的 首部。\n- 请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。\n- 响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。\n- 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。\n\n### 通用首部字段\n|首部字段名|说明|\n|--|--|\n| Cache-Control |控制缓存的行为，用于随报文传送缓存的指示|\n| Connection |允许客户端和服务器指定与请求/响应连接有关的选项|\n| Date |提供日期和时间标志，说明报文是什么时间创建的\n|\n| Pragma |报文指令，另一种随报文传送指示的方式，但并不专用于缓存|\n| MIME-Version |给出了发送端使用的 MIME 版本|\n| Trailer |如果报文采用了分块传输编码（chunked transfer encoding）方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合|\n| Transfer- Encoding |告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式|\n| Update |给出了发送端可能想要 “升级” 使用的新版本或协议|\n| Via |显示了报文经过的中间节点（代理、网关）|\n| Warning |错误通知|\n####  Cache-Control\n通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。\n指令的参数是可选的，多个指令之间通过“，”分隔。\n**缓存请求指令**\n|指令|参数|说明|\n|--|--|--|\n| no-cache |无|强制向资源服务器再次验证|\n| no-store |无|不缓存请求或响应的任何内容|\n| max-age = [秒] |必需|响应的最大Age值|\n| max-stale ( = [秒]) |可忽略|接收已过期的响应|\n| min-fresh = [秒] |必需|期望在指定时间内的响应仍有效|\n| no-transform |无|代理不可更改媒体类型|\n| only-if-cached |无|从缓存获取资源|\n| cache-extension |-|新指令标记（token）|\n\n**缓存响应指令**\n|指令|参数|说明|\n|--|--|--|\n| public |无|可向任意方提供响应的缓存|\n| private |可省略|仅向特定用户返回响应|\n| no-cache |可省略|缓存前必须先确认其有效性|\n| no-store |无|不缓存请求或响应的任何内容|\n| no-transform |无|代理不可更改媒体类型|\n| must-revalidate |无|可缓存但必须再向源服务器进行确认|\n| proxy-revalidate |无|要求中间缓存服务器对缓存的响应有效性再进行确认|\n| max-age = [秒] |必需|响应的最大Age值|\n| s-max-age = [秒] |必须|公共缓存服务器响应的最大Age值|\n| cache-extension |-|新指令标记（token）|\n\n### 请求首部字段\n\n|首部字段名|说明|\n|--|--|\n|Accept|用户可处理的媒体类型|\n|Accept- Charset|优先的字符集|\n|Accept- Encoding|优先的编码内容|\n|Accept- Language|优先的语言|\n| TE |传输编码的优先级|\n| Expect |期待服务器的特定行为|\n|If-Match|比较实体标记(ETAG)|\n|If-Modified-Since|比较资源的更新时间|\n|If-None-Match|比较实体标记(与If-Match相反)|\n|If-Range|资源未更新时发送实体Btye的范围请求|\n|If-Unmodified-Since|比较资源的更新时间(与If-Modified-Since相反)|\n| Range |实体的字节范围请求|\n| Authorization |WEB认证信息|\n| Cookie |客户端用它向服务器传送一个令牌|\n| Cookie2 |用来说明请求端支持的 cookie 版本|\n|Max-Forward|在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数|\n|Proxy-Authorization    |代理服务器要求客户端的认证信息|\n### 响应首部字段\n|首部字段名|说明|\n|--|--|\n| Age |推算资源创建经过时间|\n| Public |服务器为其资源支持的请求方法列表|\n|Retry-After    |对再次发起请求的时机要求|\n|Title|对 HTML 文档来说，就是 HTML 文档 的源端给出的标题|\n|Warning|比原因短语中更详细一些的警告报文|\n|Accept-Ranges|服务器可接受的范围类型|\n| Vary |代理服务器的安装信息|\n|Proxy-Authenticate|代理服务器对客户端的认证信息|\n|Set-Cookie|在客户端设置，以便服务器对客户端进行标识|\n|WWW-Authenticate    |服务器对客户端的认证信息|\n### 5. 实体首部字段\n|首部字段名|说明|\n|--|--|\n| Allow |资源可支持的HTTP方法|\n| Location |告知客户端实体实际上位于何处|\n|Content-Base16    |解析主体中的相对 URL 时使用的基础 URL|\n|Content-Encoding|实体主体适用的编码方式|\n|Content-Language|实体主体的自然语言|\n|Content-Length|实体主体的大小(单位：字节)|\n|Content-Location|替代对应资源的URI|\n|Content-MD5|实体主体的报文摘要|\n|Content-Range|实体主体的位置范围|\n| ETag |与此实体相关的实体标记|\n| Expires |实体主体的过期时间|\n|Last-Modified|资源的最后修改日期时间|\n\n### 其他首部字段\nHTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。以下是最为常用的首部字段：\n#### X-Frame-Options\nX-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：\n- DENY：拒绝\n- SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可\n\n####  X-XSS-Protection\nX-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:\n- 0：将 XSS 过滤设置成无效状态\n- 1：将 XSS 过滤设置成有效状态\n\n####  DNT\nDNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：\n- 0：同意被追踪 \n- 1：拒绝被追踪 \n\n####  P3P\nP3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。要进行 P3P 的设定，需按以下操作步骤进行：\n1. 创建 P3P 隐私\n2. 创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml\n3. 从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中\n\n## HTTP响应状态吗\n状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。\n### 状态码类别\n||类别|原因|\n|--|--|--|\n|1XX|nformational（信息性状态码）|接收的请求正在处理|\n|2XX|Success（成功状态码）|请求正常处理完毕|\n|3XX|Redirection（重定向状态码）|需要进行附加操作以完成请求|\n|4XX|Client Error（客户端错误状态码）|服务器无法处理请求|\n|5XX|Server Error（服务器错误状态码|服务器处理请求出错|\n### 状态具体描述\n在 RFC2616 中定义了 40 种 HTTP 状态码，webDAV ( Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制)在 RFC4918 和 RFC5842 中，定义了一些特殊的状态码，在 RFC2518、RFC2817、RFC2295、RFC2774、RFC6585 中还额外定义了一些附加的 HTTP 状态码。总共有 60+ 种。具体链接可以见 [HTTP状态码 (wikipedia)](https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81)。虽然状态种类繁多，但实际上经常使用的大概有14种，我们简单介绍一下这14种。\n|消息|描述|\n|--|--|\n|200 OK|请求成功（其后是对GET和POST请求的应答文档）|\n|204 No Content|没有新文档。浏览器应该继续显示原来的文档|\n|206 Partial Content|客户发送了一个带有Range头的GET请求，服务器完成了它|\n|301 Moved Permanently|所请求的页面已经转移至新的url|\n|302 Found|所请求的页面已经临时转移至新的url|\n|303 See Other|所请求的页面可在别的url下被找到|\n|304 Not Modified|未按预期修改文档|\n|307 Temporary Redirect|被请求的页面已经临时移至新的url|\n|400 Bad Request|服务器未能理解请求|\n|401 Unauthorized|被请求的页面需要用户名和密码|\n|403 Forbidden|对被请求页面的访问被禁止|\n|404 Not Found|服务器无法找到被请求的页面|\n|500 Internal Server Error|请求未完成，服务器遇到不可预知的情况|\n|503 Service Unavailable|请求未完成，服务器临时过载或当机|\n\n","slug":"网络编程-HTTP协议","published":1,"updated":"2018-11-05T07:01:16.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjphvsxzp00122ycw3xxgv75i","content":"<p>HTTP协议，全称超文本传输协议(HyperText Transfer Protocol)，是目前互联网上应用最为广泛的一种网络协议，位于应用层。</p>\n<h2 id=\"HTTP基础\"><a href=\"#HTTP基础\" class=\"headerlink\" title=\"HTTP基础\"></a>HTTP基础</h2><h3 id=\"HTTP协议用于客户端和服务端之间的通信\"><a href=\"#HTTP协议用于客户端和服务端之间的通信\" class=\"headerlink\" title=\"HTTP协议用于客户端和服务端之间的通信\"></a>HTTP协议用于客户端和服务端之间的通信</h3><p>两台计算机之间使用HTTP协议通信时，必有一端是客户端，另外一端是服务器端。其中请求访问资源的一端为客户端，提供资源响应的一端称为服务器端。有时候两台计算机的角色可能会互换，但是仅从一条通信路线来说，客户端和服务器端的角色是确定的。</p>\n<h3 id=\"通过请求和响应的交换达成通信\"><a href=\"#通过请求和响应的交换达成通信\" class=\"headerlink\" title=\"通过请求和响应的交换达成通信\"></a>通过请求和响应的交换达成通信</h3><p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p>\n<h3 id=\"HTTP是不保存状态的协议\"><a href=\"#HTTP是不保存状态的协议\" class=\"headerlink\" title=\"HTTP是不保存状态的协议\"></a>HTTP是不保存状态的协议</h3><p>HTTP是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p>\n<h3 id=\"请求URI定位资源\"><a href=\"#请求URI定位资源\" class=\"headerlink\" title=\"请求URI定位资源\"></a>请求URI定位资源</h3><p>HTTP协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p>\n<h3 id=\"告知服务器意图的-HTTP-方法\"><a href=\"#告知服务器意图的-HTTP-方法\" class=\"headerlink\" title=\"告知服务器意图的 HTTP 方法\"></a>告知服务器意图的 HTTP 方法</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>方法名</th>\n<th>说明</th>\n<th>描述</th>\n<th>支持版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>GET</td>\n<td>获取资源</td>\n<td>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容</td>\n<td>1.0 1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>POST</td>\n<td>传输实体主体</td>\n<td>POST 方法用来传输实体的主体。虽然 GET 也可以传输实体的主体，但一般不用 GET 而用 POST，POST 的主要目的并不是获取响应的主体内容</td>\n<td>1.0 1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>PUT</td>\n<td>传输文件</td>\n<td>PUT方法用来传输文件，要求再请求报文的主体中包含文件内容，然后保存到请求URI指定的位置</td>\n<td>1.0 1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>HEAD</td>\n<td>获取报文首部</td>\n<td>HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等等</td>\n<td>1.0 1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>DELETE</td>\n<td>删除文件</td>\n<td>与 PUT 相反的方法，DELETE 方法按请求 URI 删除指定资源</td>\n<td>1.0 1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>OPTIONS</td>\n<td>询问支持的方法</td>\n<td>OPTIONS 用来查询针对请求 URI 指定的资源支持的方法</td>\n<td>1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>TRACE</td>\n<td>追踪路径</td>\n<td>TRACE 方法是让 Web 服务器将之前的请求通信返回给客户端的方法，TRACE 方法不常用，并且容易引发 XST ( Cross-Site-Tracing ，跨站追踪)攻击，所以通常更不会用到了</td>\n<td>1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>CONNECT</td>\n<td>要求用隧道协议连接代理</td>\n<td>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信，主要使用 SSL （ Secure Sockets Layers ，安全套接层）和 TLS （ Transport Layer Security ，传输层安全）协议把通信内容加密后经网络隧道传输</td>\n<td>1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>PATCH</td>\n<td>更新部分文件内容</td>\n<td>当资源存在的时候，PATCH 用于资源的部分内容的更新，例如更新某一个字段。具体比如说只更新用户信息的电话号码字段，而 PUT 用于更新某个资源较完整的内容，比如说用户要重填完整表单更新所有信息，后台处理更新时可能只是保留内部记录 ID 不变。  当资源不存在的时候，PATCH 是修改原来的内容，也可能会产生一个新的版本。比如当资源不存在的时候，PATCH 可能会去创建一个新的资源，这个意义上像是 saveOrUpdate 操作。而 PUT 只对已有资源进行更新操作，所以是 update 操作</td>\n<td>1.1</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"持久链接节省通信量\"><a href=\"#持久链接节省通信量\" class=\"headerlink\" title=\"持久链接节省通信量\"></a>持久链接节省通信量</h3><p>HTTP协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。</p>\n<h4 id=\"持久链接\"><a href=\"#持久链接\" class=\"headerlink\" title=\"持久链接\"></a>持久链接</h4><p>为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。它的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>\n<h4 id=\"管线化-pipelining\"><a href=\"#管线化-pipelining\" class=\"headerlink\" title=\"管线化(pipelining)\"></a>管线化(pipelining)</h4><p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p>\n<h3 id=\"使用Cookie的状态管理\"><a href=\"#使用Cookie的状态管理\" class=\"headerlink\" title=\"使用Cookie的状态管理\"></a>使用Cookie的状态管理</h3><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>\n<h2 id=\"HTTP工作流程\"><a href=\"#HTTP工作流程\" class=\"headerlink\" title=\"HTTP工作流程\"></a>HTTP工作流程</h2><h3 id=\"TCP-IP通信传输流\"><a href=\"#TCP-IP通信传输流\" class=\"headerlink\" title=\"TCP/IP通信传输流\"></a>TCP/IP通信传输流</h3><p>HTTP协议是站在在TCP/IP协议肩膀上的，从HTTP往下看，是TCP协议保证了运输的可靠性，是IP协议保证了数据可以达到目标地址，是以太网协议在局域网内传递信息。所以说HTTP工作流程，先谈TCP/IP通信传输流。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-57fc5e699c7be51f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP:IP通信传输流.png\"><br>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。</p>\n<ul>\n<li>首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</li>\n<li>为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li>\n<li>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</li>\n<li><p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</p>\n<h3 id=\"HTTP请求流程\"><a href=\"#HTTP请求流程\" class=\"headerlink\" title=\"HTTP请求流程\"></a>HTTP请求流程</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-f5023e4b1746cd1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"HTTP请求流程.png\"></p>\n</li>\n<li><p>发送端在层与层之间传输数据时，每经过一层时必会被打上该层所属的头部信息。</p>\n</li>\n<li>接收端在层与层之间传输数据时，每经过一层时会把对应的头部消去。</li>\n</ul>\n<p>具体介绍如下：</p>\n<ol>\n<li>地址解析<br>比如我们用百度搜索<strong>swift</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.baidu.com/baidu?wd=swift</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>协议名：http。这里指要发出的是什么协议。<br>主机名：<a href=\"http://www.baidu.com。通过DNS解析，我们可以把主机名解析成服务器的IP地址。\" target=\"_blank\" rel=\"noopener\">www.baidu.com。通过DNS解析，我们可以把主机名解析成服务器的IP地址。</a><br>请求文件名：baidu。当我们访问到服务器后，就可以通过文件名请求指定的文件。<br>请求参数：wd=swift。即使同一个网页，可能针对不同的用户，服务器要返回给客户端的信息也是不一样的 。而服务器就是通过URL中“?”后面携带的参数不同来响应不同的用户或者同一个用户的不同请求的。</p>\n<ol start=\"2\">\n<li>封装HTTP 请求<br>这一步把上面写的 URL 以及本机的一些信息封装成一个 HTTP 请求数据包</li>\n<li>封装 TCP 包<br>第三步就是封装 TCP 包 , 建立 TCP 连接 , 也就是常说的”三次握手”。</li>\n<li>客户端发送请求命令<br>在连接建立之后 , 客户端发送 HTTP 请求到服务端与请求相关的信息都会包含在请求头和请求体中发送给服务器端 。</li>\n<li>服务器端响应<br>服务器端在收到请求之后 , 根据客户端的请求发送给客户端相应的信息 , 相关的响应信息都会放在响应头和响应体中。</li>\n<li>关闭连接<br>服务器端在发送完响应之后 , 就会关闭连接 , 如果过客户端的请求的头部信息中有 Connection-alive , 那么客户端在响应完这个请求之后不会关闭连接 , 知道客户端的所有请求都响应完毕 , 才会关闭连接 , 这样大大节省了带宽和 IO 资源。</li>\n</ol>\n<h2 id=\"HTTP协议报文结构\"><a href=\"#HTTP协议报文结构\" class=\"headerlink\" title=\"HTTP协议报文结构\"></a>HTTP协议报文结构</h2><h3 id=\"报文\"><a href=\"#报文\" class=\"headerlink\" title=\"报文\"></a>报文</h3><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p>\n<h3 id=\"报文结构\"><a href=\"#报文结构\" class=\"headerlink\" title=\"报文结构\"></a>报文结构</h3><p>HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。<br>报文结构如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-8e774f70956a66cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"HTTP报文结构.png\"></p>\n<h3 id=\"请求报文及响应报文的结构\"><a href=\"#请求报文及响应报文的结构\" class=\"headerlink\" title=\"请求报文及响应报文的结构\"></a>请求报文及响应报文的结构</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b6b3c129a6e8e93a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"请求报文及响应报文的结构.png\"><br>上面是请求报文，下面是响应报文。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-91c78683682246a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"请求报文和响应报文实例.png\"><br>上面是请求报文实例，下面是响应报文实例。<br>请求报文和响应报文的首部内容由以下数据组成。</p>\n<ul>\n<li>请求行：包含用户请求的方法，请求URI和HTTP版本。</li>\n<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本。</li>\n<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有四种首部，分别是：通用首部、请求首部、响应首部和实体首部。</li>\n<li>其他：可能包含HTTP的RFC里未定义的首部(Cookie等)。</li>\n</ul>\n<p>举个例子：<br>我们用<strong>Chrome</strong>浏览器打开百度，然后对当前网页进行检查，右键选择<strong>检查</strong>。然后刷新当前页面，选择<code>Netword</code>选项，就可以看到当前页面网络活动情况。查看<code>www.baidu.com</code>:<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-2079c62c209e84ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"例子.png\"><br>我们来看一下，这里有什么：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">General：</span><br><span class=\"line\">Request URL: https://www.baidu.com/</span><br><span class=\"line\">Request Method: GET</span><br><span class=\"line\">Status Code: 200 OK</span><br><span class=\"line\">Remote Address: 180.97.33.108:443</span><br><span class=\"line\">Referrer Policy: no-referrer-when-downgrade</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p>Response Headers：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Bdpagetype: 1</span><br><span class=\"line\">Bdqid: 0xa9952ef000020d8a</span><br><span class=\"line\">Cache-Control: private</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Type: text/html</span><br><span class=\"line\">Cxy_all: baidu+9cadcdf18d354de5e0816c739f51f361</span><br><span class=\"line\">Date: Tue, 30 Oct 2018 08:50:53 GMT</span><br><span class=\"line\">Expires: Tue, 30 Oct 2018 08:50:27 GMT</span><br><span class=\"line\">Server: BWS/1.1</span><br><span class=\"line\">Set-Cookie: delPer=0; path=/; domain=.baidu.com</span><br><span class=\"line\">Set-Cookie: BDSVRTM=0; path=/</span><br><span class=\"line\">Set-Cookie: BD_HOME=0; path=/</span><br><span class=\"line\">Set-Cookie: H_PS_PSSID=26524_1420_21093_27400_26350; path=/; domain=.baidu.com</span><br><span class=\"line\">Strict-Transport-Security: max-age=172800</span><br><span class=\"line\">Vary: Accept-Encoding</span><br><span class=\"line\">X-Ua-Compatible: IE=Edge,chrome=1</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure></p>\n<p>Request Headers:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Pragma: no-cache</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=0.9,zh-TW;q=0.8</span><br><span class=\"line\">Cookie: BAIDUID=0A51A4710C9C0407204028C7D18379A0:FG=1; BIDUPSID=0A51A4710C9C0407204028C7D18379A0; PSTM=1529891328; BD_UPN=123253; MCITY=-315%3A; ispeed_lsm=3; delPer=0; BD_HOME=0; H_PS_PSSID=26524_1420_21093_27400_26350; BD_CK_SAM=1; PSINO=3</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HTTP-报文首部字段具体分析\"><a href=\"#HTTP-报文首部字段具体分析\" class=\"headerlink\" title=\"HTTP 报文首部字段具体分析\"></a>HTTP 报文首部字段具体分析</h2><p>HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务端之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。比如给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>\n<h3 id=\"HTTP首部字段结构\"><a href=\"#HTTP首部字段结构\" class=\"headerlink\" title=\"HTTP首部字段结构\"></a>HTTP首部字段结构</h3><p>HTTP首部字段是由首部字段名和字段值构成，中间用冒号“：”分开。比如上面我们看到的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host: www.baidu.com</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Pragma: no-cache</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4种HTTP首部字段类型\"><a href=\"#4种HTTP首部字段类型\" class=\"headerlink\" title=\"4种HTTP首部字段类型\"></a>4种HTTP首部字段类型</h3><p>HTTP首部字段根据实际用途可以分为以下4种：</p>\n<ul>\n<li>通用首部字段：请求报文和响应报文两方都会使用的 首部。</li>\n<li>请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>\n<li>响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>\n<li>实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li>\n</ul>\n<h3 id=\"通用首部字段\"><a href=\"#通用首部字段\" class=\"headerlink\" title=\"通用首部字段\"></a>通用首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cache-Control</td>\n<td>控制缓存的行为，用于随报文传送缓存的指示</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>允许客户端和服务器指定与请求/响应连接有关的选项</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>提供日期和时间标志，说明报文是什么时间创建的</td>\n</tr>\n<tr>\n<td></td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>报文指令，另一种随报文传送指示的方式，但并不专用于缓存</td>\n</tr>\n<tr>\n<td>MIME-Version</td>\n<td>给出了发送端使用的 MIME 版本</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>如果报文采用了分块传输编码（chunked transfer encoding）方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合</td>\n</tr>\n<tr>\n<td>Transfer- Encoding</td>\n<td>告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</td>\n</tr>\n<tr>\n<td>Update</td>\n<td>给出了发送端可能想要 “升级” 使用的新版本或协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>显示了报文经过的中间节点（代理、网关）</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>错误通知</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。<br>指令的参数是可选的，多个指令之间通过“，”分隔。<br><strong>缓存请求指令</strong><br>|指令|参数|说明|<br>|–|–|–|<br>| no-cache |无|强制向资源服务器再次验证|<br>| no-store |无|不缓存请求或响应的任何内容|<br>| max-age = [秒] |必需|响应的最大Age值|<br>| max-stale ( = [秒]) |可忽略|接收已过期的响应|<br>| min-fresh = [秒] |必需|期望在指定时间内的响应仍有效|<br>| no-transform |无|代理不可更改媒体类型|<br>| only-if-cached |无|从缓存获取资源|<br>| cache-extension |-|新指令标记（token）|</p>\n<p><strong>缓存响应指令</strong><br>|指令|参数|说明|<br>|–|–|–|<br>| public |无|可向任意方提供响应的缓存|<br>| private |可省略|仅向特定用户返回响应|<br>| no-cache |可省略|缓存前必须先确认其有效性|<br>| no-store |无|不缓存请求或响应的任何内容|<br>| no-transform |无|代理不可更改媒体类型|<br>| must-revalidate |无|可缓存但必须再向源服务器进行确认|<br>| proxy-revalidate |无|要求中间缓存服务器对缓存的响应有效性再进行确认|<br>| max-age = [秒] |必需|响应的最大Age值|<br>| s-max-age = [秒] |必须|公共缓存服务器响应的最大Age值|<br>| cache-extension |-|新指令标记（token）|</p>\n<h3 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>用户可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept- Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept- Encoding</td>\n<td>优先的编码内容</td>\n</tr>\n<tr>\n<td>Accept- Language</td>\n<td>优先的语言</td>\n</tr>\n<tr>\n<td>TE</td>\n<td>传输编码的优先级</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待服务器的特定行为</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记(ETAG)</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记(与If-Match相反)</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源未更新时发送实体Btye的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间(与If-Modified-Since相反)</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体的字节范围请求</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>WEB认证信息</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>客户端用它向服务器传送一个令牌</td>\n</tr>\n<tr>\n<td>Cookie2</td>\n<td>用来说明请求端支持的 cookie 版本</td>\n</tr>\n<tr>\n<td>Max-Forward</td>\n<td>在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器要求客户端的认证信息</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"响应首部字段\"><a href=\"#响应首部字段\" class=\"headerlink\" title=\"响应首部字段\"></a>响应首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Age</td>\n<td>推算资源创建经过时间</td>\n</tr>\n<tr>\n<td>Public</td>\n<td>服务器为其资源支持的请求方法列表</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>对再次发起请求的时机要求</td>\n</tr>\n<tr>\n<td>Title</td>\n<td>对 HTML 文档来说，就是 HTML 文档 的源端给出的标题</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>比原因短语中更详细一些的警告报文</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>服务器可接受的范围类型</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>代理服务器的安装信息</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>代理服务器对客户端的认证信息</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>在客户端设置，以便服务器对客户端进行标识</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>服务器对客户端的认证信息</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"5-实体首部字段\"><a href=\"#5-实体首部字段\" class=\"headerlink\" title=\"5. 实体首部字段\"></a>5. 实体首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>资源可支持的HTTP方法</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>告知客户端实体实际上位于何处</td>\n</tr>\n<tr>\n<td>Content-Base16</td>\n<td>解析主体中的相对 URL 时使用的基础 URL</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>实体主体适用的编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>实体主体的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>实体主体的大小(单位：字节)</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>替代对应资源的URI</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>实体主体的报文摘要</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>实体主体的位置范围</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>与此实体相关的实体标记</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体主体的过期时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>资源的最后修改日期时间</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"其他首部字段\"><a href=\"#其他首部字段\" class=\"headerlink\" title=\"其他首部字段\"></a>其他首部字段</h3><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。以下是最为常用的首部字段：</p>\n<h4 id=\"X-Frame-Options\"><a href=\"#X-Frame-Options\" class=\"headerlink\" title=\"X-Frame-Options\"></a>X-Frame-Options</h4><p>X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：</p>\n<ul>\n<li>DENY：拒绝</li>\n<li>SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可</li>\n</ul>\n<h4 id=\"X-XSS-Protection\"><a href=\"#X-XSS-Protection\" class=\"headerlink\" title=\"X-XSS-Protection\"></a>X-XSS-Protection</h4><p>X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:</p>\n<ul>\n<li>0：将 XSS 过滤设置成无效状态</li>\n<li>1：将 XSS 过滤设置成有效状态</li>\n</ul>\n<h4 id=\"DNT\"><a href=\"#DNT\" class=\"headerlink\" title=\"DNT\"></a>DNT</h4><p>DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：</p>\n<ul>\n<li>0：同意被追踪 </li>\n<li>1：拒绝被追踪 </li>\n</ul>\n<h4 id=\"P3P\"><a href=\"#P3P\" class=\"headerlink\" title=\"P3P\"></a>P3P</h4><p>P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。要进行 P3P 的设定，需按以下操作步骤进行：</p>\n<ol>\n<li>创建 P3P 隐私</li>\n<li>创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml</li>\n<li>从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</li>\n</ol>\n<h2 id=\"HTTP响应状态吗\"><a href=\"#HTTP响应状态吗\" class=\"headerlink\" title=\"HTTP响应状态吗\"></a>HTTP响应状态吗</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>\n<h3 id=\"状态码类别\"><a href=\"#状态码类别\" class=\"headerlink\" title=\"状态码类别\"></a>状态码类别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>类别</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td>nformational（信息性状态码）</td>\n<td>接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success（成功状态码）</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection（重定向状态码）</td>\n<td>需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error（客户端错误状态码）</td>\n<td>服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error（服务器错误状态码</td>\n<td>服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"状态具体描述\"><a href=\"#状态具体描述\" class=\"headerlink\" title=\"状态具体描述\"></a>状态具体描述</h3><p>在 RFC2616 中定义了 40 种 HTTP 状态码，webDAV ( Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制)在 RFC4918 和 RFC5842 中，定义了一些特殊的状态码，在 RFC2518、RFC2817、RFC2295、RFC2774、RFC6585 中还额外定义了一些附加的 HTTP 状态码。总共有 60+ 种。具体链接可以见 <a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\" target=\"_blank\" rel=\"noopener\">HTTP状态码 (wikipedia)</a>。虽然状态种类繁多，但实际上经常使用的大概有14种，我们简单介绍一下这14种。<br>|消息|描述|<br>|–|–|<br>|200 OK|请求成功（其后是对GET和POST请求的应答文档）|<br>|204 No Content|没有新文档。浏览器应该继续显示原来的文档|<br>|206 Partial Content|客户发送了一个带有Range头的GET请求，服务器完成了它|<br>|301 Moved Permanently|所请求的页面已经转移至新的url|<br>|302 Found|所请求的页面已经临时转移至新的url|<br>|303 See Other|所请求的页面可在别的url下被找到|<br>|304 Not Modified|未按预期修改文档|<br>|307 Temporary Redirect|被请求的页面已经临时移至新的url|<br>|400 Bad Request|服务器未能理解请求|<br>|401 Unauthorized|被请求的页面需要用户名和密码|<br>|403 Forbidden|对被请求页面的访问被禁止|<br>|404 Not Found|服务器无法找到被请求的页面|<br>|500 Internal Server Error|请求未完成，服务器遇到不可预知的情况|<br>|503 Service Unavailable|请求未完成，服务器临时过载或当机|</p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP协议，全称超文本传输协议(HyperText Transfer Protocol)，是目前互联网上应用最为广泛的一种网络协议，位于应用层。</p>\n<h2 id=\"HTTP基础\"><a href=\"#HTTP基础\" class=\"headerlink\" title=\"HTTP基础\"></a>HTTP基础</h2><h3 id=\"HTTP协议用于客户端和服务端之间的通信\"><a href=\"#HTTP协议用于客户端和服务端之间的通信\" class=\"headerlink\" title=\"HTTP协议用于客户端和服务端之间的通信\"></a>HTTP协议用于客户端和服务端之间的通信</h3><p>两台计算机之间使用HTTP协议通信时，必有一端是客户端，另外一端是服务器端。其中请求访问资源的一端为客户端，提供资源响应的一端称为服务器端。有时候两台计算机的角色可能会互换，但是仅从一条通信路线来说，客户端和服务器端的角色是确定的。</p>\n<h3 id=\"通过请求和响应的交换达成通信\"><a href=\"#通过请求和响应的交换达成通信\" class=\"headerlink\" title=\"通过请求和响应的交换达成通信\"></a>通过请求和响应的交换达成通信</h3><p>HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p>\n<h3 id=\"HTTP是不保存状态的协议\"><a href=\"#HTTP是不保存状态的协议\" class=\"headerlink\" title=\"HTTP是不保存状态的协议\"></a>HTTP是不保存状态的协议</h3><p>HTTP是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p>\n<h3 id=\"请求URI定位资源\"><a href=\"#请求URI定位资源\" class=\"headerlink\" title=\"请求URI定位资源\"></a>请求URI定位资源</h3><p>HTTP协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p>\n<h3 id=\"告知服务器意图的-HTTP-方法\"><a href=\"#告知服务器意图的-HTTP-方法\" class=\"headerlink\" title=\"告知服务器意图的 HTTP 方法\"></a>告知服务器意图的 HTTP 方法</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>方法名</th>\n<th>说明</th>\n<th>描述</th>\n<th>支持版本</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>GET</td>\n<td>获取资源</td>\n<td>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容</td>\n<td>1.0 1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>POST</td>\n<td>传输实体主体</td>\n<td>POST 方法用来传输实体的主体。虽然 GET 也可以传输实体的主体，但一般不用 GET 而用 POST，POST 的主要目的并不是获取响应的主体内容</td>\n<td>1.0 1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>PUT</td>\n<td>传输文件</td>\n<td>PUT方法用来传输文件，要求再请求报文的主体中包含文件内容，然后保存到请求URI指定的位置</td>\n<td>1.0 1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>HEAD</td>\n<td>获取报文首部</td>\n<td>HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等等</td>\n<td>1.0 1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>DELETE</td>\n<td>删除文件</td>\n<td>与 PUT 相反的方法，DELETE 方法按请求 URI 删除指定资源</td>\n<td>1.0 1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>OPTIONS</td>\n<td>询问支持的方法</td>\n<td>OPTIONS 用来查询针对请求 URI 指定的资源支持的方法</td>\n<td>1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>TRACE</td>\n<td>追踪路径</td>\n<td>TRACE 方法是让 Web 服务器将之前的请求通信返回给客户端的方法，TRACE 方法不常用，并且容易引发 XST ( Cross-Site-Tracing ，跨站追踪)攻击，所以通常更不会用到了</td>\n<td>1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>CONNECT</td>\n<td>要求用隧道协议连接代理</td>\n<td>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信，主要使用 SSL （ Secure Sockets Layers ，安全套接层）和 TLS （ Transport Layer Security ，传输层安全）协议把通信内容加密后经网络隧道传输</td>\n<td>1.1</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>PATCH</td>\n<td>更新部分文件内容</td>\n<td>当资源存在的时候，PATCH 用于资源的部分内容的更新，例如更新某一个字段。具体比如说只更新用户信息的电话号码字段，而 PUT 用于更新某个资源较完整的内容，比如说用户要重填完整表单更新所有信息，后台处理更新时可能只是保留内部记录 ID 不变。  当资源不存在的时候，PATCH 是修改原来的内容，也可能会产生一个新的版本。比如当资源不存在的时候，PATCH 可能会去创建一个新的资源，这个意义上像是 saveOrUpdate 操作。而 PUT 只对已有资源进行更新操作，所以是 update 操作</td>\n<td>1.1</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"持久链接节省通信量\"><a href=\"#持久链接节省通信量\" class=\"headerlink\" title=\"持久链接节省通信量\"></a>持久链接节省通信量</h3><p>HTTP协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。</p>\n<h4 id=\"持久链接\"><a href=\"#持久链接\" class=\"headerlink\" title=\"持久链接\"></a>持久链接</h4><p>为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。它的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>\n<h4 id=\"管线化-pipelining\"><a href=\"#管线化-pipelining\" class=\"headerlink\" title=\"管线化(pipelining)\"></a>管线化(pipelining)</h4><p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p>\n<h3 id=\"使用Cookie的状态管理\"><a href=\"#使用Cookie的状态管理\" class=\"headerlink\" title=\"使用Cookie的状态管理\"></a>使用Cookie的状态管理</h3><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>\n<h2 id=\"HTTP工作流程\"><a href=\"#HTTP工作流程\" class=\"headerlink\" title=\"HTTP工作流程\"></a>HTTP工作流程</h2><h3 id=\"TCP-IP通信传输流\"><a href=\"#TCP-IP通信传输流\" class=\"headerlink\" title=\"TCP/IP通信传输流\"></a>TCP/IP通信传输流</h3><p>HTTP协议是站在在TCP/IP协议肩膀上的，从HTTP往下看，是TCP协议保证了运输的可靠性，是IP协议保证了数据可以达到目标地址，是以太网协议在局域网内传递信息。所以说HTTP工作流程，先谈TCP/IP通信传输流。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-57fc5e699c7be51f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TCP:IP通信传输流.png\"><br>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。</p>\n<ul>\n<li>首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</li>\n<li>为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li>\n<li>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</li>\n<li><p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</p>\n<h3 id=\"HTTP请求流程\"><a href=\"#HTTP请求流程\" class=\"headerlink\" title=\"HTTP请求流程\"></a>HTTP请求流程</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-f5023e4b1746cd1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"HTTP请求流程.png\"></p>\n</li>\n<li><p>发送端在层与层之间传输数据时，每经过一层时必会被打上该层所属的头部信息。</p>\n</li>\n<li>接收端在层与层之间传输数据时，每经过一层时会把对应的头部消去。</li>\n</ul>\n<p>具体介绍如下：</p>\n<ol>\n<li>地址解析<br>比如我们用百度搜索<strong>swift</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://www.baidu.com/baidu?wd=swift</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>协议名：http。这里指要发出的是什么协议。<br>主机名：<a href=\"http://www.baidu.com。通过DNS解析，我们可以把主机名解析成服务器的IP地址。\" target=\"_blank\" rel=\"noopener\">www.baidu.com。通过DNS解析，我们可以把主机名解析成服务器的IP地址。</a><br>请求文件名：baidu。当我们访问到服务器后，就可以通过文件名请求指定的文件。<br>请求参数：wd=swift。即使同一个网页，可能针对不同的用户，服务器要返回给客户端的信息也是不一样的 。而服务器就是通过URL中“?”后面携带的参数不同来响应不同的用户或者同一个用户的不同请求的。</p>\n<ol start=\"2\">\n<li>封装HTTP 请求<br>这一步把上面写的 URL 以及本机的一些信息封装成一个 HTTP 请求数据包</li>\n<li>封装 TCP 包<br>第三步就是封装 TCP 包 , 建立 TCP 连接 , 也就是常说的”三次握手”。</li>\n<li>客户端发送请求命令<br>在连接建立之后 , 客户端发送 HTTP 请求到服务端与请求相关的信息都会包含在请求头和请求体中发送给服务器端 。</li>\n<li>服务器端响应<br>服务器端在收到请求之后 , 根据客户端的请求发送给客户端相应的信息 , 相关的响应信息都会放在响应头和响应体中。</li>\n<li>关闭连接<br>服务器端在发送完响应之后 , 就会关闭连接 , 如果过客户端的请求的头部信息中有 Connection-alive , 那么客户端在响应完这个请求之后不会关闭连接 , 知道客户端的所有请求都响应完毕 , 才会关闭连接 , 这样大大节省了带宽和 IO 资源。</li>\n</ol>\n<h2 id=\"HTTP协议报文结构\"><a href=\"#HTTP协议报文结构\" class=\"headerlink\" title=\"HTTP协议报文结构\"></a>HTTP协议报文结构</h2><h3 id=\"报文\"><a href=\"#报文\" class=\"headerlink\" title=\"报文\"></a>报文</h3><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p>\n<h3 id=\"报文结构\"><a href=\"#报文结构\" class=\"headerlink\" title=\"报文结构\"></a>报文结构</h3><p>HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。<br>报文结构如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-8e774f70956a66cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"HTTP报文结构.png\"></p>\n<h3 id=\"请求报文及响应报文的结构\"><a href=\"#请求报文及响应报文的结构\" class=\"headerlink\" title=\"请求报文及响应报文的结构\"></a>请求报文及响应报文的结构</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/2855070-b6b3c129a6e8e93a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"请求报文及响应报文的结构.png\"><br>上面是请求报文，下面是响应报文。<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-91c78683682246a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"请求报文和响应报文实例.png\"><br>上面是请求报文实例，下面是响应报文实例。<br>请求报文和响应报文的首部内容由以下数据组成。</p>\n<ul>\n<li>请求行：包含用户请求的方法，请求URI和HTTP版本。</li>\n<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本。</li>\n<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部。一般有四种首部，分别是：通用首部、请求首部、响应首部和实体首部。</li>\n<li>其他：可能包含HTTP的RFC里未定义的首部(Cookie等)。</li>\n</ul>\n<p>举个例子：<br>我们用<strong>Chrome</strong>浏览器打开百度，然后对当前网页进行检查，右键选择<strong>检查</strong>。然后刷新当前页面，选择<code>Netword</code>选项，就可以看到当前页面网络活动情况。查看<code>www.baidu.com</code>:<br><img src=\"https://upload-images.jianshu.io/upload_images/2855070-2079c62c209e84ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"例子.png\"><br>我们来看一下，这里有什么：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">General：</span><br><span class=\"line\">Request URL: https://www.baidu.com/</span><br><span class=\"line\">Request Method: GET</span><br><span class=\"line\">Status Code: 200 OK</span><br><span class=\"line\">Remote Address: 180.97.33.108:443</span><br><span class=\"line\">Referrer Policy: no-referrer-when-downgrade</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure></p>\n<p>Response Headers：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Bdpagetype: 1</span><br><span class=\"line\">Bdqid: 0xa9952ef000020d8a</span><br><span class=\"line\">Cache-Control: private</span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Type: text/html</span><br><span class=\"line\">Cxy_all: baidu+9cadcdf18d354de5e0816c739f51f361</span><br><span class=\"line\">Date: Tue, 30 Oct 2018 08:50:53 GMT</span><br><span class=\"line\">Expires: Tue, 30 Oct 2018 08:50:27 GMT</span><br><span class=\"line\">Server: BWS/1.1</span><br><span class=\"line\">Set-Cookie: delPer=0; path=/; domain=.baidu.com</span><br><span class=\"line\">Set-Cookie: BDSVRTM=0; path=/</span><br><span class=\"line\">Set-Cookie: BD_HOME=0; path=/</span><br><span class=\"line\">Set-Cookie: H_PS_PSSID=26524_1420_21093_27400_26350; path=/; domain=.baidu.com</span><br><span class=\"line\">Strict-Transport-Security: max-age=172800</span><br><span class=\"line\">Vary: Accept-Encoding</span><br><span class=\"line\">X-Ua-Compatible: IE=Edge,chrome=1</span><br><span class=\"line\">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure></p>\n<p>Request Headers:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Pragma: no-cache</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=0.9,zh-TW;q=0.8</span><br><span class=\"line\">Cookie: BAIDUID=0A51A4710C9C0407204028C7D18379A0:FG=1; BIDUPSID=0A51A4710C9C0407204028C7D18379A0; PSTM=1529891328; BD_UPN=123253; MCITY=-315%3A; ispeed_lsm=3; delPer=0; BD_HOME=0; H_PS_PSSID=26524_1420_21093_27400_26350; BD_CK_SAM=1; PSINO=3</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HTTP-报文首部字段具体分析\"><a href=\"#HTTP-报文首部字段具体分析\" class=\"headerlink\" title=\"HTTP 报文首部字段具体分析\"></a>HTTP 报文首部字段具体分析</h2><p>HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务端之间以HTTP协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。比如给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>\n<h3 id=\"HTTP首部字段结构\"><a href=\"#HTTP首部字段结构\" class=\"headerlink\" title=\"HTTP首部字段结构\"></a>HTTP首部字段结构</h3><p>HTTP首部字段是由首部字段名和字段值构成，中间用冒号“：”分开。比如上面我们看到的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host: www.baidu.com</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Pragma: no-cache</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4种HTTP首部字段类型\"><a href=\"#4种HTTP首部字段类型\" class=\"headerlink\" title=\"4种HTTP首部字段类型\"></a>4种HTTP首部字段类型</h3><p>HTTP首部字段根据实际用途可以分为以下4种：</p>\n<ul>\n<li>通用首部字段：请求报文和响应报文两方都会使用的 首部。</li>\n<li>请求首部字段：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</li>\n<li>响应首部字段：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>\n<li>实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</li>\n</ul>\n<h3 id=\"通用首部字段\"><a href=\"#通用首部字段\" class=\"headerlink\" title=\"通用首部字段\"></a>通用首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cache-Control</td>\n<td>控制缓存的行为，用于随报文传送缓存的指示</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>允许客户端和服务器指定与请求/响应连接有关的选项</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>提供日期和时间标志，说明报文是什么时间创建的</td>\n</tr>\n<tr>\n<td></td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>报文指令，另一种随报文传送指示的方式，但并不专用于缓存</td>\n</tr>\n<tr>\n<td>MIME-Version</td>\n<td>给出了发送端使用的 MIME 版本</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>如果报文采用了分块传输编码（chunked transfer encoding）方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合</td>\n</tr>\n<tr>\n<td>Transfer- Encoding</td>\n<td>告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式</td>\n</tr>\n<tr>\n<td>Update</td>\n<td>给出了发送端可能想要 “升级” 使用的新版本或协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>显示了报文经过的中间节点（代理、网关）</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>错误通知</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。<br>指令的参数是可选的，多个指令之间通过“，”分隔。<br><strong>缓存请求指令</strong><br>|指令|参数|说明|<br>|–|–|–|<br>| no-cache |无|强制向资源服务器再次验证|<br>| no-store |无|不缓存请求或响应的任何内容|<br>| max-age = [秒] |必需|响应的最大Age值|<br>| max-stale ( = [秒]) |可忽略|接收已过期的响应|<br>| min-fresh = [秒] |必需|期望在指定时间内的响应仍有效|<br>| no-transform |无|代理不可更改媒体类型|<br>| only-if-cached |无|从缓存获取资源|<br>| cache-extension |-|新指令标记（token）|</p>\n<p><strong>缓存响应指令</strong><br>|指令|参数|说明|<br>|–|–|–|<br>| public |无|可向任意方提供响应的缓存|<br>| private |可省略|仅向特定用户返回响应|<br>| no-cache |可省略|缓存前必须先确认其有效性|<br>| no-store |无|不缓存请求或响应的任何内容|<br>| no-transform |无|代理不可更改媒体类型|<br>| must-revalidate |无|可缓存但必须再向源服务器进行确认|<br>| proxy-revalidate |无|要求中间缓存服务器对缓存的响应有效性再进行确认|<br>| max-age = [秒] |必需|响应的最大Age值|<br>| s-max-age = [秒] |必须|公共缓存服务器响应的最大Age值|<br>| cache-extension |-|新指令标记（token）|</p>\n<h3 id=\"请求首部字段\"><a href=\"#请求首部字段\" class=\"headerlink\" title=\"请求首部字段\"></a>请求首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Accept</td>\n<td>用户可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept- Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept- Encoding</td>\n<td>优先的编码内容</td>\n</tr>\n<tr>\n<td>Accept- Language</td>\n<td>优先的语言</td>\n</tr>\n<tr>\n<td>TE</td>\n<td>传输编码的优先级</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待服务器的特定行为</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记(ETAG)</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记(与If-Match相反)</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源未更新时发送实体Btye的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间(与If-Modified-Since相反)</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体的字节范围请求</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>WEB认证信息</td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>客户端用它向服务器传送一个令牌</td>\n</tr>\n<tr>\n<td>Cookie2</td>\n<td>用来说明请求端支持的 cookie 版本</td>\n</tr>\n<tr>\n<td>Max-Forward</td>\n<td>在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器要求客户端的认证信息</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"响应首部字段\"><a href=\"#响应首部字段\" class=\"headerlink\" title=\"响应首部字段\"></a>响应首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Age</td>\n<td>推算资源创建经过时间</td>\n</tr>\n<tr>\n<td>Public</td>\n<td>服务器为其资源支持的请求方法列表</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>对再次发起请求的时机要求</td>\n</tr>\n<tr>\n<td>Title</td>\n<td>对 HTML 文档来说，就是 HTML 文档 的源端给出的标题</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>比原因短语中更详细一些的警告报文</td>\n</tr>\n<tr>\n<td>Accept-Ranges</td>\n<td>服务器可接受的范围类型</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>代理服务器的安装信息</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>代理服务器对客户端的认证信息</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>在客户端设置，以便服务器对客户端进行标识</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>服务器对客户端的认证信息</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"5-实体首部字段\"><a href=\"#5-实体首部字段\" class=\"headerlink\" title=\"5. 实体首部字段\"></a>5. 实体首部字段</h3><table>\n<thead>\n<tr>\n<th>首部字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Allow</td>\n<td>资源可支持的HTTP方法</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>告知客户端实体实际上位于何处</td>\n</tr>\n<tr>\n<td>Content-Base16</td>\n<td>解析主体中的相对 URL 时使用的基础 URL</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>实体主体适用的编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>实体主体的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>实体主体的大小(单位：字节)</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>替代对应资源的URI</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>实体主体的报文摘要</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>实体主体的位置范围</td>\n</tr>\n<tr>\n<td>ETag</td>\n<td>与此实体相关的实体标记</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体主体的过期时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>资源的最后修改日期时间</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"其他首部字段\"><a href=\"#其他首部字段\" class=\"headerlink\" title=\"其他首部字段\"></a>其他首部字段</h3><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。以下是最为常用的首部字段：</p>\n<h4 id=\"X-Frame-Options\"><a href=\"#X-Frame-Options\" class=\"headerlink\" title=\"X-Frame-Options\"></a>X-Frame-Options</h4><p>X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：</p>\n<ul>\n<li>DENY：拒绝</li>\n<li>SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可</li>\n</ul>\n<h4 id=\"X-XSS-Protection\"><a href=\"#X-XSS-Protection\" class=\"headerlink\" title=\"X-XSS-Protection\"></a>X-XSS-Protection</h4><p>X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:</p>\n<ul>\n<li>0：将 XSS 过滤设置成无效状态</li>\n<li>1：将 XSS 过滤设置成有效状态</li>\n</ul>\n<h4 id=\"DNT\"><a href=\"#DNT\" class=\"headerlink\" title=\"DNT\"></a>DNT</h4><p>DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：</p>\n<ul>\n<li>0：同意被追踪 </li>\n<li>1：拒绝被追踪 </li>\n</ul>\n<h4 id=\"P3P\"><a href=\"#P3P\" class=\"headerlink\" title=\"P3P\"></a>P3P</h4><p>P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。要进行 P3P 的设定，需按以下操作步骤进行：</p>\n<ol>\n<li>创建 P3P 隐私</li>\n<li>创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml</li>\n<li>从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</li>\n</ol>\n<h2 id=\"HTTP响应状态吗\"><a href=\"#HTTP响应状态吗\" class=\"headerlink\" title=\"HTTP响应状态吗\"></a>HTTP响应状态吗</h2><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>\n<h3 id=\"状态码类别\"><a href=\"#状态码类别\" class=\"headerlink\" title=\"状态码类别\"></a>状态码类别</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>类别</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1XX</td>\n<td>nformational（信息性状态码）</td>\n<td>接收的请求正在处理</td>\n</tr>\n<tr>\n<td>2XX</td>\n<td>Success（成功状态码）</td>\n<td>请求正常处理完毕</td>\n</tr>\n<tr>\n<td>3XX</td>\n<td>Redirection（重定向状态码）</td>\n<td>需要进行附加操作以完成请求</td>\n</tr>\n<tr>\n<td>4XX</td>\n<td>Client Error（客户端错误状态码）</td>\n<td>服务器无法处理请求</td>\n</tr>\n<tr>\n<td>5XX</td>\n<td>Server Error（服务器错误状态码</td>\n<td>服务器处理请求出错</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"状态具体描述\"><a href=\"#状态具体描述\" class=\"headerlink\" title=\"状态具体描述\"></a>状态具体描述</h3><p>在 RFC2616 中定义了 40 种 HTTP 状态码，webDAV ( Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制)在 RFC4918 和 RFC5842 中，定义了一些特殊的状态码，在 RFC2518、RFC2817、RFC2295、RFC2774、RFC6585 中还额外定义了一些附加的 HTTP 状态码。总共有 60+ 种。具体链接可以见 <a href=\"https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\" target=\"_blank\" rel=\"noopener\">HTTP状态码 (wikipedia)</a>。虽然状态种类繁多，但实际上经常使用的大概有14种，我们简单介绍一下这14种。<br>|消息|描述|<br>|–|–|<br>|200 OK|请求成功（其后是对GET和POST请求的应答文档）|<br>|204 No Content|没有新文档。浏览器应该继续显示原来的文档|<br>|206 Partial Content|客户发送了一个带有Range头的GET请求，服务器完成了它|<br>|301 Moved Permanently|所请求的页面已经转移至新的url|<br>|302 Found|所请求的页面已经临时转移至新的url|<br>|303 See Other|所请求的页面可在别的url下被找到|<br>|304 Not Modified|未按预期修改文档|<br>|307 Temporary Redirect|被请求的页面已经临时移至新的url|<br>|400 Bad Request|服务器未能理解请求|<br>|401 Unauthorized|被请求的页面需要用户名和密码|<br>|403 Forbidden|对被请求页面的访问被禁止|<br>|404 Not Found|服务器无法找到被请求的页面|<br>|500 Internal Server Error|请求未完成，服务器遇到不可预知的情况|<br>|503 Service Unavailable|请求未完成，服务器临时过载或当机|</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjphvsxrj00002ycwdrdjrqry","tag_id":"cjphvsxru00022ycwm02jnps5","_id":"cjphvsxs300072ycw3qfi3ii5"},{"post_id":"cjphvsxrz00052ycwkkey1w33","tag_id":"cjphvsxru00022ycwm02jnps5","_id":"cjphvsxs400092ycwjzpxcq5p"},{"post_id":"cjphvsxs300082ycw4lky00qt","tag_id":"cjphvsxru00022ycwm02jnps5","_id":"cjphvsxs7000c2ycw1nqeutj9"},{"post_id":"cjphvsxrr00012ycwe5n2xe39","tag_id":"cjphvsxru00022ycwm02jnps5","_id":"cjphvsxs9000e2ycw9jx98bif"},{"post_id":"cjphvsxs5000a2ycwxpysfsbj","tag_id":"cjphvsxru00022ycwm02jnps5","_id":"cjphvsxsc000h2ycwjqt3gi5w"},{"post_id":"cjphvsxrw00032ycw5tbvc747","tag_id":"cjphvsxru00022ycwm02jnps5","_id":"cjphvsxse000i2ycwdnvqya1f"},{"post_id":"cjphvsxrx00042ycwlw02mm8p","tag_id":"cjphvsxsc000g2ycw2b7ovg9s","_id":"cjphvsxse000k2ycwzjhwo1j0"},{"post_id":"cjphvsxs9000f2ycwlzuha3go","tag_id":"cjphvsxse000j2ycwqoqz2v4d","_id":"cjphvsxse000l2ycwu9w6z9b8"},{"post_id":"cjphvsxxz000m2ycwysey54i7","tag_id":"cjphvsxru00022ycwm02jnps5","_id":"cjphvsxy6000p2ycwpd61ppwx"},{"post_id":"cjphvsxy4000o2ycweh38rjef","tag_id":"cjphvsxru00022ycwm02jnps5","_id":"cjphvsxy8000r2ycw6fb4bswb"},{"post_id":"cjphvsxy6000q2ycwwxqrl2j2","tag_id":"cjphvsxru00022ycwm02jnps5","_id":"cjphvsxya000t2ycw7dw6pp3y"},{"post_id":"cjphvsxy8000s2ycwel4gum3v","tag_id":"cjphvsxru00022ycwm02jnps5","_id":"cjphvsxyb000v2ycwbhrxq7lt"},{"post_id":"cjphvsxya000u2ycw4bfwzo1m","tag_id":"cjphvsxyd000x2ycwlscbey9y","_id":"cjphvsxye000z2ycw5s8xfxbb"},{"post_id":"cjphvsxyb000w2ycwqx2i23k5","tag_id":"cjphvsxyd000y2ycw1pdgqp2p","_id":"cjphvsxye00102ycwmx15bps2"},{"post_id":"cjphvsxzo00112ycw8oqi09sh","tag_id":"cjphvsxyd000y2ycw1pdgqp2p","_id":"cjphvsxzq00132ycwpylbtkqo"},{"post_id":"cjphvsxzp00122ycw3xxgv75i","tag_id":"cjphvsxyd000y2ycw1pdgqp2p","_id":"cjphvsxzq00142ycwit4taowu"}],"Tag":[{"name":"RxSwift","_id":"cjphvsxru00022ycwm02jnps5"},{"name":"swift 冷门方法","_id":"cjphvsxsc000g2ycw2b7ovg9s"},{"name":"其它","_id":"cjphvsxse000j2ycwqoqz2v4d"},{"name":"源码阅读","_id":"cjphvsxyd000x2ycwlscbey9y"},{"name":"网络","_id":"cjphvsxyd000y2ycw1pdgqp2p"}]}}